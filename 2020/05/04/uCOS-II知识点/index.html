<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="uCOS-II知识点"><meta name="keywords" content="uCOS-II,操作系统"><meta name="author" content="gzwang"><meta name="copyright" content="gzwang"><title>uCOS-II知识点 | Rubina の blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">第一章 嵌入式实时操作系统的基本概念</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-uC-OS-II-%E4%B8%AD%E7%9A%84%E4%BB%BB%E5%8A%A1%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">第二章 uC&#x2F;OS-II 中的任务（重点）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.</span> <span class="toc-text">任务的基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E5%A0%86%E6%A0%88"><span class="toc-number">2.2.</span> <span class="toc-text">任务堆栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E6%8E%A7%E5%88%B6%E5%9D%97%E5%8F%8A%E5%85%B6%E9%93%BE%E8%A1%A8"><span class="toc-number">2.3.</span> <span class="toc-text">任务控制块及其链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E5%B0%B1%E7%BB%AA%E8%A1%A8%E5%8F%8A%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6"><span class="toc-number">2.4.</span> <span class="toc-text">任务就绪表及任务调度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">2.5.</span> <span class="toc-text">任务的创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%8C%82%E8%B5%B7%E5%92%8C%E6%81%A2%E5%A4%8D"><span class="toc-number">2.6.</span> <span class="toc-text">任务的挂起和恢复</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-number">2.7.</span> <span class="toc-text">其他任务管理函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#uC-OS-II%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%90%AF%E5%8A%A8"><span class="toc-number">2.8.</span> <span class="toc-text">uC&#x2F;OS-II的初始化和任务的启动</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-uC-OS-II%E7%9A%84%E4%B8%AD%E6%96%AD%E5%92%8C%E6%97%B6%E9%92%9F"><span class="toc-number">3.</span> <span class="toc-text">第三章 uC&#x2F;OS-II的中断和时钟</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%90%8C%E6%AD%A5%E4%B8%8E%E9%80%9A%E4%BF%A1"><span class="toc-number">4.</span> <span class="toc-text">第四章 任务的同步与通信</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BF%A1%E5%8F%B7%E9%87%8F%E9%9B%86"><span class="toc-number">5.</span> <span class="toc-text">第五章 信号量集</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%86%85%E5%AD%98%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D"><span class="toc-number">6.</span> <span class="toc-text">第六章 内存的动态分配</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%9C%A851%E5%8D%95%E7%89%87%E6%9C%BA%E4%B8%8A%E7%A7%BB%E6%A4%8D-uCOS-II"><span class="toc-number">7.</span> <span class="toc-text">第七章 在51单片机上移植 uCOS-II</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%9C%A8ARM7%E4%B8%8A%E7%A7%BB%E6%A4%8DuCOS-II"><span class="toc-number">8.</span> <span class="toc-text">第八章 在ARM7上移植uCOS-II</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B2%E8%B4%A7"><span class="toc-number">9.</span> <span class="toc-text">干货</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://gzwangu.github.io/img/avatar.jpg"></div><div class="author-info__name text-center">gzwang</div><div class="author-info__description text-center">Study and Life growth record</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">32</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">35</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">9</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://crownz.run/">crownZ</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://blog.zyuanlee.cn/">Pandalzy</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://blog.zguolee.cn/">Lee</a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Rubina の blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">uCOS-II知识点</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-04</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/">课程学习</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">7.2k</span><span class="post-meta__separator">|</span><span>阅读时长: 24 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="第一章-嵌入式实时操作系统的基本概念"><a href="#第一章-嵌入式实时操作系统的基本概念" class="headerlink" title="第一章 嵌入式实时操作系统的基本概念"></a>第一章 嵌入式实时操作系统的基本概念</h1><p>第一章都是些基本概念知识，比如：什么是嵌入式操作系统，嵌入式操作系统是支持嵌入式系统工作的操作系统，一般用于比较复杂的嵌入式系统软件开发中；什么又是嵌入式实时操作系统，大多嵌入式系统应用在实时环境中，因此嵌入式操作系统跟实时（Real-Time）操作系统密切联系在一起；典型嵌入式操作系统有哪些，主要有VxWorks、Windows CE、Palm OS、QNX、Linux 和 μC/OS 等。这些东西了解即可，不用死记硬背，换句话说——不考。</p>
<h1 id="第二章-uC-OS-II-中的任务（重点）"><a href="#第二章-uC-OS-II-中的任务（重点）" class="headerlink" title="第二章 uC/OS-II 中的任务（重点）"></a>第二章 uC/OS-II 中的任务（重点）</h1><h2 id="任务的基本概念"><a href="#任务的基本概念" class="headerlink" title="任务的基本概念"></a>任务的基本概念</h2><p>从应用程序设计的角度，uC/OS-II 的任务就是一个<em>线程</em></p>
<p>uC/OS-II 任务的组成：</p>
<ul>
<li>任务代码：任务的执行部分 </li>
<li>任务堆栈：保存任务工作环境 </li>
<li>任务控制块：保存任务的属性</li>
</ul>
<p>uC/OS-II 的任务有两种：</p>
<ul>
<li>用户任务：由应用程序设计者编写的任务</li>
<li>系统任务：系统提供的任务 </li>
</ul>
<p>预定义了两个系统任务：<em>空闲任务</em>和<em>统计任务</em>。系统在某个时间内无用户任务可运行而处于空闲状态，为使 CPU 在没有用户任务可执行时有事可做，uC/OS-II 提供了空闲任务。统计任务每秒计算一次 CPU 在单位时间内被使用的时间，并把计算结果以百分比的形式存放在变量 OSCPUsage 中，以便应用程序通过访问它来了解 CPU 的利用率。</p>
<p>任务的5种状态：睡眠状态、就绪状态、运行状态、等待状态、中断服务状态</p>
<p><img src="task_state_transition.png" alt="任务状态转换图"></p>
<p>uC/OS-II 最多可以对 <em>64</em> 个任务进行管理，其中系统任务（预留）8 个，用户任务 56 个</p>
<p>每个任务都必须具有一个唯一的优先级别，0～63 共 64 个优先级别，数字越小，优先级别越高</p>
<p>在文件 OS_CFG.H 中常数 OS_LOWEST_PRIO 表示最低优先级 </p>
<p>任务个数：OS_LOWEST_PRIO + 1，其中 OS_LOWEST_PRIO 自动赋给空闲任务，OS_LOWEST_PRIO－1 自动赋给统计任务（存在的话）</p>
<p><img src="%E4%BE%8B2-3.png" alt="例2-3"></p>
<p>任务的优先级别为 28 个即 0～27，则最低优先级别的常数 OS_LOWEST_PRIO 值为 27，应用程序中使用了系统提供的空闲任务和统计任务，则应用程序最多可以安排 28-2 = 26 个任务。</p>
<h2 id="任务堆栈"><a href="#任务堆栈" class="headerlink" title="任务堆栈"></a>任务堆栈</h2><p>任务的重要组成部分；每个任务都配有自己的堆栈；满足任务切换和响应中断时保护CPU寄存器中的内容及存储任务私有数据的需要；</p>
<p>在文件 OS_CPU.H 中的数据类型 OS_STK </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> OS_STK;        <span class="comment">//该类型长度为16位 </span></span><br></pre></td></tr></table></figure>

<p>在应用程序中定义 OS_STK 类型的一个数组 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> TASK_STK_SIZE 512	     <span class="comment">//定义堆栈长度 </span></span></span><br><span class="line">OS_STK TaskStk[TASK_STK_SIZE];       <span class="comment">//定义数组</span></span><br></pre></td></tr></table></figure>

<p><img src="OSTaskCreate.png" alt="OSTaskCreate()原型"></p>
<p><img src="%E4%BE%8B2-4.png" alt="例 2-4"></p>
<p>堆栈的增长方向是随系统所使用的处理器不同而不同,例 2-4 是假设使用了支持堆栈向下增长方式的处理器，如果使用堆栈增长方向向上的形式则如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OSTaskCreat(MyTask, &amp;MyTaskAgu, &amp;MyTaskStk[<span class="number">0</span>], <span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<h2 id="任务控制块及其链表"><a href="#任务控制块及其链表" class="headerlink" title="任务控制块及其链表"></a>任务控制块及其链表</h2><p>任务控制块（OS_TCB）：用来记录任务的堆栈指针、任务的当前状态、任务的优先级别等一系列与任务管理有关的属性的表 </p>
<p>用两条链表来管理任务控制块：</p>
<ul>
<li>空任务控制块链表：应用程序调用函数 OSInit() 对 uC/OS-II 系统进行初始化时建立的单向链表 </li>
<li>任务控制块链表：应用程序调用 OSTaskCreate() 创建任务时建立的双向链表</li>
</ul>
<p>OSTCBInit() 的主要任务如下：</p>
<ul>
<li>为被创建任务从空任务控制块链表获取一个任务控制块；</li>
<li>用任务的属性对任务控制块各个成员进行赋值；</li>
<li>把这个任务控制块链入到任务控制块链表；</li>
</ul>
<p>**OSTCBPrioTbl[ ]**：以任务优先级为下标，保存任务控制块指针的数组。</p>
<p>为什么要对TCB进行初始化？ </p>
<ul>
<li>获得任务控制块 </li>
<li>保存任务属性</li>
</ul>
<h2 id="任务就绪表及任务调度"><a href="#任务就绪表及任务调度" class="headerlink" title="任务就绪表及任务调度"></a>任务就绪表及任务调度</h2><p>uC/OS-II进行调度的思想 </p>
<ul>
<li>每时每刻总是让优先级最高的就绪任务处于运行状态 </li>
<li>在系统或用户任务调用系统函数及执行中断服务程序 结束时，调用调度器来确定应该运行的任务并运行它</li>
</ul>
<p><em>任务就绪表</em>：OSRdyTbl[ ]数组，无符号8位数，一个元素可表达8个任务的就绪状态（1/0）</p>
<p>变量 <em>OSRdyGrp</em> 位数对应 OSRdyTbl[ ] 的下标，即组号；状态表示该组有无任务就绪</p>
<p>把优先级看成一个 6 位二进制数，表示范围为 0 ~ 63 共 64 个任务</p>
<ul>
<li>用高 3 位表示 OSRyGrp 的具体数据位（组号），即任务就绪表数组元素的下标</li>
<li>低 3 位表示数组元素的具体数据位（位置号）</li>
</ul>
<p><img src="%E4%BE%8B2-5.png" alt="例 2-5"></p>
<p><em>简单点的方法</em>：不需要把 49 化成二进制再分别取高低三位，直接用 49 / 8 = 6…1 可知应该在 OSRdyTbl[6] 的 D1 位上置 1，同时要把变量 OSRdyGrp 的 D6 位置 1。又如书 P74 例 3-5 给的优先级别 prio = 30 ,用同样方法 30 / 8 = 3…6 可知应该在 OSRdyTbl[3] 的 D6 位上置 1，同时要把变量 OSRdyGrp 的 D3 位置 1。 </p>
<p>OSMapTbl[ ] 是为加快运算速度定义的一个数组，它的各元素值为： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OSMapTbl[<span class="number">0</span>] = <span class="number">00000001B</span>;</span><br><span class="line">OSMapTbl[<span class="number">1</span>] = <span class="number">00000010B</span>; </span><br><span class="line">OSMapTbl[<span class="number">2</span>] = <span class="number">00000100B</span>; </span><br><span class="line">OSMapTbl[<span class="number">3</span>] = <span class="number">00001000B</span>; </span><br><span class="line">OSMapTbl[<span class="number">4</span>] = <span class="number">00010000B</span>; </span><br><span class="line">OSMapTbl[<span class="number">5</span>] = <span class="number">00100000B</span>; </span><br><span class="line">OSMapTbl[<span class="number">6</span>] = <span class="number">01000000B</span>; </span><br><span class="line">OSMapTbl[<span class="number">7</span>] = <span class="number">10000000B</span>;</span><br></pre></td></tr></table></figure>

<p><strong>登记</strong>：在程序中，用下面的代码把优先级别为prio的任务置为就绪状态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OSRdyGrp |= OSMapTbl[prio&gt;&gt;<span class="number">3</span>];   </span><br><span class="line">OSRdyTbl[prio&gt;&gt;<span class="number">3</span>] |= OSMapTbl[prio&amp;<span class="number">0x07</span>]; </span><br></pre></td></tr></table></figure>
<blockquote>
<p>举例 prio = 30 = 011 110<br>OSRdyGrp 的 D3 位置 1<br>OSRdyGrp = OSRdyGrp | OSMapTbl[3] = OSRdyGrp | 00001000<br>OSRdyTbl[3] 的 D6 位置 1<br>OSRdyTbl[3] = OSRdyTbl[3] | OSMapTbl[6] = OSRdyTbl[3] | 01000000</p>
</blockquote>
<p><strong>注销</strong>：使一个优先级别为prio的任务脱离就绪状态 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((OSRdyTbl[prio&gt;&gt;<span class="number">3</span>] &amp;= -OSMapTbl[prio&amp;<span class="number">0x07</span>])==<span class="number">0</span>) </span><br><span class="line">  OSRdyGrp &amp;= -OSMapTbl[prio&gt;&gt;<span class="number">3</span>]; </span><br></pre></td></tr></table></figure>
<blockquote>
<p>举例 prio = 30 = 011 110<br>if(OSRdyTbl[3] &amp;= 10111111 == 0) 将 OSRdyTbl[3] 的 D6 位置 0，如果 OSRdyTbl[3] == 0 即所有任务都处于非就绪状态<br>OSRdyGrp = OSRdyGrp &amp; 11110111   OSRdyGrp 的 D3 位置 0 ，其它位不变 </p>
</blockquote>
<p><strong>查找最高优先级</strong>： 从任务就绪表中获得优先级别最高的就绪任务 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Y = OSUnMapTbl[OSRdyGrp]; 	<span class="comment">//获得优先级别高3位 </span></span><br><span class="line">X = OSUnMapTbl[OSRdyTbl[y]];    <span class="comment">//获得优先级别低3位 </span></span><br><span class="line">Prio = (y&lt;&lt;<span class="number">3</span>) + x; 		<span class="comment">//获得就绪任务的优先级别 </span></span><br><span class="line">或 </span><br><span class="line">Y = OSUnMapTbl[OSRdyGrp]; </span><br><span class="line">Prio = (INT8U)((y&lt;&lt;<span class="number">3</span>) + OSUnMapTbl[OSRdyTbl[y]]); </span><br><span class="line"></span><br><span class="line">INT8U <span class="keyword">const</span> OSUnMapTbl[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, </span><br><span class="line">			    <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, </span><br><span class="line">			    <span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, </span><br><span class="line">			    <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, </span><br><span class="line">			    <span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, </span><br><span class="line">			    <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, </span><br><span class="line">			    <span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, </span><br><span class="line">			    <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, </span><br><span class="line">			    <span class="number">7</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, </span><br><span class="line">			    <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, </span><br><span class="line">			    <span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, </span><br><span class="line">			    <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, </span><br><span class="line">			    <span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, </span><br><span class="line">			    <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, </span><br><span class="line">			    <span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, </span><br><span class="line">			    <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">			    &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>辅助数组 OSUnMapTbl[ ] 的赋值过程（分析较长，可跳过）<br>变量 OSRdyGrp 格式如下：</p>
<table>
<thead>
<tr>
<th align="center">D7</th>
<th align="center">D6</th>
<th align="center">D5</th>
<th align="center">D4</th>
<th align="center">D3</th>
<th align="center">D2</th>
<th align="center">D1</th>
<th align="center">D0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1/0</td>
<td align="center">1/0</td>
<td align="center">1/0</td>
<td align="center">1/0</td>
<td align="center">1/0</td>
<td align="center">1/0</td>
<td align="center">1/0</td>
<td align="center">1/0</td>
</tr>
</tbody></table>
<p>分析 y = OSUnMapTbI[OSRdyGrp]; //优先级高三位</p>
<p>① D0=1时<br>表明OSRdyTbl[0]中有任务就绪，OSRdyTbl[0]中的任务优先级为0-7，则y应该为0，OSRdyGrp为奇数，故数组OSUnMapTbl中以奇数为下标的数组元素都应该为0；<br>② D1=1,D0=0时<br>表明OSRdyTbl[1]中有任务就绪，OSRdyTbl[1]中的任务优先级为8-15，则y应该为1，OSRdyGrp取值为2、6、10、14、18…，故数组 OSUnMapTbl中下标能被2整除且不能被4整除的数组元素值都应该为1；</p>
<p>③ D2=1,D1=0,D0=0时<br>表明OSRdyTbl[2]中有任务就绪，OSRdyTbl[2]中的任务优先级为16-23，则y应该为2，OSRdyGrp取值为4、12、20、28…，故数组 OSUnMapTbl中下标能被4整除且不能被8整除的数组元素值都应该为2；</p>
<p>④ D3=1,D2=0,D1=0,D0=0时<br>表明OSRdyTbl[3]中有任务就绪，OSRdyTbl[3]中的任务优先级为24-31，则y应该为3，OSRdyGrp取值为8、24、40、56…，故数组 OSUnMapTbl中下标能被8整除且不能被16整除的数组元素值都应该为3；</p>
<p>⑤ D4=1,D3=0,D2=0,D1=0,D0=0时<br>表明OSRdyTbl[4]中有任务就绪，OSRdyTbl[4]中的任务优先级为32-39，则y应该为4，OSRdyGrp取值为16、48、64、80…，故数组 OSUnMapTbl中下标能被16整除且不能被32整除的数组元素值都应该为4；</p>
<p>⑥ D5=1,D4=0,D3=0,D2=0,D1=0,D0=0时<br>表明OSRdyTbl[5]中有任务就绪，OSRdyTbl[5]中的任务优先级为40-47，则y应该为5，OSRdyGrp取值为32、96、160、224，故数组 OSUnMapTbl中下标能被32整除且不能被64整除的数组元素值都应该为5；</p>
<p>⑦ D6=1,D5=0,D4=0,D3=0,D2=0,D1=0,D0=0时<br>表明OSRdyTbl[6]中有任务就绪，OSRdyTbl[6]中的任务优先级为48-55，则y应该为6，OSRdyGrp取值为64、192，故数组 OSUnMapTbl中下标能被64整除且不能被128整除的数组元素值都应该为6；</p>
<p>⑧ D7=1,D6=0,D5=0,D4=0,D3=0,D2=0,D1=0,D0=0时<br>表明OSRdyTbl[7]中有任务就绪，OSRdyTbl[7]中的任务优先级为56-63，则y应该为7，OSRdyGrp取值为128，故数组OSUnMapTbl中下标为128的数组元素值应该为7；</p>
<p>调度器有两种：</p>
<ul>
<li>任务级调度器：OSSched() 函数 </li>
<li>中断级调度器：OSIntExit() 函数 </li>
</ul>
<p>任务调度主要工作有两项： </p>
<ul>
<li>在任务就绪表中查找具有最高优先级别的就绪任务 </li>
<li>实现任务切换 <ul>
<li>获得待运行任务的 TCB 指针 </li>
<li>进行断点数据的切换</li>
</ul>
</li>
</ul>
<p><img src="OSSched.png" alt="OSSched 源代码"></p>
<p>任务切换宏 OS_TASK_SW() 实际工作主要由 OSCtxSw 来完成，OSCtxSw() 依次完成的工作</p>
<ol>
<li>把被中止任务的断点指针保存到任务堆栈中</li>
<li>把 CPU 通用寄存器的内容保存到被中止任务的堆栈中 </li>
<li>把被中止任务的任务堆栈指针当前值保存到该任务的任务控制块的 OSTCBStkPtr 中 </li>
<li>获得待运行任务的任务控制块 </li>
<li>使 CPU 通过任务控制块获得待运行任务的任务堆栈指针 </li>
<li>把待运行任务堆栈中通用寄存器的内容恢复到 CPU 的通用寄存器中 </li>
<li>使 CPU 获得待运行任务的断点指针PC </li>
</ol>
<h2 id="任务的创建"><a href="#任务的创建" class="headerlink" title="任务的创建"></a>任务的创建</h2><p>有两个用来创建任务的函数： </p>
<ul>
<li>OSTaskCreate() </li>
<li>OSTaskCreateExt() </li>
</ul>
<p>调用函数OSStart()之前先创建一个任务，并赋予它最高的优先级别，从而使它成为起始任务；然后在这个任务中，再创建其它各任务。</p>
<p><img src="%E4%BE%8B2-7.png" alt="例 2-7"></p>
<p><img src="%E4%BE%8B2-71.jpg" alt="运行结果"></p>
<p>多任务程序分析方法：<em>时间轴法</em><br><img src="%E4%BE%8B2-72.png" alt="程序分析"></p>
<h2 id="任务的挂起和恢复"><a href="#任务的挂起和恢复" class="headerlink" title="任务的挂起和恢复"></a>任务的挂起和恢复</h2><p><img src="OSTaskSuspendResume.png" alt="任务的挂起和恢复"></p>
<p><em>挂起任务</em>函数 OSTaskSuspend() 和<em>恢复任务</em>函数 OSTaskResume() 的原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INT8U <span class="title">OSTaskSuspend</span> <span class="params">(INT8U prio)</span></span>;</span><br><span class="line"><span class="function">INT8U <span class="title">OSTaskResume</span> <span class="params">(INT8U prio)</span></span>;</span><br></pre></td></tr></table></figure>
<p>挂起任务自身时,函数参数为：OS_PRIO_SELF（<em>0xFF</em>） </p>
<h2 id="其他任务管理函数"><a href="#其他任务管理函数" class="headerlink" title="其他任务管理函数"></a>其他任务管理函数</h2><p>任务优先级别的修改 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INT8U <span class="title">OSTaskChangePrio</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">		      INT8U oldprio, <span class="comment">//任务现在的优先级别 </span></span></span></span><br><span class="line"><span class="function"><span class="params">		      INT8U newprio <span class="comment">//要修改的优先级别 </span></span></span></span><br><span class="line"><span class="function"><span class="params">		      )</span></span>;</span><br></pre></td></tr></table></figure>
<p>任务的删除</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INT8U <span class="title">OSTaskDel</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">		INT8U prio <span class="comment">//要删除任务的优先级别 </span></span></span></span><br><span class="line"><span class="function"><span class="params">		)</span></span>; </span><br></pre></td></tr></table></figure>
<ul>
<li>把被删除任务的任务控制块从任务控制块链表中删除，并归还给空任务控制块链表，然后在任务就绪表中把该任务的就绪状态置为0，于是该任务就不能再被调度了 </li>
<li>可以通过调用 OSTaskDel() 来删除任务自身或除了空闲任务之外的其它任务 </li>
<li>删除任务自己时，函数参数为：OS_PRIO_SELF</li>
<li>被动删除的任务，往往存在<em>动态分配资源丢失!!</em></li>
</ul>
<p>一般删除任务的方法</p>
<ul>
<li>提出删除任务请求的任务 A 只负责提出删除任务请求，而删除工作则由被删除任务 B 自己来完成</li>
<li>联络信号：OSTCBDelReq（ B 的任务控制块成员） </li>
<li>A 调用<strong>请求删除任务函数</strong>：OSTaskDelReq() </li>
<li>函数原型：INT8U OSTaskDelReq( INT8U prio ) //待删除任务的优先级别 </li>
<li>提出删除任务请求的调用参数：prio</li>
</ul>
<p>查询任务信息 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INT8U <span class="title">OSTaskQuery</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">		INT8U prio, <span class="comment">//待查任务的优先级别 </span></span></span></span><br><span class="line"><span class="function"><span class="params">		OS_TCB *pdata <span class="comment">//存储任务信息的结构 </span></span></span></span><br><span class="line"><span class="function"><span class="params">		)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="uC-OS-II的初始化和任务的启动"><a href="#uC-OS-II的初始化和任务的启动" class="headerlink" title="uC/OS-II的初始化和任务的启动"></a>uC/OS-II的初始化和任务的启动</h2><p>uC/OS-II的初始化（ OSInit() ） </p>
<ul>
<li>对所有的全局变量和数据结构进行初始化</li>
<li>创建空闲任务OSTaskIdle，并赋之以最低优先级和永远的就绪状态</li>
<li>如果常数 OS_TASK_STAT_EN = 1，则以优先级别为 OS_LOWEST_PRIO - 1 来创建统计任务 </li>
<li>OSInit() 对数据结构初始化 <ul>
<li>主要是创建包括空任务控制快链表在内的 5 个空数据缓冲区 <ul>
<li>空任务控制块链表</li>
<li>空队列控制块链表</li>
<li>空事件控制块链表</li>
<li>空标志组链表</li>
<li>空内存控制块链表</li>
</ul>
</li>
<li>创建数组 OSTCBPrioTbl[OS_LOWEST_PRIO+1]</li>
</ul>
</li>
</ul>
<h1 id="第三章-uC-OS-II的中断和时钟"><a href="#第三章-uC-OS-II的中断和时钟" class="headerlink" title="第三章 uC/OS-II的中断和时钟"></a>第三章 uC/OS-II的中断和时钟</h1><p><strong>中断响应过程</strong></p>
<ul>
<li>系统接收到中断请求后，这时如果CPU处于中断允许状态（即中断是开放的），系统就会中止正在运行的当前任务，而按照中断向量的指向转而去运行中断服务子程序；</li>
<li>当中断服务子程序的运行结束后，系统将会根据情况返回到被中止的任务继续运行或者转向运行另一个具有更高优先级别的就绪任务。</li>
</ul>
<p><strong>临界段</strong><br>在应用程序中经常有些代码段必须不受任何干扰地连续运行，这样的代码段叫做临界段</p>
<p><strong>时钟中断</strong></p>
<ul>
<li>uC/OS-II 用硬件定时器产生周期为毫秒级的周期性中断来实现时钟，最小时钟单位叫<em>时钟节拍</em></li>
<li>时钟节拍中断服务程序 OSTickISR（）</li>
<li>调用时钟节拍服务函数 OSTimeTick（）完成：<ul>
<li>给计数器 OSTime 加 1</li>
<li>遍历所有 TCB，将它们的 OSTCBDly 减 1</li>
<li>若 OSTCBDly 为 0，且任务未被挂起，将其置为就绪态并相应的修改就绪表</li>
</ul>
</li>
</ul>
<p><strong>延时函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">OSTimeDly(INT16U ticks);   <span class="comment">//参数 ticks 以时钟节拍数为单位的延时时间</span></span><br><span class="line"></span><br><span class="line">OSTimeDlyHMSM( </span><br><span class="line">		INT8U hours,    <span class="comment">//时</span></span><br><span class="line">		INT8U minutes,  <span class="comment">//分</span></span><br><span class="line">		INT8U seconds,  <span class="comment">//秒</span></span><br><span class="line">		INT8U milli,    <span class="comment">//毫秒</span></span><br><span class="line">		)；</span><br><span class="line"></span><br><span class="line">INT8U OSTimeDlyResume（INT8U prio）;  <span class="comment">//取消任务延时</span></span><br></pre></td></tr></table></figure>

<h1 id="第四章-任务的同步与通信"><a href="#第四章-任务的同步与通信" class="headerlink" title="第四章 任务的同步与通信"></a>第四章 任务的同步与通信</h1><p><strong>任务同步</strong><br>为实现任务间的合作和无冲突运行，各任务间需建立制约关系。有两种制约关系：</p>
<ul>
<li>直接制约关系：源于任务间的合作</li>
<li>间接制约关系：源于对资源的共享/竞争</li>
</ul>
<p>任务间这种制约性的合作运行机制叫做任务间的<em>同步</em>，系统中的同步是依靠任务间互发消息来保证的！</p>
<p><strong>事件</strong><br>在 uC/OS-II 中，使用信号量、邮箱（消息邮箱）和消息队列这些被称为<strong>事件</strong>的中间环节来实现任务之间的通信。</p>
<ul>
<li><em>信号量</em> 是一类事件，使用它是为了建立一个标志来表示某共享资源被占用的情况</li>
<li>用来传递消息缓冲区指针的数据结构叫做<em>消息邮箱</em></li>
<li>可传递多个消息的数据结构叫做<em>消息队列</em></li>
</ul>
<p><strong>事件控制块</strong><br>uC/OS-II 使用 <em>事件控制块</em> ECB 的数据结构来描述诸如信号量、邮箱（消息邮箱）和消息队列这类事件</p>
<p><img src="ECB.png" alt="事件控制块 ECB"></p>
<p>采用类似于任务就绪表的 <em>任务等待表</em> 来完成对等待事件的任务的记录与排序</p>
<ul>
<li>等待时限记录在 TCB 成员 OSTCBDly 中；</li>
<li>当有任务的时限已到时，将其从任务等待表中删除，并设置任务就续表，使其进入就绪状态；</li>
</ul>
<p><em>空事件控制块链表</em>：uC/OS-II 初始化时，函数 OSInit() 创建 OS_MAX_EVENTS 个空事件控制块并借用成员 OSEventPtr 将它们链接成一个单向链表</p>
<ul>
<li>当新创建一个事件时，从该空事件控制块链表取下一个空 ECB 并对其初始化</li>
<li>当删除一个事件时，将事件的 ECB 归还给空事件控制块链表</li>
</ul>
<p><strong>信号量及其操作</strong><br>信号量两部分组成：</p>
<ul>
<li>信号量计数器</li>
<li>任务等待表</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建信号量 </span></span><br><span class="line"><span class="function">OS_EVENT * <span class="title">OSSemCreate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		       INT16U cnt <span class="comment">// 信号量计数器初值</span></span></span></span><br><span class="line"><span class="function"><span class="params">		       )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求信号量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OSSemPend</span> <span class="params">(OS_EVENT *pevent,  <span class="comment">//信号量的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                INT16U timeout,   <span class="comment">//等待时限</span></span></span></span><br><span class="line"><span class="function"><span class="params">                INT8U *err  	<span class="comment">//错误信息</span></span></span></span><br><span class="line"><span class="function"><span class="params">               )</span></span>;    </span><br><span class="line"><span class="comment">// 信号量请求函数 OSSemAccept() 允许任务在信号量无效时不进入等待状态而继续运行</span></span><br><span class="line"><span class="function">INT16U <span class="title">OSSemAccept</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		   OS_EVENT * pevent <span class="comment">//信号量的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">		   )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送信号量</span></span><br><span class="line"><span class="function">INT8U <span class="title">OSSemPost</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		OS_EVENT * pevent <span class="comment">//信号量的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">		)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>优先级反转</strong></p>
<ul>
<li>定义：在可剥夺型内核中，当某任务以独占方式共享资源时，会出现低优先级任务先于高优先级任务而被运行的现 象，这叫做优先级反转</li>
<li>产生优先级反转的原因：一个低优先级的任务在获得了信号量使用共享资源时，被具有较高优先级的任务打断而不能释放信号量，从而使正在等待这个信号量的更高优先级的任务因得不到信号量而被迫处于等待状态。在这个等待期间，就让优先级别低于它而高于占据信号量的任务的任务先运行</li>
<li>对系统的影响：优先级反转极大的恶化了高优先级任务的运行环境，是实时系统所无法容忍的</li>
</ul>
<p><img src="priority_inversion.png"></p>
<ul>
<li>根本原因：使用信号量的任务能否运行受到 <em>任务的优先级别</em> 和 <em>是否占有信号量</em> 两个条件的约束</li>
<li><strong>互斥型信号量</strong>是一个二值信号量，解决任务在使用独占式资源出现的优先级反转问题</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建互斥信号量</span></span><br><span class="line"><span class="function">OS_EVENT *<span class="title">OSMutexCreate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                        INT8U prio, <span class="comment">// 优先级别</span></span></span></span><br><span class="line"><span class="function"><span class="params">                        INT8U * err <span class="comment">// 错误信息</span></span></span></span><br><span class="line"><span class="function"><span class="params">                        )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求互斥型信号量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OSMutexPend</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                OS_EVENT * pevent, <span class="comment">//互斥型信号量指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                INT16U timeout, <span class="comment">//等待时限</span></span></span></span><br><span class="line"><span class="function"><span class="params">                INT8U * err <span class="comment">//错误信息</span></span></span></span><br><span class="line"><span class="function"><span class="params">                )</span></span>;</span><br><span class="line"><span class="comment">// 也可调用 OSMutexAccept() 无等待的请求信号量</span></span><br><span class="line"><span class="function">INT8U <span class="title">OSMutexAccept</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                    OS_EVENT * pevent, <span class="comment">//互斥型信号量指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    INT8U * err <span class="comment">//错误信息</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    )</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送互斥型信号量</span></span><br><span class="line"><span class="function">INT8U <span class="title">OSMutexPost</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                    OS_EVENT * pevent <span class="comment">//互斥型信号量指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    )</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>消息邮箱及其操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建消息邮箱</span></span><br><span class="line"><span class="function">OS_EVENT * <span class="title">OSMboxCreate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">void</span> * msg <span class="comment">// 消息指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                        )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向邮箱发送消息</span></span><br><span class="line"><span class="function">INT8U <span class="title">OSMboxPost</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                OS_EVENT * pevent, <span class="comment">//消息邮箱指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">void</span> * msg <span class="comment">//消息指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求消息邮箱</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">OSMboxPend</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                OS_EVENT * pevent, <span class="comment">//请求消息邮箱指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                INT16U timeout, <span class="comment">//等待时限</span></span></span></span><br><span class="line"><span class="function"><span class="params">                INT8U * err <span class="comment">//错误信息</span></span></span></span><br><span class="line"><span class="function"><span class="params">                )</span></span>; </span><br><span class="line"><span class="comment">// 也可调用 OSMboxAccept() 无等待请求邮箱</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">OSMboxAccept</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                    OS_EVENT * pevent <span class="comment">//消息邮箱指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    )</span></span>; </span><br></pre></td></tr></table></figure>

<p><strong>消息队列及其操作</strong></p>
<ul>
<li>消息队列包含：事件控制块、消息队列、消息</li>
<li>消息队列的核心是<em>消息指针数组</em></li>
<li>向指针数组插入消息指针有两种方式：FIFO 和  LIFO</li>
<li>uC/OS-II 初始化时，创建由 OS_MAX_QS 个队列控制块组成的 <em>空队列控制块链表</em></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建消息队列</span></span><br><span class="line"><span class="function">OS_EVENT <span class="title">OSQCreate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">void</span> * * start, <span class="comment">//指针数组的地址</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    INT16U size <span class="comment">//数组长度</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求消息队列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">OSQPend</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                OS_EVENT * pevent, <span class="comment">//所请求的消息队列的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                INT16U timeout, <span class="comment">//等待时限</span></span></span></span><br><span class="line"><span class="function"><span class="params">                INT8U * err <span class="comment">//错误信息</span></span></span></span><br><span class="line"><span class="function"><span class="params">                )</span></span>;</span><br><span class="line"><span class="comment">// 调用函数 OSQAccept() 可以无等待的请求队列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">OSQAccept</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                OS_EVENT * pevent <span class="comment">//所请求的消息队列的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向消息队列发送消息</span></span><br><span class="line"><span class="comment">// 以 FIFO 方式组织消息队列</span></span><br><span class="line"><span class="function">INT8U <span class="title">OSQPost</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                OS_EVENT * pevent, <span class="comment">//消息队列的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">void</span> * msg <span class="comment">//消息指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                )</span></span>;</span><br><span class="line"><span class="comment">// 以LIFO方式组织消息队列</span></span><br><span class="line"><span class="function">INT8U <span class="title">OSQPostFront</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                    OS_EVENT * pevent, <span class="comment">//消息队列的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">void</span> * msg <span class="comment">//消息指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    )</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>例  4 -9 （ P180 ）</strong></p>
<p><img src="%E4%BE%8B4-9.png" alt="例 4 - 9"></p>
<p>任务优先级：S&gt;M&gt;Y，后进先出方式发送消息<br>0 秒开始 S 依次发送了s0、s100、s1，延时 1 秒，M 请求消息队列输出 s1，延时 1 秒，Y 请求消息，输出 s100，延时 1 秒，1 秒时，S又发送了 s100 和 s1，同样 M Y 依次请求消息队列，输出 s1 s100，2 秒时，S 没有发送，延时 1 秒，M请求消息队列，输出 s0，Y 没有请求到等待，N 秒时，三个任务都就绪，S发送 s500延时 1 秒，M 请求消息队列，输出 s500，延时1 秒，N+1 秒时，Y 请求消息队列输出 s500，M 等待，N+2 秒时，M 请求消息队列输出 s500，Y 等待。。。</p>
<h1 id="第五章-信号量集"><a href="#第五章-信号量集" class="headerlink" title="第五章 信号量集"></a>第五章 信号量集</h1><p><strong>信号量集由两部分组成：</strong></p>
<ul>
<li>标志组：存放了信号量集中的所有信号</li>
<li>等待任务链表：每个节点都对应一个正在等待信号量集的等待任务</li>
</ul>
<p>uC/OS-II 初始化时，系统创建 OS_MAX_FLAGS 个标志组，并将其连接成一个<em>空标志组链表</em></p>
<p><strong>信号量集的操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建信号量集</span></span><br><span class="line"><span class="function">OS_FLAG_GRP * <span class="title">OSFlagCreate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                            OS_FLAGS flags; <span class="comment">// 信号量的初始值</span></span></span></span><br><span class="line"><span class="function"><span class="params">                            INT8U * err     <span class="comment">// 错误信息</span></span></span></span><br><span class="line"><span class="function"><span class="params">                            )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求信号量集</span></span><br><span class="line"><span class="function">OS_FLAGS <span class="title">OSFlagPend</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                    OS_FLAG_GRP * pgrp, <span class="comment">// 所请求的信号量集的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    OS_FLAGS flags, 	<span class="comment">// 滤波器</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    INT8U wait_type, 	<span class="comment">// 逻辑运算类型</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    INT16U timeout, 	<span class="comment">// 等待时限</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    INT8U *err 	        <span class="comment">// 错误信息</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    )</span></span>;</span><br><span class="line"><span class="comment">// 无等待请求信号量集</span></span><br><span class="line"><span class="function">OS_FLAGS <span class="title">OSFlagAccept</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                    OS_FLAG_GRP * pgrp, <span class="comment">// 所请求的信号量集的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    OS_FLAGS flags, 	<span class="comment">// 滤波器</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    INT8U wait_type, 	<span class="comment">// 逻辑运算类型</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    INT8U *err 	        <span class="comment">// 错误信息</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向信号量集发信号</span></span><br><span class="line"><span class="function">OS_FLAGS <span class="title">OSFlagPost</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                    OS_FLAG_GRP * pgrp, <span class="comment">//信号量集的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    OS_FLAGS flags, <span class="comment">//选择要发送的信号</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    INT8U opt, <span class="comment">//信号有效的选项</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    INT8U *err <span class="comment">//错误信息</span></span></span></span><br><span class="line"><span class="function"><span class="params">                )</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>例 5 - 1 （ P195 ）</strong><a target="_blank" rel="noopener" href="https://github.com/gzwangu/uCOS-II-semaphore-set">源代码</a></p>
<p><img src="%E4%BE%8B5-1.png"></p>
<p><img src="%E4%BE%8B5-11.jpg" alt="例 5 - 1"></p>
<p>任务优先级 MyTask &gt; YouTask &gt; HerTask</p>
<p>任务开始 MyTask 优先级最高请求不到信号量集处于等待状态，YouTask 开始运行，输出 S2，延时 8 秒，接着 HerTask 连续运行，输出 8 个 S3，第 8 秒时，YouTask 运行发送信号量集，这时两个任务都发送了信号，发送完被高优先级 MyTask 打断，MyTask 输出 S1 延时 2 秒，接着 YouTask 继续运行，延时两秒，HerTask 输出 S3 延时 1 秒，到第 9 秒后，HerTask 输出 S3 延时 1 秒，第10 秒，MyTask 输出 S1 延时 2 秒，YouTask 输出 S2，延时 8 秒，HerTask 输出 S3 延时 1 秒…</p>
<p>把 MyTask 修改为无等待请求信号量集 OSFlagAccept()<br><img src="%E4%BE%8B5-2.png" alt="例 5 - 2"></p>
<h1 id="第六章-内存的动态分配"><a href="#第六章-内存的动态分配" class="headerlink" title="第六章 内存的动态分配"></a>第六章 内存的动态分配</h1><p><strong>内存的两级管理</strong><br>把一个连续的内存空间分成若干个分区，每个分区又分成了若干大小相等的内存块来管理</p>
<p><strong>动态内存的管理</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建动态内存分区</span></span><br><span class="line"><span class="function">OS_MEM * <span class="title">OSMemCreate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">void</span> * addr, <span class="comment">//内存分区的起始地址</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    INT32U nblks, <span class="comment">//分区中内存块的数目</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    INT32U blksize, <span class="comment">//每个内存块的字节数</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    INT8U * err <span class="comment">//错误信息</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求获得一个内存块</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">OSMemGet</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                OS_MEM * pmem, <span class="comment">//内存分区的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                INT8U * err <span class="comment">//错误信息</span></span></span></span><br><span class="line"><span class="function"><span class="params">                )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放一个内存块</span></span><br><span class="line"><span class="function">INT8U <span class="title">OSMemPut</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                OS_MEM * pmem, <span class="comment">//内存块所属内存分区的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">void</span> * pblk <span class="comment">//待释放内存块的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                )</span></span>;</span><br></pre></td></tr></table></figure>

<p><img src="%E4%BE%8B6-1.png" alt="例 6 - 1"></p>
<h1 id="第七章-在51单片机上移植-uCOS-II"><a href="#第七章-在51单片机上移植-uCOS-II" class="headerlink" title="第七章 在51单片机上移植 uCOS-II"></a>第七章 在51单片机上移植 uCOS-II</h1><p><strong>可重入函数</strong><br>在多任务操作系统中，系统提供的函数应该能允许同时被多个任务所调用，而不会通过函数中变量的耦合引起任务之间的互相干扰。</p>
<p><strong>系统堆栈</strong><br>片内RAM中的公用堆栈，只存放运行的任务堆栈</p>
<p><strong>任务堆栈映象</strong><br>片外RAM中用来存放任务堆栈内容的区域</p>
<p><strong>系统堆栈与任务堆栈映象的关系</strong></p>
<ul>
<li>51 单片机要求堆栈必须设置在片内RAM中，51单片机的片内 RAM 极其有限，不可能把应用程序中所有任务的任务堆栈都设置在片内RAM中</li>
<li>解决办法：把应用程序中各个任务堆栈的内容存放在片外RAM中的任务堆栈映象中，而只在片内 RAM 中设置一个公用的系统堆栈</li>
</ul>
<h1 id="第八章-在ARM7上移植uCOS-II"><a href="#第八章-在ARM7上移植uCOS-II" class="headerlink" title="第八章 在ARM7上移植uCOS-II"></a>第八章 在ARM7上移植uCOS-II</h1><p><strong>工作模式的选择映像</strong></p>
<p>系统模式和用户模式</p>
<p><strong>处理器相关的移植文件</strong></p>
<ul>
<li>OS_CPU.H</li>
<li>OS_CPU_C.C</li>
<li>OS_CPU_A.S</li>
</ul>
<p>如果你看到这，恭喜这本书的主要内容已经掌握了，考试肯定不是问题，下面分享下干货！</p>
<h1 id="干货"><a href="#干货" class="headerlink" title="干货"></a>干货</h1><p><strong>这是老师给的知识点总结：</strong></p>
<p>第2章 uC/OS-II中的任务<br>1、任务的基本概念<br>2、任务堆栈<br>3、任务控制块<br>4、任务就续表及其操作<br>5、任务调度、任务切换<br>6、任务调度器函数OSSched()<br>7、任务创建<br>8、任务的挂起和恢复<br>9、请求删除任务函数<br>10、任务初始化</p>
<p>第3章 uC/OS-II的中断和时钟<br>1、中断响应过程<br>2、临界段的概念<br>3、时钟中断<br>4、延时函数</p>
<p>第4章 任务的同步与通信<br>1、任务同步<br>2、事件<br>3、事件控制块<br>4、事件的操作（创建、发送、请求）<br>5、优先级反转<br>6、相关例题（例8、例9）</p>
<p>第5章 信号量集<br>1、信号量集<br>2、信号量集的操作（创建、请求和发送）<br>3、相关例题（例1）</p>
<p>第6章 内存的动态分配<br>1、内存的管理<br>2、内存分区的组织<br>3、动态内存的管理（创建、请求、释放）（例1、例2）</p>
<p>第7章 在51单片机上移植uCOS-II<br>1、可重入函数<br>2、系统堆栈和任务堆栈</p>
<p>第8章 在ARM7上移植uCOS-II<br>1、工作模式的选择映像<br>2、与处理器相关的移植文件</p>
<p><strong>在此基础上本人详细的罗列了一些考点：</strong></p>
<p>任务组成<br>两种系统任务<br>64个任务<br>任务5中状态<br>OS_LOWEST_PRIO<br>堆栈增长方向，影响 OSTaskCreate 函数任务堆栈栈顶指针参数  P66<br>OSTCBPrioTbl 数组：以任务的优先级为下标，保存任务的任务控制块指针的数组<br>任务就绪表操作：登记、注销、最高优先级就绪任务查找  会写<br>为什么管理64个任务：OSRdyTbl[ ] 有8个数组元素，每个元素都是8位二进制数，可表示8个任务的就绪状态，所以系统最多可以管理8x8=64个任务<br>OSSched() 函数代码加黑部分要会写 P77<br>任务切换7个步 P79<br>挂起自身  OXFF<br>删除任务过程：提出删除任务请求的任务调用请求删除任务函数，改变联络信号值，当被删除任务查到信号值改变，会在适当的时候删除自身。<br>初始化5个链表：空任务控制块链表、空事件控制块链表、空队列控制块链表、空标志组链表、空内存控制块链表</p>
<p>中断响应过程<br>OSTimeTick 做的三件事  PPT上有，书上说了 2 件，其实也是 3 件<br>OSTimeTick 代码懂且能写出来<br>两个延时函数  OSTimeDly 和 OSTimeDlyHMSM</p>
<p>事件（信号量、消息邮箱、消息队列）的操作（创建、请求、发送）  能看懂代码<br>优先级反转：定义、过程、解决方法（使用互斥信号量）<br>例8  例9   会分析解释  时间轴法</p>
<p>信号量集的操作<br>例1  会分析解释</p>
<p>内存二级管理<br>例1、2  看懂会写吧</p>
<p>可重入函数定义<br>系统/任务堆栈</p>
<p>用户模式/系统模式<br>3个移植文件：OS_CPU.H、OS_CPU_C.C、OS_CPU_A.S</p>
<p><strong>最后个干货，中国矿业大学2019-2020 第一学期嵌入式操作系统 A 卷：</strong></p>
<p>一、简答题（50分）</p>
<ol>
<li>任务的分类</li>
<li>可以管理多少任务？从 OSRdyTbl[ ] 解释之</li>
<li>给一个 prio = 29，注销操作，哪一位置 0</li>
<li>中断响应过程</li>
<li>能否使用全局变量来实现任务间的通信? 如果可以，有什么缺点?</li>
</ol>
<p>二、程序填空（20分，会给注释）</p>
<ol>
<li>任务的创建源代码</li>
<li>OSSched() 函数</li>
<li>OSTimeTick() 函数</li>
<li>写信号量集的请求的例子</li>
</ol>
<p>三、综合（30分，都是书上的例子）</p>
<ol>
<li>任务挂起与恢复</li>
<li>消息队列</li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">gzwang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://gzwangu.github.io/2020/05/04/uCOS-II知识点/">https://gzwangu.github.io/2020/05/04/uCOS-II知识点/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://gzwangu.github.io">Rubina の blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/uCOS-II/">uCOS-II</a><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/05/05/HDL%E5%A4%8D%E4%B9%A0/"><i class="fa fa-chevron-left">  </i><span>HDL复习</span></a></div><div class="next-post pull-right"><a href="/2020/04/25/%E5%9F%BA%E4%BA%8E%E6%A0%91%E8%8E%93%E6%B4%BE%E7%9A%84%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E9%97%A8%E7%A6%81%E7%B3%BB%E7%BB%9F/"><span>基于树莓派的人脸识别门禁系统</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2022 By gzwang</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>