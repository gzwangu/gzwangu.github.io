<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="操作系统"><meta name="keywords" content="操作系统"><meta name="author" content="gzwang"><meta name="copyright" content="gzwang"><title>操作系统 | Rubina の blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E8%AE%BA"><span class="toc-number">1.</span> <span class="toc-text">概论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.</span> <span class="toc-text">操作系统的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">1.2.</span> <span class="toc-text">操作系统的功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">1.3.</span> <span class="toc-text">操作系统的特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.4.</span> <span class="toc-text">操作系统的分类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">进程管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C"><span class="toc-number">2.1.</span> <span class="toc-text">程序的执行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E5%BE%81%E4%B8%8E%E6%8E%A7%E5%88%B6"><span class="toc-number">2.2.</span> <span class="toc-text">进程的特征与控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%8A%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.2.1.</span> <span class="toc-text">进程状态及转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97-PCB"><span class="toc-number">2.2.2.</span> <span class="toc-text">进程控制块 PCB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">2.2.3.</span> <span class="toc-text">进程控制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5"><span class="toc-number">2.3.</span> <span class="toc-text">进程的互斥与同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90%E4%B8%8E%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="toc-number">2.3.1.</span> <span class="toc-text">临界资源与临界区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">2.3.2.</span> <span class="toc-text">进程同步机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98"><span class="toc-number">2.3.3.</span> <span class="toc-text">进程同步经典问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-number">2.4.</span> <span class="toc-text">进程通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">2.5.</span> <span class="toc-text">进程调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.5.1.</span> <span class="toc-text">进程调度模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E9%80%89%E6%8B%A9-%E8%AF%84%E4%BB%B7%E5%87%86%E5%88%99"><span class="toc-number">2.5.2.</span> <span class="toc-text">调度算法选择&#x2F;评价准则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">2.5.3.</span> <span class="toc-text">调度算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">2.6.</span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.7.</span> <span class="toc-text">线程与进程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0"><span class="toc-number">3.1.</span> <span class="toc-text">内存管理概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.1.</span> <span class="toc-text">计算机存储系统的结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.1.2.</span> <span class="toc-text">地址的表示与地址转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">3.1.3.</span> <span class="toc-text">内存管理的功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF"><span class="toc-number">3.1.4.</span> <span class="toc-text">覆盖与交换技术</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">3.2.</span> <span class="toc-text">分区内存管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">3.3.</span> <span class="toc-text">页式存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E8%A1%A8"><span class="toc-number">3.3.1.</span> <span class="toc-text">快表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="toc-number">3.3.2.</span> <span class="toc-text">多级页表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AE%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">3.4.</span> <span class="toc-text">段式存储管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF"><span class="toc-number">3.5.</span> <span class="toc-text">虚拟存储技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">3.6.</span> <span class="toc-text">请求分页虚拟存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E6%94%AF%E6%8C%81"><span class="toc-number">3.6.1.</span> <span class="toc-text">硬件支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%E4%B8%8E%E9%A1%B5%E9%9D%A2%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">3.6.2.</span> <span class="toc-text">页面分配策略与页面调度算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">3.6.3.</span> <span class="toc-text">页面置换算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">设备管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0"><span class="toc-number">4.1.</span> <span class="toc-text">设备管理概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.</span> <span class="toc-text">设备控制方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%8A%80%E6%9C%AF"><span class="toc-number">4.3.</span> <span class="toc-text">缓冲技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%BD%AF%E4%BB%B6"><span class="toc-number">4.4.</span> <span class="toc-text">输入输出软件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6"><span class="toc-number">4.5.</span> <span class="toc-text">设备分配与回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E4%BF%A1%E6%81%AF%E6%8F%8F%E8%BF%B0"><span class="toc-number">4.5.1.</span> <span class="toc-text">设备信息描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-number">4.5.2.</span> <span class="toc-text">设备分配策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SPOOLing-%E6%8A%80%E6%9C%AF-%E5%81%87%E8%84%B1%E6%9C%BA"><span class="toc-number">4.5.3.</span> <span class="toc-text">SPOOLing 技术(假脱机)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">4.5.4.</span> <span class="toc-text">设备分配算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.</span> <span class="toc-text">文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">5.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%84%E7%BB%87"><span class="toc-number">5.2.</span> <span class="toc-text">文件的组织</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E7%BB%84%E7%BB%87"><span class="toc-number">5.2.1.</span> <span class="toc-text">逻辑结构组织</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84%E7%BB%84%E7%BB%87"><span class="toc-number">5.2.2.</span> <span class="toc-text">物理结构组织</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%AD%98%E5%8F%96%E6%96%B9%E6%B3%95"><span class="toc-number">5.2.3.</span> <span class="toc-text">文件的存取方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95"><span class="toc-number">5.3.</span> <span class="toc-text">文件目录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">5.3.1.</span> <span class="toc-text">文件目录的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%84%E7%BB%87"><span class="toc-number">5.3.2.</span> <span class="toc-text">目录文件的组织</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">5.3.3.</span> <span class="toc-text">目录的结构</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://gzwangu.github.io/img/avatar.jpg"></div><div class="author-info__name text-center">gzwang</div><div class="author-info__description text-center">Study and Life growth record</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">31</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">35</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">9</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://crownz.run/">crownZ</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://blog.zyuanlee.cn/">Pandalzy</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://blog.zguolee.cn/">Lee</a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Rubina の blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">操作系统</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-05</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/">课程学习</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">7.5k</span><span class="post-meta__separator">|</span><span>阅读时长: 22 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h1><h2 id="操作系统的定义"><a href="#操作系统的定义" class="headerlink" title="操作系统的定义"></a>操作系统的定义</h2><p>操作系统（OS ）是管理计算机硬件与软件资源的计算机程序。</p>
<h2 id="操作系统的功能"><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a>操作系统的功能</h2><ol>
<li>进程管理——进程线程的状态、控制、同步互斥、通信调度等</li>
<li>内存管理——分配/回收、地址转换、存储保护等</li>
<li>设备管理——设备驱动、分配回收、缓冲技术等</li>
<li>文件管理——文件目录、文件操作、磁盘空间、文件存取控制</li>
</ol>
<h2 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h2><ol>
<li><strong>并发性</strong><br>并发性是两个或多个事件在同一时间间隔内发生的、同时处于活动状态的特性。</li>
<li><strong>共享性</strong><br>主要是指资源共享。内存中并发执行的多个程序可以共享计算机的硬件和软件资源。</li>
<li><strong>虚拟性</strong><br>虚拟性是指将一个物理实体映射为一个或多个逻辑对象。</li>
<li><strong>随机性</strong><br>随机性也叫异步性，指的是每道程序在何时执行、各个程序执行的顺序以及每道程序所需的时间都是不确定的，也是不可预知的。</li>
</ol>
<h2 id="操作系统的分类"><a href="#操作系统的分类" class="headerlink" title="操作系统的分类"></a>操作系统的分类</h2><ol>
<li>批处理操作系统</li>
<li>分时操作系统</li>
<li>实时操作系统</li>
<li>嵌入式操作系统</li>
<li>个人操作系统</li>
<li>网络操作系统</li>
<li>分布式操作系统</li>
</ol>
<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><p>进程就是正在运行的程序及其占用的系统资源，是系统进行资源分配、保护和调度的基本单位。</p>
<h2 id="程序的执行"><a href="#程序的执行" class="headerlink" title="程序的执行"></a>程序的执行</h2><p><strong>程序的顺序执行</strong></p>
<p>一个具有独立功能的程序独占处理器直至最终结束的过程称为程序的顺序执行。</p>
<p>顺序执行有如下三个特点：</p>
<ul>
<li>顺序性</li>
<li>封闭性</li>
<li>可在现性</li>
</ul>
<p><strong>程序的并发执行与并行执行</strong></p>
<p>并行是指多个事件在同一时刻发生，而并发是指多个事件在同一时期内发生。</p>
<p>并行是并发的特例，程序并行执行的硬件前提是系统中有多个 CPU。</p>
<p>并发的本质是一个 CPU 在多个程序运行过程中的时分复用。</p>
<p>并发执行的特性有以下三点：</p>
<ul>
<li>间断性</li>
<li>开放/交互性</li>
<li>不可再现性</li>
</ul>
<h2 id="进程的特征与控制"><a href="#进程的特征与控制" class="headerlink" title="进程的特征与控制"></a>进程的特征与控制</h2><p>进程有以下特性：</p>
<ul>
<li>结构性</li>
<li>动态性</li>
<li>独立性</li>
<li>并发性</li>
</ul>
<p>进程通常分为两类：系统进程和用户进程</p>
<p><code>进程上下文</code>：进程的生命周期中，进程实体和支持进程运行的环境</p>
<h3 id="进程状态及转换"><a href="#进程状态及转换" class="headerlink" title="进程状态及转换"></a>进程状态及转换</h3><p><img src="Process-tristate.png" alt="进程三态模型"></p>
<p><strong>就绪状态</strong>——进程在内存中已经具备执行的条件，等待分配 CPU。<em>就绪队列</em></p>
<p><strong>运行状态</strong>——进程占用 CPU 并正在执行。</p>
<p><strong>阻塞状态</strong>——也成为等待状态。<em>阻塞队列</em></p>
<p><img src="Process-five-states.png" alt="进程五态模型"></p>
<p><strong>新建状态</strong>——进程被创建时所处的状态。</p>
<p><strong>终止状态</strong>——进程正常结束或出现严重错误时，会被操作系统终止或被其它有终止权的进程终止。</p>
<p><img src="Process-seven-states.png" alt="进程七态模型"></p>
<p><strong>挂起就绪</strong>——进程具备运行条件，但目前不在内存中，需要被系统调入内存才能运行。</p>
<p><strong>挂起阻塞</strong>——进程在等待某一事件或条件并且该进程目前不在内存中。</p>
<h3 id="进程控制块-PCB"><a href="#进程控制块-PCB" class="headerlink" title="进程控制块 PCB"></a>进程控制块 PCB</h3><p>描述和控制进程运行的数据结构——进程控制块（进程描述符）</p>
<p>PCB 是进程存在的<code>唯一标志</code></p>
<ol>
<li>进程标识信息——内部标识符和外部标识符 </li>
<li>现场信息——进程运行时 CPU 的即时状态即各寄存器的值</li>
<li>控制信息——操作系统控制进程需要的信息</li>
</ol>
<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p>核心态（内核态）和用户态，也称为管态和目态</p>
<p><strong>进程控制</strong>——系统对进程生命周期的各个环节进行控制</p>
<p>进程控制通常由原语完成。<strong>原语</strong>是由若干条指令所组成，用来实现某个特定功能，在执行过程中不可被中断的程序段。</p>
<p>原语是不可分割的执行单位，原语的执行不可能是并发的。</p>
<ol>
<li>创建进程</li>
<li>撤消与终止进程</li>
<li>阻塞与唤醒进程</li>
<li>挂起与激活进程</li>
</ol>
<h2 id="进程的互斥与同步"><a href="#进程的互斥与同步" class="headerlink" title="进程的互斥与同步"></a>进程的互斥与同步</h2><p>并发运行的多个进程之间存在两种基本关系——竞争（互斥）和协作（同步）</p>
<p>竞争，会引起一下两种极端情况：</p>
<ul>
<li>死锁：一组进程均只占有部分所需资源而无法继续运行，陷入阻塞</li>
<li>饥饿：进程被调度程序长期忽视而分配不到 CPU 执行</li>
</ul>
<h3 id="临界资源与临界区"><a href="#临界资源与临界区" class="headerlink" title="临界资源与临界区"></a>临界资源与临界区</h3><p><strong>临界资源</strong>：在某段时间内只能允许一个进程使用的资源<br><strong>临界区</strong>：访问临界资源的代码段</p>
<p>临界区调度原则：</p>
<ol>
<li>一次至多一个进程能够进入临界区内执行；</li>
<li>如果已有进程在临界区，其它试图进入的进程应等待；</li>
<li>进入临界区内的进程应在有限时间内退出，以便让等待进程中的一个进入；</li>
</ol>
<h3 id="进程同步机制"><a href="#进程同步机制" class="headerlink" title="进程同步机制"></a>进程同步机制</h3><ol>
<li><p>信号量机制</p>
<p>P(s)：将信号量 s 的值减 1，若结果小于 0，则调用 P(s) 的进程被阻塞，并进入信号量 s 的阻塞队列中；若结果不小于 0，则调用 P(s) 的进程继续运行。</p>
<p>V(s)：将信号量 s 的值加 1，若结果不大于 0，则调用 V(s) 的进程从该信号量阻塞队列中释放、唤醒一个处于等待状态的进程，将其转换为就绪状态，调用 V(s) 的进程继续运行；若结果大于0，则调用V(s)的进程继续运行。</p>
<ul>
<li>P 操作意味进程申请一个资源，求而不得则阻塞进程，V 操作意味着释放一个资源，若此时还有进程在等待获取该资源，则被唤醒。</li>
<li>若信号量的值为正数，该正数表示可对信号量可进行的 P 操作的次数，即可用的资源数。信号量的初值一般设为系统中相关资源的总数，对于互斥信号量，初值一般设为 1。</li>
<li>若信号量的值为负，其绝对值表示有多个进程申请该资源而又不能得到，在阻塞队列等待，即在信号量阻塞队列中等待该资源的进程个数。</li>
</ul>
</li>
<li><p>管程同步机制</p>
<p>把临界区集中并封装成抽象数据类型，其中包括与临界资源相关、仅限管程内部访问的公共变量，供管程外的进程调用以访问这些公共变量的接口过程，并提供互斥机制确保进程互斥地使用管程 。</p>
<p>管程具有以下特点：</p>
<ul>
<li>模块化</li>
<li>隐蔽性</li>
<li>互斥性</li>
</ul>
<p>条件变量（condition variable）同步机制</p>
<ul>
<li>让进入管程却因资源不足而阻塞的进程暂时放弃管程控制权（开放管程），进入该条件变量的等待队列 </li>
<li>条件变量只能在管程中通过两个原语操作——wait 原语和 signal 原语 </li>
<li>一个进程已进入管程但无法继续执行，便在相应的条件变量 x 上调用 x.wait( )，将自己阻塞并移入 x 的等待队列中，放弃管程控制权（开放管程），另一进程可以通过对同一个条件变量执行 x.signal( ) 来唤醒之前在 x 上等待的进程  </li>
</ul>
</li>
</ol>
<p><strong>管程与进程的区别：</strong></p>
<ul>
<li>管程把共享变量上的同步操作集中起来，而临界区却分散在每个进程中；</li>
<li>管程是为管理共享资源而建立的，进程主要是为实现系统并发性而引入的；</li>
<li>管程被进程调用，管程和调用它的进程不能并行工作，而进程之间能并行工作，并发性是其固有特性；</li>
<li>管程是语言或操作系统的组成部分，随操作系统启动而装入内存，不必创建或撤销，而进程有生命周期；</li>
</ul>
<h3 id="进程同步经典问题"><a href="#进程同步经典问题" class="headerlink" title="进程同步经典问题"></a>进程同步经典问题</h3><ol>
<li><p>生产者-消费者问题</p>
<p>在并发环境下生产者、消费者进程访问缓冲区的速度不协调、不匹配——不同步，或者没有做到互不影响地使用、更新缓冲区——互斥，所以会出现运行错误甚至是死锁。<img src="Producer-consumer.png" alt="生产者-消费者问题"></p>
</li>
<li><p>读者-写者问题</p>
<ul>
<li>允许多个读者进程同时读文件</li>
<li>只允许一个写者进程写文件</li>
<li>任何一个写者进程在完成写操作之前不允许其它读者或写者工作</li>
<li>写者执行写操作前，应让已有的写者和读者全部退出</li>
</ul>
</li>
<li><p>哲学家就餐问题</p>
<p>五个哲学家围坐在一圆桌旁，桌中央有一盘通心面，每人面前有一只空盘子，每两人之间放一只筷子。每个哲学家的行为是思考，感到饥饿，然后吃通心面。为了吃面，每个哲学家必须拿到两只筷子，并且每个人只能直接从自己的左手边和右手边去取筷子。<img src="Philosopher-dining.png" alt="哲学家就餐问题"></p>
</li>
<li><p>睡眠理发师</p>
<p>理发店里有一个理发师，一把理发椅，N 个供等候顾客休息的椅子。若无顾客，理发师躺在理发椅上睡觉。顾客到来时唤醒理发师，若理发师正在理发，新来的顾客坐在空闲的休息椅上等候，如果没有空椅子，顾客离开。</p>
</li>
</ol>
<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><ol>
<li>消息传递通信</li>
<li>共享内存通信</li>
<li>管道通信</li>
</ol>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><p>两种基本的进程调度方式，抢占方式和非抢占方式，也称剥夺式（preemptive）和非剥夺式（non_preemptive）调度</p>
<h3 id="进程调度模型"><a href="#进程调度模型" class="headerlink" title="进程调度模型"></a>进程调度模型</h3><ul>
<li>高级调度（High-Level Scheduling)，又称为作业调度，它决定把后备作业调入内存运行； </li>
<li>中级调度（Intermediate-Level Scheduling)，又称为平衡调度，在虚拟存储器中引入，在内、外存对换区进行进程对换；</li>
<li>低级调度 (Low-Level Scheduling)：又称为进程调度，它决定就绪队列的某进程获得CPU； <img src="Three-level-scheduling.png" alt="三级调度模型"></li>
</ul>
<h3 id="调度算法选择-评价准则"><a href="#调度算法选择-评价准则" class="headerlink" title="调度算法选择/评价准则"></a>调度算法选择/评价准则</h3><ul>
<li>处理器利用率（CPU utilization）= CPU有效工作时间 / CPU总的运行时间 </li>
<li>响应时间（response time）：交互环境下用户从键盘提交请求开始，到系统首次产生响应为止的时间</li>
<li>周转时间（turnaround time）Ti =  Tf – Ts，即：周转时间 = 完成时刻 - 提交时刻 </li>
<li>带权周转时间—— Wi = 作业的周转时间 Ti / 系统为作业提供的服务时间 Tsi，显然带权周转时间总大于 1 </li>
<li>平均作业周转时间 T = (ΣTi) / n</li>
<li>平均作业带权周转时间W = (ΣWi) / n</li>
</ul>
<h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><p>非剥夺方式：先来先服务、短作业优先、高响应比优先</p>
<p>剥夺方式：最短剩余时间优先、优先权、时间片轮转</p>
<ol>
<li><p>先来先服务（First-Come First-Served，FCFS）——按进程就绪的先后顺序来调度，到达得越早，就越先执行</p>
<ul>
<li>获得CPU的进程，未遇到其它情况时，一直运行下去</li>
<li>是一种非抢占式算法</li>
<li>没有考虑执行时间长短、运行特性和资源的要求</li>
</ul>
<p>系统中现有 5 个作业 A、B、C、D、E 同时提交（到达顺序也为ABCDE），其预计运行时间分别 10、1、2、1、5 个时间单位，如表所示，计算 FCFS 调度下作业的平均周转时间和平均带权周转时间。</p>
<table>
<thead>
<tr>
<th>作业ID</th>
<th>预计需运行时间</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>10</td>
</tr>
<tr>
<td>B</td>
<td>1</td>
</tr>
<tr>
<td>C</td>
<td>2</td>
</tr>
<tr>
<td>D</td>
<td>1</td>
</tr>
<tr>
<td>E</td>
<td>5</td>
</tr>
</tbody></table>
<p>设作业到达时刻为0，根据定义计算，系统运行情况 </p>
<table>
<thead>
<tr>
<th>作业ID</th>
<th>运行时间</th>
<th>等待时间</th>
<th>开始时间</th>
<th>完成时间</th>
<th>周转时间</th>
<th>带权周转时间</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>10</td>
<td>0</td>
<td>0</td>
<td>10</td>
<td>10</td>
<td>1</td>
</tr>
<tr>
<td>B</td>
<td>1</td>
<td>10</td>
<td>10</td>
<td>11</td>
<td>11</td>
<td>11</td>
</tr>
<tr>
<td>C</td>
<td>2</td>
<td>11</td>
<td>11</td>
<td>13</td>
<td>13</td>
<td>6.5</td>
</tr>
<tr>
<td>D</td>
<td>1</td>
<td>13</td>
<td>13</td>
<td>14</td>
<td>14</td>
<td>14</td>
</tr>
<tr>
<td>E</td>
<td>5</td>
<td>14</td>
<td>14</td>
<td>19</td>
<td>19</td>
<td>3.8</td>
</tr>
</tbody></table>
<p>平均周转时间：T =（10+11+13+14+19）/ 5 = 13.4<br>平均带权周转时间：W =（1+11+6.5+14+3.8）/ 5 = 7.26</p>
</li>
<li><p>短作业优先（Shortest-Job-First，SJF）——以进入系统的作业所要求的CPU服务时间为标准，总选取估计所需CPU时间最短的作业优先投入运行</p>
</li>
<li><p>最短剩余时间优先（Shortest Remaining Time First，SRTF）——若一就绪状态的新作业所需的CPU时间比当前正在执行的作业剩余任务所需CPU时间还短，SRTF将打断正在执行作业，将执行权分配给新作业</p>
</li>
<li><p>高响应比优先（Highest Response Ratio First，HRRF）——是 FCFS 与 SJF 两种算法的折衷——既考虑作业等待时间，又考虑作业的运行时间，既照顾短作业又不使长作业等待过久，改善了调度性能，仍属于非抢占式算法</p>
<p>响应比为作业的响应时间与作业所需运行时间之比，简化为：响应比 ＝1 +（已等待的时间 / 估计运行时间）</p>
</li>
<li><p>优先权（Highest-Priority-First，HPF）——根据进程的优先权进行进程调度，每次总是选取优先权高的进程调度，也称优先级调度算法，一般是抢占式调度</p>
</li>
<li><p>时间片轮转（Round-Ribon，RR）——调度程序把CPU分配给进程使用一个规定的时段，称为一个时间片（如100ms），就绪队列中的进程轮流获得CPU的一个时间片。当一个时间片结束时，系统剥夺该进程执行权，等候下一轮调度，属于抢占式调度</p>
</li>
</ol>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p> 死锁产生的原因主要有两个：</p>
<ul>
<li>并发进程对临界资源的竞争</li>
<li>并发进程推进顺序不当</li>
</ul>
<p>死锁发生的四个必要条件：</p>
<ol>
<li>互斥条件</li>
<li>请求与保持条件</li>
<li>不剥夺条件</li>
<li>环路等待条件</li>
</ol>
<p><strong>银行家算法</strong>的思路：</p>
<ol>
<li>在某一时刻，各进程已获得所需的部分资源。有一进程提出新的资源请求，系统将剩余资源试探性地分配给该进程。</li>
<li>如果此时剩余资源能够满足余下的某些进程的需求，则将剩余资源分配给能充分满足的、资源需求缺口最大的进程，运行结束后释放的资源再并入系统的剩余资源集合。</li>
<li>反复执行第 2 步，直到所有的进程都能够获得所需而运行结束。说明第1步的进程请求是可行的，系统处于安全状态，相应的进程执行序列称为系统的安全序列。如果所有的进程都试探过而不能将资源分配给进程，即不存在安全序列，则系统是不安全的。</li>
</ol>
<h2 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h2><ul>
<li>进程是程序在某个数据集合上的一次执行过程，线程是进程内部的一个执行序列</li>
<li>进程是资源分配的最小单位，线程是 CPU 调度的最小单位</li>
<li>一个进程可以包含若干个线程</li>
<li>多个线程共享进程的资源，使用相同的地址空间</li>
<li>进程间切换代价大，线程间切换代价小</li>
<li>进程拥有资源多，线程不拥有自己的资源或只有必要的资源</li>
</ul>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p><strong>MMU</strong> 内存管理单元，也称作分页内存管理单元，把虚拟地址转换成物理地址。<strong>TLB</strong> 是一块高速缓存，缓存虚拟地址和其映射的物理地址，减少CPU访问物理内存的次数，用于改进虚拟地址到物理地址转换速度。</p>
<h2 id="内存管理概述"><a href="#内存管理概述" class="headerlink" title="内存管理概述"></a>内存管理概述</h2><p>计算机的存储系统主要包括内存储器和外存储器</p>
<ul>
<li>内存储器（Memory）即俗称的内存或主存</li>
<li>外存储器也叫辅助存储器</li>
</ul>
<h3 id="计算机存储系统的结构"><a href="#计算机存储系统的结构" class="headerlink" title="计算机存储系统的结构"></a>计算机存储系统的结构</h3><p><img src="Structure-of-storage-system.jpg" alt="计算机系统的结构与使用关系"></p>
<h3 id="地址的表示与地址转换"><a href="#地址的表示与地址转换" class="headerlink" title="地址的表示与地址转换"></a>地址的表示与地址转换</h3><p>只有把程序和数据的逻辑地址转换为物理地址，程序才能正确运行，该过程称为地址转换或地址重定位。地址转换有静态重定位和动态重定位两种方式。</p>
<ul>
<li>静态重定位：这种方式是在用户作业装入内存时由装入程序(装配程序)实现从逻辑地址到物理地址的转换，地址转换在作业执行前一次完成</li>
<li>动态重定位：程序执行过程中，CPU在访问程序和数据之前才实现地址转换。动态重定位必须借助于硬件地址转换机构来实现，硬件系统中设置了一个<strong>定位寄存器</strong>，当操作系统为某程序分配了一块内存区域后，装入程序把程序装入到所分配的区域中，然后把该内存区域的起始地址置入定位寄存器中。在程序执行过程中需要进行地址转换时，只需将逻辑地址与定位寄存器中的值相加就可得到物理地址。这种地址转换方式是在指令过程中进行的，所以称动态重定位。</li>
</ul>
<h3 id="内存管理的功能"><a href="#内存管理的功能" class="headerlink" title="内存管理的功能"></a>内存管理的功能</h3><ol>
<li>内存的分配和回收</li>
<li>提高内存的利用率</li>
<li>通过虚拟存储技术“扩充”内存容量</li>
<li>内存信息保护</li>
</ol>
<h3 id="覆盖与交换技术"><a href="#覆盖与交换技术" class="headerlink" title="覆盖与交换技术"></a>覆盖与交换技术</h3><ol>
<li><p>覆盖技术：按照程序自身的逻辑结构，让不同时执行的程序段先后共享同一块内存区域</p>
<p>例如：某程序由A、B、C、D、E、F等六个程序段组成，它们之间的调用关系如图3.3左图所示。其中，程序段A只调用B和C，程序段B只调用F，而程序段C只调用D和E。由于B和C之间没有相互调用，所以它们可以共享同一覆盖区。覆盖区的大小以能装入所有共享的程序段为准。本例中，与B、C对应的覆盖区的大小为50K。类似地，D、E、F也可以共享一大小为40K的覆盖区，如下图所示。<img src="Coverage-technology.png" alt="覆盖技术"></p>
</li>
<li><p>交换技术：由操作系统根据需要，将某些暂时不运行的进程或程序段从内存移到外存的交换区中；当内存空间富余时再给被移出的进程或程序段重新分配内存，让其进入内存</p>
</li>
</ol>
<h2 id="分区内存管理"><a href="#分区内存管理" class="headerlink" title="分区内存管理"></a>分区内存管理</h2><ol>
<li>单一连续内存管理</li>
<li>固定分区内存管理</li>
<li>可变分区内存管理<ul>
<li>最先适应分配算法</li>
<li>循环首次适应分配算法</li>
<li>最优适应分配算法</li>
<li>最差适应分配算法</li>
<li>快速适应算法</li>
</ul>
</li>
</ol>
<h2 id="页式存储管理"><a href="#页式存储管理" class="headerlink" title="页式存储管理"></a>页式存储管理</h2><p>页：将用户进程的逻辑地址空间划分为大小相等的区，每一个区称为一页或一个页面，并对各页从 0 开始编号，如第 0 页、第 1 页等。</p>
<p>物理块：将物理内存也划分成与页大小相等的区，每一个区称为一个物理块(block)，或称为块、页框，也同样对它们加以编号，如 0 号块、1 号块等。</p>
<p>内存分配的<strong>基本单位</strong>是页，进程的最后一页经常装不满一块，所以会在最后一块内形成不可利用的碎片，称之为“<strong>页内碎片</strong>”。</p>
<p>32 位操作系统其逻辑地址是 32 位，采用页式内存管理，如果每页大小 4096 B，那么页内偏移要占用其逻辑地址的低 12 位，从 0 位开始到 11 位结束。逻辑地址剩余的高 20 位用来表示页号，从 12 位开始到 31 位结束，这样最多允许有 220（1M）个页面。页面的编号从 0 开始，分别为 0，1，2，3 …，220−1，如图所示。</p>
<p><img src="Page-storage.jpg" alt="页式存储的逻辑地址"></p>
<h3 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h3><p>为了提高程序的运行速度，可以将最近访问过的页的页表项信息存放在高速缓存中，高速缓存也称为“联想存储器”，其中的页表称为“快表”。</p>
<h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p>为了能够快速查找页表页在内存中的物理块号，为这些页表页再设计一个地址索引表，即页目录表。二级页表的逻辑地址被划分为三部分： 页目录、页表页、页内偏移</p>
<p><img src="Secondary-page-table.jpg" alt="二级页表结构"></p>
<p><strong>缺页中断</strong>指的是在进程运行过程中，发现所访问的页不在内存中时，CPU的内存管理单元发出的中断。与一般中断：CPU 检测中断时间不同，CPU 可多次处理。</p>
<p><strong>缺页中断处理流程</strong>是：先查看内存是否有空闲块，若有则按该页在外存中的地址将该页找出并装入内存，在页表中填上它占用的块号且修改标志位。若内存已没有空闲块，则必须先淘汰已在内存中的某一页，再将所需的页装入，对页表和内存分配表作相应的修改。淘汰某页时，要查看该页的修改位来判断该页是否修改过，若该页在执行过程中没有被修改过，那么不必重新写回到存储器中，而已修改过的页调出时必须再将该页写回到外存中。</p>
<h2 id="段式存储管理"><a href="#段式存储管理" class="headerlink" title="段式存储管理"></a>段式存储管理</h2><p>分段式存储管理是以段为单位进行内存分配，逻辑地址空间是一个二维空间，分为段号和段内偏移两部分。</p>
<p><img src="Segment-storage.png" alt="段式存储的逻辑地址"></p>
<p><strong>分段和分页的比较</strong></p>
<ul>
<li>段是信息的逻辑单位，由源程序的逻辑结构所决定，用户可见，段长可根据用户需要来规定，段起始地址可以从任何地址开始。在分段方式中，源程序(段号，段内偏移)经连结装配后仍保持二维结构。</li>
<li>页是信息的物理单位，与源程序的逻辑结构无关，用户不可见，页长由系统确定，页面只能以页大小的整倍数地址开始。在分页方式中，源程序(页号，页内偏移)经连结装配后变成了一维结构。</li>
<li>在分段式存储管理的基础上实现分页式存储管理，这就是<strong>段页式存储管理</strong>，是目前应用最多的一种存储管理方式。</li>
</ul>
<p><img src="Segment-page-storage.png" alt="段页式存储的逻辑地址"></p>
<p>逻辑地址分 3 个部分：段号、段内页号和页内位移，其形式为：对于用户来说，虚拟地址应该由段号 s 和段内位移 d’ 组成，用户看不到如何分页。而是由操作系统自动把 d’解释成两部分：段内页号 p 和页内位移 d，也就是说，d’ = p × 块长+ d。 </p>
<h2 id="虚拟存储技术"><a href="#虚拟存储技术" class="headerlink" title="虚拟存储技术"></a>虚拟存储技术</h2><p>将作业不执行的部分暂时存放在外存，待到进程需要时，再将其从外存调入内存。将外存作为内存的补充，从逻辑上扩充内存。</p>
<p>虚拟存储技术的<strong>实现基础</strong>是内存的分页或分段管理，采用的是进程的分页或分段在内存与外存之间对换。</p>
<h2 id="请求分页虚拟存储管理"><a href="#请求分页虚拟存储管理" class="headerlink" title="请求分页虚拟存储管理"></a>请求分页虚拟存储管理</h2><h3 id="硬件支持"><a href="#硬件支持" class="headerlink" title="硬件支持"></a>硬件支持</h3><ol>
<li>请求分页的页表机制</li>
<li>缺页中断机构</li>
<li>地址转换机构 </li>
</ol>
<h3 id="页面分配策略与页面调度算法"><a href="#页面分配策略与页面调度算法" class="headerlink" title="页面分配策略与页面调度算法"></a>页面分配策略与页面调度算法</h3><p><strong>1.页面分配策略</strong></p>
<p>通常分为固定分配和可变分配两种不同的方式</p>
<ol>
<li>固定分配方式：<ul>
<li>进程平均分配法</li>
<li>进程按比例分配法</li>
<li>进程优先权分配法</li>
</ul>
</li>
<li>可变分配方式</li>
</ol>
<p><strong>2.页面调入策略</strong></p>
<ol>
<li>请求页（demand paging）调入</li>
<li>预先页（prepaging）调入 </li>
</ol>
<p><strong>3.页面置换策略</strong></p>
<ol>
<li>全局置换</li>
<li>局部置换</li>
</ol>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p>先进先出、最佳页面、最近最久未使用、时钟置换算法</p>
<ol>
<li><p>先进先出（FIFO）页面置换算法</p>
<p>总是选择最先进入内存的页面或驻留时间最长的页面先淘汰<img src="FIFO.png" alt="FIFO 页面置换算法"></p>
</li>
<li><p>最佳（OPT）页面置换算法</p>
<p>在选择页面置换时应该考虑该页面将来使用的情况，将来最长时间不用的页面被淘汰。在进程采用固定页面分配的情况下，最佳页面置换算法具有最低的缺页率<img src="OPT.png" alt="OPT 页面置换算法"></p>
</li>
<li><p>LRU 页面置换算法</p>
<p>系统须维护一个页面淘汰队列，该队列中存放当前在内存中的页号，每当访问一页时就调整一次，使队尾总指向最近访问的页，而队列头部就是最近最少用的页，发生缺页中断时总淘汰队列头所指示的页；而执行一次页面访问后，需要从队列中把该页调整到队列尾<img src="LRU.png" alt="LRU 页面置换算法"></p>
</li>
<li><p>时钟（clock）置换算法</p>
</li>
</ol>
<h1 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h1><h2 id="设备管理概述"><a href="#设备管理概述" class="headerlink" title="设备管理概述"></a>设备管理概述</h2><p>设备管理目标：</p>
<ul>
<li>提高使用效率</li>
<li>提供便捷的界面</li>
</ul>
<p>设备管理功能：</p>
<ul>
<li>设备的分配与回收</li>
<li>缓冲区管理</li>
<li>设备控制和中断处理</li>
<li>实现虚拟设备</li>
</ul>
<h2 id="设备控制方法"><a href="#设备控制方法" class="headerlink" title="设备控制方法"></a>设备控制方法</h2><ol>
<li><p>程序循环查询方式</p>
</li>
<li><p>中断驱动方式</p>
</li>
<li><p>直接内存访问方式（DMA）</p>
<ul>
<li>数据传输的基本单位是数据块</li>
<li>所传送的数据是从设备直接送入内存，或者直接读出内存的</li>
<li>在传输时CPU参与更少，仅在传送一个或多个数据块的开始和结束时，才需CPU干预，整块数据的传送是在控制器的控制下完成的</li>
</ul>
</li>
<li><p>通道方式</p>
<p>I/O 通道方式是 DMA 方式的发展，它可进一步减少 CPU 的干预，即把对一个数据块的读(或写)为单位的干预，减少为对一组数据块的读(或写)及有关的控制和管理为单位的干预</p>
</li>
</ol>
<h2 id="缓冲技术"><a href="#缓冲技术" class="headerlink" title="缓冲技术"></a>缓冲技术</h2><p>缓冲技术主要有以下作用：</p>
<ul>
<li>改善中央处理器与外围设备之间速度不匹配的矛盾，提高 CPU 和 I/O 设备的并行性</li>
<li>减少 I/O 对 CPU 的中断次数和放宽对 CPU 中断响应时间的要求</li>
<li>协调逻辑记录大小与物理记录大小不一致的问题</li>
</ul>
<h2 id="输入输出软件"><a href="#输入输出软件" class="headerlink" title="输入输出软件"></a>输入输出软件</h2><p><strong>设备独立性</strong>，也称为设备无关性，是指在用户程序中不直接使用物理设备名（或设备的物理地址），而只能使用逻辑设备名。</p>
<ul>
<li>使得设备分配更加灵活，提高了设备的利用率</li>
<li>可以实现 I/O 重定向</li>
</ul>
<h2 id="设备分配与回收"><a href="#设备分配与回收" class="headerlink" title="设备分配与回收"></a>设备分配与回收</h2><h3 id="设备信息描述"><a href="#设备信息描述" class="headerlink" title="设备信息描述"></a>设备信息描述</h3><ol>
<li>系统设备表 SDT</li>
<li>设备控制表 DCT</li>
<li>控制器控制表 COCT</li>
<li>通道控制表 CHCT</li>
</ol>
<h3 id="设备分配策略"><a href="#设备分配策略" class="headerlink" title="设备分配策略"></a>设备分配策略</h3><ol>
<li>独占方式</li>
<li>共享方式</li>
<li>虚拟方式</li>
</ol>
<h3 id="SPOOLing-技术-假脱机"><a href="#SPOOLing-技术-假脱机" class="headerlink" title="SPOOLing 技术(假脱机)"></a>SPOOLing 技术(假脱机)</h3><p>当系统中引入了多道程序技术后，可以利用其中的一道程序，来模拟脱机输入输出时的外围控制机功能，把低速 I/O 设备上的数据传送到高速磁盘上；或者把数据从磁盘传送到低速输出设备上。这样，便可在主机的直接控制下，实现脱机输入输出功能。</p>
<ul>
<li>提高了 I/O 的速度，缓和了高速的处理器与低速输入输出设备之间的矛盾</li>
<li>将独占设备改造为共享设备，提高了设备的利用率</li>
<li>实现了虚拟设备功能，将物理的单个设备变换为多个对应的逻辑设备</li>
</ul>
<h3 id="设备分配算法"><a href="#设备分配算法" class="headerlink" title="设备分配算法"></a>设备分配算法</h3><ul>
<li>先来先服务算法</li>
<li>优先级高者优先算法</li>
</ul>
<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>文件分类方法有很多，下面是常用的几种文件分类方法： </p>
<ul>
<li>按照文件的逻辑结构的不同，可以把文件分成流式文件和纪录式文件</li>
<li>按照用途将文件分为系统文件、库文件和用户文件</li>
<li>按照性质可以把文件分为普通文件、目录文件和特殊文件按照性质可以把文件分为普通文件、目录文件和特殊文件</li>
</ul>
<h2 id="文件的组织"><a href="#文件的组织" class="headerlink" title="文件的组织"></a>文件的组织</h2><h3 id="逻辑结构组织"><a href="#逻辑结构组织" class="headerlink" title="逻辑结构组织"></a>逻辑结构组织</h3><p><strong>1.流式文件</strong></p>
<p>流式文件指文件内的数据不组成记录，只是依次的一串信息集合，如字节流或字符流。流式文件本身可以没有结构。</p>
<p><strong>2.纪录式文件</strong></p>
<p>记录式文件是一种有结构的文件，它是指文件中的数据由若干条定长或不定长的记录构成，每条记录又由若干数据项构成。记录是记录式文件进行存取的基本单位。</p>
<p>按照组织方式的不同，记录式文件可进一步分为：</p>
<ul>
<li>顺序文件</li>
<li>索引文件</li>
<li>索引顺序文件</li>
</ul>
<h3 id="物理结构组织"><a href="#物理结构组织" class="headerlink" title="物理结构组织"></a>物理结构组织</h3><ol>
<li><p>连续文件</p>
</li>
<li><p>链接文件</p>
</li>
<li><p>索引文件<img src="Tertiary-index-eg.png" alt="3 级索引"></p>
</li>
<li><p>直接文件</p>
</li>
</ol>
<h3 id="文件的存取方法"><a href="#文件的存取方法" class="headerlink" title="文件的存取方法"></a>文件的存取方法</h3><ol>
<li>顺序存取</li>
<li>直接存取</li>
<li>按键存取</li>
</ol>
<h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><h3 id="文件目录的基本概念"><a href="#文件目录的基本概念" class="headerlink" title="文件目录的基本概念"></a>文件目录的基本概念</h3><p>文件控制块——用于描述和控制文件的数据结构，称之为文件控制块（File Control Block，FCB）</p>
<ul>
<li>为了加快文件的查找速度，通常把 FCB 集中起来进行管理，文件控制块的有序集合称为<strong>文件目录</strong></li>
<li>文件目录也是以文件的形式保存在外存上的，这就形成了<strong>目录文件</strong></li>
</ul>
<h3 id="目录文件的组织"><a href="#目录文件的组织" class="headerlink" title="目录文件的组织"></a>目录文件的组织</h3><p>常用的组织方法主要有三种：</p>
<ul>
<li>FCB 线性表</li>
<li>索引节点</li>
<li>哈希表组织</li>
</ul>
<h3 id="目录的结构"><a href="#目录的结构" class="headerlink" title="目录的结构"></a>目录的结构</h3><p>目录结构都是采用层次结构，主要分为：</p>
<ul>
<li>单级目录</li>
<li>二级目录</li>
<li>多级层次目录结构（最常用）</li>
<li>图状目录结构</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">gzwang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://gzwangu.github.io/2020/06/05/操作系统/">https://gzwangu.github.io/2020/06/05/操作系统/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://gzwangu.github.io">Rubina の blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><i class="fa fa-chevron-left">  </i><span>计算机网络</span></a></div><div class="next-post pull-right"><a href="/2020/05/05/HDL%E5%A4%8D%E4%B9%A0/"><span>HDL复习</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2022 By gzwang</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>