<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="操作系统"><meta name="keywords" content="操作系统"><meta name="author" content="gzwang"><meta name="copyright" content="gzwang"><title>操作系统 | Rubina の blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E8%AE%BA"><span class="toc-number">1.</span> <span class="toc-text">概论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.</span> <span class="toc-text">操作系统的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">1.2.</span> <span class="toc-text">操作系统的功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">1.3.</span> <span class="toc-text">操作系统的特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.4.</span> <span class="toc-text">操作系统的分类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">进程管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.1.</span> <span class="toc-text">进程与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.1.1.</span> <span class="toc-text">进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.1.2.</span> <span class="toc-text">线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">2.1.3.</span> <span class="toc-text">区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C"><span class="toc-number">2.2.</span> <span class="toc-text">程序的执行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E5%BE%81%E4%B8%8E%E6%8E%A7%E5%88%B6"><span class="toc-number">2.3.</span> <span class="toc-text">进程的特征与控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%8A%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.3.1.</span> <span class="toc-text">进程状态及转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97-PCB"><span class="toc-number">2.3.2.</span> <span class="toc-text">进程控制块 PCB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">2.3.3.</span> <span class="toc-text">进程控制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5"><span class="toc-number">2.4.</span> <span class="toc-text">进程的互斥与同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90%E4%B8%8E%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="toc-number">2.4.1.</span> <span class="toc-text">临界资源与临界区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">2.4.2.</span> <span class="toc-text">进程同步机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98"><span class="toc-number">2.4.3.</span> <span class="toc-text">进程同步经典问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-number">2.5.</span> <span class="toc-text">进程通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93"><span class="toc-number">2.5.1.</span> <span class="toc-text">管道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93%EF%BC%88FIFO%EF%BC%89"><span class="toc-number">2.5.2.</span> <span class="toc-text">有名管道（FIFO）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">2.5.3.</span> <span class="toc-text">消息队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7"><span class="toc-number">2.5.4.</span> <span class="toc-text">信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">2.5.5.</span> <span class="toc-text">信号量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="toc-number">2.5.6.</span> <span class="toc-text">共享内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-number">2.5.7.</span> <span class="toc-text">套接字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">2.6.</span> <span class="toc-text">进程调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.6.1.</span> <span class="toc-text">进程调度模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E9%80%89%E6%8B%A9-%E8%AF%84%E4%BB%B7%E5%87%86%E5%88%99"><span class="toc-number">2.6.2.</span> <span class="toc-text">调度算法选择&#x2F;评价准则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">2.6.3.</span> <span class="toc-text">调度算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">2.7.</span> <span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">2.7.1.</span> <span class="toc-text">必要条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95"><span class="toc-number">2.7.2.</span> <span class="toc-text">处理方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0"><span class="toc-number">3.1.</span> <span class="toc-text">内存管理概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.1.</span> <span class="toc-text">计算机存储系统的结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.1.2.</span> <span class="toc-text">地址的表示与地址转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">3.1.3.</span> <span class="toc-text">内存管理的功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF"><span class="toc-number">3.1.4.</span> <span class="toc-text">覆盖与交换技术</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">3.2.</span> <span class="toc-text">分区内存管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">3.3.</span> <span class="toc-text">页式存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E8%A1%A8"><span class="toc-number">3.3.1.</span> <span class="toc-text">快表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="toc-number">3.3.2.</span> <span class="toc-text">多级页表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AE%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">3.4.</span> <span class="toc-text">段式存储管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF"><span class="toc-number">3.5.</span> <span class="toc-text">虚拟存储技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">3.6.</span> <span class="toc-text">请求分页虚拟存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E6%94%AF%E6%8C%81"><span class="toc-number">3.6.1.</span> <span class="toc-text">硬件支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%E4%B8%8E%E9%A1%B5%E9%9D%A2%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">3.6.2.</span> <span class="toc-text">页面分配策略与页面调度算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">3.6.3.</span> <span class="toc-text">页面置换算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">设备管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0"><span class="toc-number">4.1.</span> <span class="toc-text">设备管理概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.</span> <span class="toc-text">设备控制方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%8A%80%E6%9C%AF"><span class="toc-number">4.3.</span> <span class="toc-text">缓冲技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%BD%AF%E4%BB%B6"><span class="toc-number">4.4.</span> <span class="toc-text">输入输出软件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6"><span class="toc-number">4.5.</span> <span class="toc-text">设备分配与回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E4%BF%A1%E6%81%AF%E6%8F%8F%E8%BF%B0"><span class="toc-number">4.5.1.</span> <span class="toc-text">设备信息描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-number">4.5.2.</span> <span class="toc-text">设备分配策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SPOOLing-%E6%8A%80%E6%9C%AF-%E5%81%87%E8%84%B1%E6%9C%BA"><span class="toc-number">4.5.3.</span> <span class="toc-text">SPOOLing 技术(假脱机)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">4.5.4.</span> <span class="toc-text">设备分配算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.</span> <span class="toc-text">文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">5.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%84%E7%BB%87"><span class="toc-number">5.2.</span> <span class="toc-text">文件的组织</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E7%BB%84%E7%BB%87"><span class="toc-number">5.2.1.</span> <span class="toc-text">逻辑结构组织</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84%E7%BB%84%E7%BB%87"><span class="toc-number">5.2.2.</span> <span class="toc-text">物理结构组织</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%AD%98%E5%8F%96%E6%96%B9%E6%B3%95"><span class="toc-number">5.2.3.</span> <span class="toc-text">文件的存取方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95"><span class="toc-number">5.3.</span> <span class="toc-text">文件目录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">5.3.1.</span> <span class="toc-text">文件目录的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%84%E7%BB%87"><span class="toc-number">5.3.2.</span> <span class="toc-text">目录文件的组织</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">5.3.3.</span> <span class="toc-text">目录的结构</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://gzwangu.github.io/img/avatar.jpg"></div><div class="author-info__name text-center">gzwang</div><div class="author-info__description text-center">Study and Life growth record</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">35</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">38</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">10</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://crownz.run/">crownZ</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://blog.zyuanlee.cn/">Pandalzy</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://blog.zguolee.cn/">Lee</a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Rubina の blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">操作系统</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-05</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/">课程学习</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">9.9k</span><span class="post-meta__separator">|</span><span>阅读时长: 29 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h1><h2 id="操作系统的定义"><a href="#操作系统的定义" class="headerlink" title="操作系统的定义"></a>操作系统的定义</h2><p>操作系统（OS ）是管理计算机硬件与软件资源的计算机程序。</p>
<h2 id="操作系统的功能"><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a>操作系统的功能</h2><ol>
<li>进程管理——进程线程的状态、控制、同步互斥、通信调度等</li>
<li>内存管理——分配/回收、地址转换、存储保护等</li>
<li>设备管理——设备驱动、分配回收、缓冲技术等</li>
<li>文件管理——文件目录、文件操作、磁盘空间、文件存取控制</li>
</ol>
<h2 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h2><ol>
<li><strong>并发性</strong><br>并发性是两个或多个事件在同一时间间隔内发生的、同时处于活动状态的特性。</li>
<li><strong>共享性</strong><br>指系统中的资源可以被多个并发进程共同使用，内存中并发执行的多个程序可以共享计算机的硬件和软件资源。有两种共享方式：互斥共享和同时共享。</li>
<li><strong>虚拟性</strong><br>虚拟性是指将一个物理实体映射为一个或多个逻辑对象。主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。</li>
<li><strong>异步性</strong><br>随机性也叫异步性，指的是每道程序在何时执行、各个程序执行的顺序以及每道程序所需的时间都是不确定的，也是不可预知的。</li>
</ol>
<h2 id="操作系统的分类"><a href="#操作系统的分类" class="headerlink" title="操作系统的分类"></a>操作系统的分类</h2><ol>
<li>批处理操作系统</li>
<li>分时操作系统</li>
<li>实时操作系统</li>
<li>嵌入式操作系统</li>
<li>个人操作系统</li>
<li>网络操作系统</li>
<li>分布式操作系统</li>
</ol>
<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程是正在运行的程序及其占用的系统资源，是系统进行资源分配、保护和调度的基本单位。</p>
<p>进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程是独立调度的基本单位。</p>
<p>一个进程中可以有多个线程，它们共享进程资源。</p>
<p>QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol>
<li>拥有资源。进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。</li>
<li>调度。线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</li>
<li>系统开销。由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</li>
<li>通信方面。线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。</li>
</ol>
<h2 id="程序的执行"><a href="#程序的执行" class="headerlink" title="程序的执行"></a>程序的执行</h2><p><strong>程序的顺序执行</strong></p>
<p>一个具有独立功能的程序独占处理器直至最终结束的过程称为程序的顺序执行。</p>
<p>顺序执行有如下三个特点：顺序性、封闭性、可在现性</p>
<p>并发执行的特性有以下三点：间断性、开放/交互性、不可再现性</p>
<p><strong>程序的并发执行与并行执行：</strong></p>
<ul>
<li><p>并行是指多个事件在同一时刻发生，而并发是指多个事件在同一时期内发生。</p>
</li>
<li><p>并行是并发的特例，程序并行执行的硬件前提是系统中有多个 CPU。</p>
</li>
<li><p>并发的本质是一个 CPU 在多个程序运行过程中的时分复用。</p>
</li>
</ul>
<h2 id="进程的特征与控制"><a href="#进程的特征与控制" class="headerlink" title="进程的特征与控制"></a>进程的特征与控制</h2><p>进程有以下特性：结构性、动态性、独立性、并发性</p>
<p>进程通常分为两类：系统进程和用户进程</p>
<p><strong><code>进程上下文</code>：</strong>进程的生命周期中，进程实体和支持进程运行的环境</p>
<h3 id="进程状态及转换"><a href="#进程状态及转换" class="headerlink" title="进程状态及转换"></a>进程状态及转换</h3><p><img src="Process-tristate.png" alt="进程三态模型"></p>
<p><strong>就绪状态</strong>——进程在内存中已经具备执行的条件，等待分配 CPU。<em>就绪队列</em></p>
<p><strong>运行状态</strong>——进程占用 CPU 并正在执行。</p>
<p><strong>阻塞状态</strong>——等待资源，也称为等待状态。<em>阻塞队列</em></p>
<p>应该注意以下内容：</p>
<p>（1）只有就绪态和运行态可以相互转换，其它的都是单向转换。</p>
<p>（2）就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</p>
<p>（3）阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。</p>
<p><img src="Process-five-states.png" alt="进程五态模型"></p>
<p><strong>新建状态</strong>——进程被创建时所处的状态。</p>
<p><strong>终止状态</strong>——进程正常结束或出现严重错误时，会被操作系统终止或被其它有终止权的进程终止。</p>
<p><img src="Process-seven-states.png" alt="进程七态模型"></p>
<p><strong>挂起就绪</strong>——进程具备运行条件，但目前不在内存中，需要被系统调入内存才能运行。</p>
<p><strong>挂起阻塞</strong>——进程在等待某一事件或条件并且该进程目前不在内存中。</p>
<h3 id="进程控制块-PCB"><a href="#进程控制块-PCB" class="headerlink" title="进程控制块 PCB"></a>进程控制块 PCB</h3><p>描述和控制进程运行的数据结构，PCB 是进程存在的<code>唯一标志</code>。</p>
<ol>
<li>进程标识信息——内部标识符和外部标识符 </li>
<li>现场信息——进程运行时 CPU 的即时状态即各寄存器的值</li>
<li>控制信息——操作系统控制进程需要的信息</li>
</ol>
<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p>核心态（内核态）和用户态，也称为管态和目态</p>
<p><strong>进程控制</strong>——系统对进程生命周期的各个环节进行控制</p>
<p>进程控制通常由原语完成。<strong>原语</strong>是由若干条指令所组成，用来实现某个特定功能，在执行过程中不可被中断的程序段。</p>
<p>原语是不可分割的执行单位，原语的执行不可能是并发的。</p>
<ol>
<li>创建进程</li>
<li>撤消与终止进程</li>
<li>阻塞与唤醒进程</li>
<li>挂起与激活进程</li>
</ol>
<h2 id="进程的互斥与同步"><a href="#进程的互斥与同步" class="headerlink" title="进程的互斥与同步"></a>进程的互斥与同步</h2><p>并发运行的多个进程之间存在两种基本关系——竞争（互斥）和协作（同步）</p>
<ul>
<li>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</li>
<li>互斥：多个进程在同一时刻只有一个进程能进入临界区。</li>
</ul>
<p>竞争，会引起一下两种极端情况：</p>
<ul>
<li>死锁：一组进程均只占有部分所需资源而无法继续运行，陷入阻塞</li>
<li>饥饿：进程被调度程序长期忽视而分配不到 CPU 执行</li>
</ul>
<h3 id="临界资源与临界区"><a href="#临界资源与临界区" class="headerlink" title="临界资源与临界区"></a>临界资源与临界区</h3><p><strong>临界资源</strong>：在某段时间内只能允许一个进程使用的资源<br><strong>临界区</strong>：访问临界资源的代码段</p>
<p>临界区调度原则：</p>
<ol>
<li>一次至多一个进程能够进入临界区内执行；</li>
<li>如果已有进程在临界区，其它试图进入的进程应等待；</li>
<li>进入临界区内的进程应在有限时间内退出，以便让等待进程中的一个进入；</li>
</ol>
<h3 id="进程同步机制"><a href="#进程同步机制" class="headerlink" title="进程同步机制"></a>进程同步机制</h3><ol>
<li><p>信号量机制</p>
<p><strong>P(s)：</strong>将信号量 s 的值减 1，若结果小于 0，则调用 P(s) 的进程被阻塞，并进入信号量 s 的阻塞队列中；若结果不小于 0，则调用 P(s) 的进程继续运行。</p>
<p><strong>V(s)：</strong>将信号量 s 的值加 1，若结果不大于 0，则调用 V(s) 的进程从该信号量阻塞队列中释放、唤醒一个处于等待状态的进程，将其转换为就绪状态，调用 V(s) 的进程继续运行；若结果大于0，则调用V(s)的进程继续运行。</p>
<ul>
<li>P 操作意味进程申请一个资源，求而不得则阻塞进程，V 操作意味着释放一个资源，若此时还有进程在等待获取该资源，则被唤醒。</li>
<li>若信号量的值为正数，该正数表示可对信号量可进行的 P 操作的次数，即可用的资源数。信号量的初值一般设为系统中相关资源的总数，对于互斥信号量，初值一般设为 1。</li>
<li>若信号量的值为负，其绝对值表示有多个进程申请该资源而又不能得到，在阻塞队列等待，即在信号量阻塞队列中等待该资源的进程个数。</li>
</ul>
</li>
<li><p>管程同步机制</p>
<p>把临界区集中并封装成抽象数据类型，其中包括与临界资源相关、仅限管程内部访问的公共变量，供管程外的进程调用以访问这些公共变量的接口过程，并提供互斥机制确保进程互斥地使用管程 。</p>
<p><strong>管程具有以下特点：</strong>模块化、隐蔽性、互斥性</p>
<p>管程有一个重要特性：<strong>在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。</strong></p>
<p>管程引入了<strong>条件变量</strong>同步机制：</p>
<ul>
<li>让进入管程却因资源不足而阻塞的进程暂时放弃管程控制权（开放管程），进入该条件变量的等待队列 </li>
<li>条件变量只能在管程中通过两个原语操作——wait 原语和 signal 原语 </li>
<li>一个进程已进入管程但无法继续执行，便在相应的条件变量 x 上调用 x.wait( )，将自己阻塞并移入 x 的等待队列中，放弃管程控制权（开放管程），另一进程可以通过对同一个条件变量执行 x.signal( ) 来唤醒之前在 x 上等待的进程  </li>
</ul>
</li>
</ol>
<p><strong>管程与进程的区别：</strong></p>
<ul>
<li>管程把共享变量上的同步操作集中起来，而临界区却分散在每个进程中；</li>
<li>管程是为管理共享资源而建立的，进程主要是为实现系统并发性而引入的；</li>
<li>管程被进程调用，管程和调用它的进程不能并行工作，而进程之间能并行工作，并发性是其固有特性；</li>
<li>管程是语言或操作系统的组成部分，随操作系统启动而装入内存，不必创建或撤销，而进程有生命周期；</li>
</ul>
<h3 id="进程同步经典问题"><a href="#进程同步经典问题" class="headerlink" title="进程同步经典问题"></a>进程同步经典问题</h3><ol>
<li><p><strong>生产者-消费者问题</strong></p>
<p>在并发环境下生产者、消费者进程访问缓冲区的速度不协调、不匹配——不同步，或者没有做到互不影响地使用、更新缓冲区——互斥，所以会出现运行错误甚至是死锁。<img src="Producer-consumer.png" alt="生产者-消费者问题"></p>
<p>方案：因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。</p>
<p>为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。</p>
</li>
<li><p><strong>读者-写者问题</strong></p>
<ul>
<li>允许多个读者进程同时读文件</li>
<li>只允许一个写者进程写文件</li>
<li>任何一个写者进程在完成写操作之前不允许其它读者或写者工作</li>
<li>写者执行写操作前，应让已有的写者和读者全部退出</li>
</ul>
<p>方案：一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore count_mutex = <span class="number">1</span>;</span><br><span class="line">semaphore data_mutex = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        <span class="built_in">p</span>(&amp;count_mutex);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">1</span>) <span class="built_in">p</span>(&amp;data_mutex); <span class="comment">// 第一个读者需要对数据进行加锁，防止写进程访问</span></span><br><span class="line">        <span class="built_in">v</span>(&amp;count_mutex);</span><br><span class="line">        <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">p</span>(&amp;count_mutex);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>) <span class="built_in">v</span>(&amp;data_mutex);</span><br><span class="line">        <span class="built_in">v</span>(&amp;count_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        <span class="built_in">p</span>(&amp;data_mutex);</span><br><span class="line">        <span class="built_in">write</span>();</span><br><span class="line">        <span class="built_in">v</span>(&amp;data_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>哲学家就餐问题</strong></p>
<p>五个哲学家围坐在一圆桌旁，桌中央有一盘通心面，每人面前有一只空盘子，每两人之间放一只筷子。每个哲学家的行为是思考，感到饥饿，然后吃通心面。为了吃面，每个哲学家必须拿到两只筷子，并且每个人只能直接从自己的左手边和右手边去取筷子。<img src="Philosopher-dining.png" alt="哲学家就餐问题"></p>
<p>为了防止死锁的发生，可以设置两个条件：</p>
<ul>
<li>必须同时拿起左右两根筷子；</li>
<li>只有在两个邻居都没有进餐的情况下才允许进餐。</li>
</ul>
</li>
<li><p><strong>睡眠理发师</strong></p>
<p>理发店里有一个理发师，一把理发椅，N 个供等候顾客休息的椅子。若无顾客，理发师躺在理发椅上睡觉。顾客到来时唤醒理发师，若理发师正在理发，新来的顾客坐在空闲的休息椅上等候，如果没有空椅子，顾客离开。</p>
</li>
</ol>
<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>进程同步与进程通信很容易混淆，它们的区别在于：</p>
<ul>
<li>进程同步：控制多个进程按一定顺序执行；</li>
<li>进程通信：进程间传输信息。</li>
</ul>
<p>进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。进程间通信的7种方式：<strong>管道（匿名管道）、有名管道、消息队列、信号、信号量、共享内存和套接字</strong>。</p>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>管道/匿名管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。</p>
<p>它具有以下限制：</p>
<ul>
<li>只支持半双工通信（单向交替传输）</li>
<li>只能在父子进程或者兄弟进程中使用。</li>
<li>管道的缓冲区是有限的</li>
</ul>
<p><img src="pipe.png"></p>
<p>管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据。</p>
<p>该缓冲区可以看做是一个循环队列，读和写的位置都是自动增长的，不能随意改变，一个数据只能被读一次，读出来以后在缓冲区就不复存在了。</p>
<p>当缓冲区读空或者写满时，有一定的规则控制相应的读进程或者写进程进入等待队列，当空的缓冲区有新数据写入或者满的缓冲区有数据读出来时，就唤醒等待队列中的进程继续读写。</p>
<h3 id="有名管道（FIFO）"><a href="#有名管道（FIFO）" class="headerlink" title="有名管道（FIFO）"></a>有名管道（FIFO）</h3><p>FIFO克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。有名管道的名字存在于文件系统中，内容存放在内存中。</p>
<p>FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。</p>
<p><img src="YFIFO.png"></p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。消息队列允许一个或多个进程向它写入与读取消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p>
<p>相比于 FIFO，消息队列具有以下优点：</p>
<ul>
<li>消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；</li>
<li>避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；</li>
<li>读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。</li>
</ul>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。如果该进程当前并未处于执行状态，则该信号就有内核保存起来，直到该进程回复执行并传递给它为止。如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。</p>
<p><img src="signal.png"></p>
<p>Linux系统中常用信号：</p>
<ul>
<li>SIGINT：程序终止信号。程序运行过程中，按Ctrl+C键将产生该信号。</li>
<li>SIGQUIT：程序退出信号。程序运行过程中，按Ctrl+\\键将产生该信号。</li>
<li>SIGKILL：用户终止进程执行信号。shell下执行kill -9发送该信号。</li>
</ul>
<p>信号是软件层次上对中断机制的一种模拟，是一种异步通信方式，信号可以在用户空间进程和内核之间直接交互，内核可以利用信号来通知用户空间的进程发生了哪些系统事件。</p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。</p>
<p><strong>信号量与普通整型变量的区别：</strong></p>
<ul>
<li>信号量是非负整型变量，除了初始化之外，它只能通过两个标准原子操作：wait(semap) , signal(semap) 来进行访问；</li>
<li>操作也被成为PV原语，普通整型变量则可以在任何语句块中被访问；</li>
</ul>
<p><strong>信号量与互斥量之间的区别：</strong></p>
<ul>
<li>互斥量用于线程的互斥，信号量用于线程的同步（根本区别）</li>
<li>互斥量值只能为0/1，信号量值可以为非负整数。</li>
<li>互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。</li>
</ul>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。</p>
<p>为在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。</p>
<p>由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。</p>
<p><img src="share-memory.png"></p>
<h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><p>套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。</p>
<p><img src="socket.png"></p>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><p>两种基本的进程调度方式，抢占方式和非抢占方式，也称剥夺式（preemptive）和非剥夺式（non_preemptive）调度</p>
<h3 id="进程调度模型"><a href="#进程调度模型" class="headerlink" title="进程调度模型"></a>进程调度模型</h3><ul>
<li>高级调度（High-Level Scheduling)，又称为作业调度，它决定把后备作业调入内存运行； </li>
<li>中级调度（Intermediate-Level Scheduling)，又称为平衡调度，在虚拟存储器中引入，在内、外存对换区进行进程对换；</li>
<li>低级调度 (Low-Level Scheduling)：又称为进程调度，它决定就绪队列的某进程获得CPU； <img src="Three-level-scheduling.png" alt="三级调度模型"></li>
</ul>
<h3 id="调度算法选择-评价准则"><a href="#调度算法选择-评价准则" class="headerlink" title="调度算法选择/评价准则"></a>调度算法选择/评价准则</h3><ul>
<li>处理器利用率（CPU utilization）= CPU有效工作时间 / CPU总的运行时间 </li>
<li>响应时间（response time）：交互环境下用户从键盘提交请求开始，到系统首次产生响应为止的时间</li>
<li>周转时间（turnaround time）Ti =  Tf – Ts，即：周转时间 = 完成时刻 - 提交时刻 </li>
<li>带权周转时间—— Wi = 作业的周转时间 Ti / 系统为作业提供的服务时间 Tsi，显然带权周转时间总大于 1 </li>
<li>平均作业周转时间 T = (ΣTi) / n</li>
<li>平均作业带权周转时间W = (ΣWi) / n</li>
</ul>
<h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><ul>
<li><p>非抢占方式：先来先服务、短作业优先、高响应比优先</p>
</li>
<li><p>抢占方式：最短剩余时间优先、优先权、时间片轮转、多级反馈队列</p>
</li>
</ul>
<ol>
<li><strong>先来先服务</strong>(First-Come First-Served，FCFS)——按进程就绪的先后顺序来调度，到达得越早，就越先执行。特点如下：获得CPU的进程，未遇到其它情况时，一直运行下去；是一种非抢占式算法；没有考虑执行时间长短、运行特性和资源的要求。</li>
<li><strong>短作业优先</strong>(Shortest-Job-First，SJF)——以进入系统的作业所要求的CPU服务时间为标准，总选取估计所需CPU时间最短的作业优先投入运行。</li>
<li><strong>最短剩余时间优先</strong>(Shortest Remaining Time First，SRTF)——若一就绪状态的新作业所需的CPU时间比当前正在执行的作业剩余任务所需CPU时间还短，SRTF将打断正在执行作业，将执行权分配给新作业。</li>
<li><strong>高响应比优先</strong>(Highest Response Ratio First，HRRF)——是 FCFS 与 SJF 两种算法的折衷——既考虑作业等待时间，又考虑作业的运行时间，既照顾短作业又不使长作业等待过久，改善了调度性能，仍属于非抢占式算法。响应比为作业的响应时间与作业所需运行时间之比，简化为：响应比 ＝1 +（已等待的时间 / 估计运行时间）。</li>
<li><strong>优先权</strong>(Highest-Priority-First，HPF)——根据进程的优先权进行进程调度，每次总是选取优先权高的进程调度，也称优先级调度算法，一般是抢占式调度。</li>
<li><strong>时间片轮转</strong>(Round-Ribon，RR)——调度程序把CPU分配给进程使用一个规定的时段，称为一个时间片（如100ms），就绪队列中的进程轮流获得CPU的一个时间片。当一个时间片结束时，系统剥夺该进程执行权，等候下一轮调度，属于抢占式调度。</li>
<li><strong>多级反馈队列</strong>(MFQS)——将时间片轮转与优先级调度相结合，把进程按优先级分成不同的队列，先按优先级调度，优先级相同的，按时间片轮转。优点是兼顾长短作业，有较好的响应时间，可行性强，适用于各种作业环境。</li>
</ol>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p> 死锁产生的原因主要有两个：<strong>并发进程对临界资源的竞争；并发进程推进顺序不当</strong>。</p>
<h3 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h3><ol>
<li><strong>互斥条件</strong>：每个资源要么已经分配给了一个进程，要么就是可用的</li>
<li><strong>请求与保持条件</strong>：已经得到了某个资源的进程可以再请求新的资源</li>
<li><strong>不剥夺条件</strong>：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放</li>
<li><strong>环路等待条件</strong>：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源</li>
</ol>
<h3 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h3><p>主要有以下四种方法：鸵鸟策略、</p>
<p><strong>银行家算法</strong>的思路：</p>
<ol>
<li>在某一时刻，各进程已获得所需的部分资源。有一进程提出新的资源请求，系统将剩余资源试探性地分配给该进程。</li>
<li>如果此时剩余资源能够满足余下的某些进程的需求，则将剩余资源分配给能充分满足的、资源需求缺口最大的进程，运行结束后释放的资源再并入系统的剩余资源集合。</li>
<li>反复执行第 2 步，直到所有的进程都能够获得所需而运行结束。说明第1步的进程请求是可行的，系统处于安全状态，相应的进程执行序列称为系统的安全序列。如果所有的进程都试探过而不能将资源分配给进程，即不存在安全序列，则系统是不安全的。</li>
</ol>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p><strong>MMU</strong> 内存管理单元，也称作分页内存管理单元，把虚拟地址转换成物理地址。<strong>TLB</strong> 是一块高速缓存，缓存虚拟地址和其映射的物理地址，减少CPU访问物理内存的次数，用于改进虚拟地址到物理地址转换速度。</p>
<h2 id="内存管理概述"><a href="#内存管理概述" class="headerlink" title="内存管理概述"></a>内存管理概述</h2><p>计算机的存储系统主要包括内存储器和外存储器</p>
<ul>
<li>内存储器（Memory）即俗称的内存或主存</li>
<li>外存储器也叫辅助存储器</li>
</ul>
<h3 id="计算机存储系统的结构"><a href="#计算机存储系统的结构" class="headerlink" title="计算机存储系统的结构"></a>计算机存储系统的结构</h3><p><img src="Structure-of-storage-system.jpg" alt="计算机系统的结构与使用关系"></p>
<h3 id="地址的表示与地址转换"><a href="#地址的表示与地址转换" class="headerlink" title="地址的表示与地址转换"></a>地址的表示与地址转换</h3><p>只有把程序和数据的逻辑地址转换为物理地址，程序才能正确运行，该过程称为地址转换或地址重定位。地址转换有静态重定位和动态重定位两种方式。</p>
<ul>
<li>静态重定位：这种方式是在用户作业装入内存时由装入程序(装配程序)实现从逻辑地址到物理地址的转换，地址转换在作业执行前一次完成</li>
<li>动态重定位：程序执行过程中，CPU在访问程序和数据之前才实现地址转换。动态重定位必须借助于硬件地址转换机构来实现，硬件系统中设置了一个<strong>定位寄存器</strong>，当操作系统为某程序分配了一块内存区域后，装入程序把程序装入到所分配的区域中，然后把该内存区域的起始地址置入定位寄存器中。在程序执行过程中需要进行地址转换时，只需将逻辑地址与定位寄存器中的值相加就可得到物理地址。这种地址转换方式是在指令过程中进行的，所以称动态重定位。</li>
</ul>
<h3 id="内存管理的功能"><a href="#内存管理的功能" class="headerlink" title="内存管理的功能"></a>内存管理的功能</h3><ol>
<li>内存的分配和回收</li>
<li>提高内存的利用率</li>
<li>通过虚拟存储技术“扩充”内存容量</li>
<li>内存信息保护</li>
</ol>
<h3 id="覆盖与交换技术"><a href="#覆盖与交换技术" class="headerlink" title="覆盖与交换技术"></a>覆盖与交换技术</h3><ol>
<li><p>覆盖技术：按照程序自身的逻辑结构，让不同时执行的程序段先后共享同一块内存区域</p>
<p>例如：某程序由A、B、C、D、E、F等六个程序段组成，它们之间的调用关系如图3.3左图所示。其中，程序段A只调用B和C，程序段B只调用F，而程序段C只调用D和E。由于B和C之间没有相互调用，所以它们可以共享同一覆盖区。覆盖区的大小以能装入所有共享的程序段为准。本例中，与B、C对应的覆盖区的大小为50K。类似地，D、E、F也可以共享一大小为40K的覆盖区，如下图所示。<img src="Coverage-technology.png" alt="覆盖技术"></p>
</li>
<li><p>交换技术：由操作系统根据需要，将某些暂时不运行的进程或程序段从内存移到外存的交换区中；当内存空间富余时再给被移出的进程或程序段重新分配内存，让其进入内存</p>
</li>
</ol>
<h2 id="分区内存管理"><a href="#分区内存管理" class="headerlink" title="分区内存管理"></a>分区内存管理</h2><ol>
<li>单一连续内存管理</li>
<li>固定分区内存管理</li>
<li>可变分区内存管理<ul>
<li>最先适应分配算法</li>
<li>循环首次适应分配算法</li>
<li>最优适应分配算法</li>
<li>最差适应分配算法</li>
<li>快速适应算法</li>
</ul>
</li>
</ol>
<h2 id="页式存储管理"><a href="#页式存储管理" class="headerlink" title="页式存储管理"></a>页式存储管理</h2><p>页：将用户进程的逻辑地址空间划分为大小相等的区，每一个区称为一页或一个页面，并对各页从 0 开始编号，如第 0 页、第 1 页等。</p>
<p>物理块：将物理内存也划分成与页大小相等的区，每一个区称为一个物理块(block)，或称为块、页框，也同样对它们加以编号，如 0 号块、1 号块等。</p>
<p>内存分配的<strong>基本单位</strong>是页，进程的最后一页经常装不满一块，所以会在最后一块内形成不可利用的碎片，称之为“<strong>页内碎片</strong>”。</p>
<p>32 位操作系统其逻辑地址是 32 位，采用页式内存管理，如果每页大小 4096 B，那么页内偏移要占用其逻辑地址的低 12 位，从 0 位开始到 11 位结束。逻辑地址剩余的高 20 位用来表示页号，从 12 位开始到 31 位结束，这样最多允许有 220（1M）个页面。页面的编号从 0 开始，分别为 0，1，2，3 …，220−1，如图所示。</p>
<p><img src="Page-storage.jpg" alt="页式存储的逻辑地址"></p>
<h3 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h3><p>为了提高程序的运行速度，可以将最近访问过的页的页表项信息存放在高速缓存中，高速缓存也称为“联想存储器”，其中的页表称为“快表”。</p>
<h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p>为了能够快速查找页表页在内存中的物理块号，为这些页表页再设计一个地址索引表，即页目录表。二级页表的逻辑地址被划分为三部分： 页目录、页表页、页内偏移</p>
<p><img src="Secondary-page-table.jpg" alt="二级页表结构"></p>
<p><strong>缺页中断</strong>指的是在进程运行过程中，发现所访问的页不在内存中时，CPU的内存管理单元发出的中断。与一般中断：CPU 检测中断时间不同，CPU 可多次处理。</p>
<p><strong>缺页中断处理流程</strong>是：先查看内存是否有空闲块，若有则按该页在外存中的地址将该页找出并装入内存，在页表中填上它占用的块号且修改标志位。若内存已没有空闲块，则必须先淘汰已在内存中的某一页，再将所需的页装入，对页表和内存分配表作相应的修改。淘汰某页时，要查看该页的修改位来判断该页是否修改过，若该页在执行过程中没有被修改过，那么不必重新写回到存储器中，而已修改过的页调出时必须再将该页写回到外存中。</p>
<h2 id="段式存储管理"><a href="#段式存储管理" class="headerlink" title="段式存储管理"></a>段式存储管理</h2><p>分段式存储管理是以段为单位进行内存分配，逻辑地址空间是一个二维空间，分为段号和段内偏移两部分。</p>
<p><img src="Segment-storage.png" alt="段式存储的逻辑地址"></p>
<p><strong>分段和分页的比较</strong></p>
<ul>
<li>段是信息的逻辑单位，由源程序的逻辑结构所决定，用户可见，段长可根据用户需要来规定，段起始地址可以从任何地址开始。在分段方式中，源程序(段号，段内偏移)经连结装配后仍保持二维结构。</li>
<li>页是信息的物理单位，与源程序的逻辑结构无关，用户不可见，页长由系统确定，页面只能以页大小的整倍数地址开始。在分页方式中，源程序(页号，页内偏移)经连结装配后变成了一维结构。</li>
<li>在分段式存储管理的基础上实现分页式存储管理，这就是<strong>段页式存储管理</strong>，是目前应用最多的一种存储管理方式。</li>
</ul>
<p><img src="Segment-page-storage.png" alt="段页式存储的逻辑地址"></p>
<p>逻辑地址分 3 个部分：段号、段内页号和页内位移，其形式为：对于用户来说，虚拟地址应该由段号 s 和段内位移 d’ 组成，用户看不到如何分页。而是由操作系统自动把 d’解释成两部分：段内页号 p 和页内位移 d，也就是说，d’ = p × 块长+ d。 </p>
<h2 id="虚拟存储技术"><a href="#虚拟存储技术" class="headerlink" title="虚拟存储技术"></a>虚拟存储技术</h2><p>将作业不执行的部分暂时存放在外存，待到进程需要时，再将其从外存调入内存。将外存作为内存的补充，从逻辑上扩充内存。</p>
<p>虚拟存储技术的<strong>实现基础</strong>是内存的分页或分段管理，采用的是进程的分页或分段在内存与外存之间对换。</p>
<h2 id="请求分页虚拟存储管理"><a href="#请求分页虚拟存储管理" class="headerlink" title="请求分页虚拟存储管理"></a>请求分页虚拟存储管理</h2><h3 id="硬件支持"><a href="#硬件支持" class="headerlink" title="硬件支持"></a>硬件支持</h3><ol>
<li>请求分页的页表机制</li>
<li>缺页中断机构</li>
<li>地址转换机构 </li>
</ol>
<h3 id="页面分配策略与页面调度算法"><a href="#页面分配策略与页面调度算法" class="headerlink" title="页面分配策略与页面调度算法"></a>页面分配策略与页面调度算法</h3><p><strong>1.页面分配策略</strong></p>
<p>通常分为固定分配和可变分配两种不同的方式</p>
<ol>
<li>固定分配方式：<ul>
<li>进程平均分配法</li>
<li>进程按比例分配法</li>
<li>进程优先权分配法</li>
</ul>
</li>
<li>可变分配方式</li>
</ol>
<p><strong>2.页面调入策略</strong></p>
<ol>
<li>请求页（demand paging）调入</li>
<li>预先页（prepaging）调入 </li>
</ol>
<p><strong>3.页面置换策略</strong></p>
<ol>
<li>全局置换</li>
<li>局部置换</li>
</ol>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p>先进先出、最佳页面、最近最久未使用、时钟置换算法</p>
<ol>
<li><p>先进先出（FIFO）页面置换算法</p>
<p>总是选择最先进入内存的页面或驻留时间最长的页面先淘汰<img src="FIFO.png" alt="FIFO 页面置换算法"></p>
</li>
<li><p>最佳（OPT）页面置换算法</p>
<p>在选择页面置换时应该考虑该页面将来使用的情况，将来最长时间不用的页面被淘汰。在进程采用固定页面分配的情况下，最佳页面置换算法具有最低的缺页率<img src="OPT.png" alt="OPT 页面置换算法"></p>
</li>
<li><p>LRU 页面置换算法</p>
<p>系统须维护一个页面淘汰队列，该队列中存放当前在内存中的页号，每当访问一页时就调整一次，使队尾总指向最近访问的页，而队列头部就是最近最少用的页，发生缺页中断时总淘汰队列头所指示的页；而执行一次页面访问后，需要从队列中把该页调整到队列尾<img src="LRU.png" alt="LRU 页面置换算法"></p>
</li>
<li><p>时钟（clock）置换算法</p>
</li>
</ol>
<h1 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h1><h2 id="设备管理概述"><a href="#设备管理概述" class="headerlink" title="设备管理概述"></a>设备管理概述</h2><p>设备管理目标：</p>
<ul>
<li>提高使用效率</li>
<li>提供便捷的界面</li>
</ul>
<p>设备管理功能：</p>
<ul>
<li>设备的分配与回收</li>
<li>缓冲区管理</li>
<li>设备控制和中断处理</li>
<li>实现虚拟设备</li>
</ul>
<h2 id="设备控制方法"><a href="#设备控制方法" class="headerlink" title="设备控制方法"></a>设备控制方法</h2><ol>
<li><p>程序循环查询方式</p>
</li>
<li><p>中断驱动方式</p>
</li>
<li><p>直接内存访问方式（DMA）</p>
<ul>
<li>数据传输的基本单位是数据块</li>
<li>所传送的数据是从设备直接送入内存，或者直接读出内存的</li>
<li>在传输时CPU参与更少，仅在传送一个或多个数据块的开始和结束时，才需CPU干预，整块数据的传送是在控制器的控制下完成的</li>
</ul>
</li>
<li><p>通道方式</p>
<p>I/O 通道方式是 DMA 方式的发展，它可进一步减少 CPU 的干预，即把对一个数据块的读(或写)为单位的干预，减少为对一组数据块的读(或写)及有关的控制和管理为单位的干预</p>
</li>
</ol>
<h2 id="缓冲技术"><a href="#缓冲技术" class="headerlink" title="缓冲技术"></a>缓冲技术</h2><p>缓冲技术主要有以下作用：</p>
<ul>
<li>改善中央处理器与外围设备之间速度不匹配的矛盾，提高 CPU 和 I/O 设备的并行性</li>
<li>减少 I/O 对 CPU 的中断次数和放宽对 CPU 中断响应时间的要求</li>
<li>协调逻辑记录大小与物理记录大小不一致的问题</li>
</ul>
<h2 id="输入输出软件"><a href="#输入输出软件" class="headerlink" title="输入输出软件"></a>输入输出软件</h2><p><strong>设备独立性</strong>，也称为设备无关性，是指在用户程序中不直接使用物理设备名（或设备的物理地址），而只能使用逻辑设备名。</p>
<ul>
<li>使得设备分配更加灵活，提高了设备的利用率</li>
<li>可以实现 I/O 重定向</li>
</ul>
<h2 id="设备分配与回收"><a href="#设备分配与回收" class="headerlink" title="设备分配与回收"></a>设备分配与回收</h2><h3 id="设备信息描述"><a href="#设备信息描述" class="headerlink" title="设备信息描述"></a>设备信息描述</h3><ol>
<li>系统设备表 SDT</li>
<li>设备控制表 DCT</li>
<li>控制器控制表 COCT</li>
<li>通道控制表 CHCT</li>
</ol>
<h3 id="设备分配策略"><a href="#设备分配策略" class="headerlink" title="设备分配策略"></a>设备分配策略</h3><ol>
<li>独占方式</li>
<li>共享方式</li>
<li>虚拟方式</li>
</ol>
<h3 id="SPOOLing-技术-假脱机"><a href="#SPOOLing-技术-假脱机" class="headerlink" title="SPOOLing 技术(假脱机)"></a>SPOOLing 技术(假脱机)</h3><p>当系统中引入了多道程序技术后，可以利用其中的一道程序，来模拟脱机输入输出时的外围控制机功能，把低速 I/O 设备上的数据传送到高速磁盘上；或者把数据从磁盘传送到低速输出设备上。这样，便可在主机的直接控制下，实现脱机输入输出功能。</p>
<ul>
<li>提高了 I/O 的速度，缓和了高速的处理器与低速输入输出设备之间的矛盾</li>
<li>将独占设备改造为共享设备，提高了设备的利用率</li>
<li>实现了虚拟设备功能，将物理的单个设备变换为多个对应的逻辑设备</li>
</ul>
<h3 id="设备分配算法"><a href="#设备分配算法" class="headerlink" title="设备分配算法"></a>设备分配算法</h3><ul>
<li>先来先服务算法</li>
<li>优先级高者优先算法</li>
</ul>
<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>文件分类方法有很多，下面是常用的几种文件分类方法： </p>
<ul>
<li>按照文件的逻辑结构的不同，可以把文件分成流式文件和纪录式文件</li>
<li>按照用途将文件分为系统文件、库文件和用户文件</li>
<li>按照性质可以把文件分为普通文件、目录文件和特殊文件按照性质可以把文件分为普通文件、目录文件和特殊文件</li>
</ul>
<h2 id="文件的组织"><a href="#文件的组织" class="headerlink" title="文件的组织"></a>文件的组织</h2><h3 id="逻辑结构组织"><a href="#逻辑结构组织" class="headerlink" title="逻辑结构组织"></a>逻辑结构组织</h3><p><strong>1.流式文件</strong></p>
<p>流式文件指文件内的数据不组成记录，只是依次的一串信息集合，如字节流或字符流。流式文件本身可以没有结构。</p>
<p><strong>2.纪录式文件</strong></p>
<p>记录式文件是一种有结构的文件，它是指文件中的数据由若干条定长或不定长的记录构成，每条记录又由若干数据项构成。记录是记录式文件进行存取的基本单位。</p>
<p>按照组织方式的不同，记录式文件可进一步分为：</p>
<ul>
<li>顺序文件</li>
<li>索引文件</li>
<li>索引顺序文件</li>
</ul>
<h3 id="物理结构组织"><a href="#物理结构组织" class="headerlink" title="物理结构组织"></a>物理结构组织</h3><ol>
<li><p>连续文件</p>
</li>
<li><p>链接文件</p>
</li>
<li><p>索引文件<img src="Tertiary-index-eg.png" alt="3 级索引"></p>
</li>
<li><p>直接文件</p>
</li>
</ol>
<h3 id="文件的存取方法"><a href="#文件的存取方法" class="headerlink" title="文件的存取方法"></a>文件的存取方法</h3><ol>
<li>顺序存取</li>
<li>直接存取</li>
<li>按键存取</li>
</ol>
<h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><h3 id="文件目录的基本概念"><a href="#文件目录的基本概念" class="headerlink" title="文件目录的基本概念"></a>文件目录的基本概念</h3><p>文件控制块——用于描述和控制文件的数据结构，称之为文件控制块（File Control Block，FCB）</p>
<ul>
<li>为了加快文件的查找速度，通常把 FCB 集中起来进行管理，文件控制块的有序集合称为<strong>文件目录</strong></li>
<li>文件目录也是以文件的形式保存在外存上的，这就形成了<strong>目录文件</strong></li>
</ul>
<h3 id="目录文件的组织"><a href="#目录文件的组织" class="headerlink" title="目录文件的组织"></a>目录文件的组织</h3><p>常用的组织方法主要有三种：</p>
<ul>
<li>FCB 线性表</li>
<li>索引节点</li>
<li>哈希表组织</li>
</ul>
<h3 id="目录的结构"><a href="#目录的结构" class="headerlink" title="目录的结构"></a>目录的结构</h3><p>目录结构都是采用层次结构，主要分为：</p>
<ul>
<li>单级目录</li>
<li>二级目录</li>
<li>多级层次目录结构（最常用）</li>
<li>图状目录结构</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">gzwang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://gzwangu.github.io/2020/06/05/操作系统/">https://gzwangu.github.io/2020/06/05/操作系统/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://gzwangu.github.io">Rubina の blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><i class="fa fa-chevron-left">  </i><span>计算机网络</span></a></div><div class="next-post pull-right"><a href="/2020/05/05/HDL%E5%A4%8D%E4%B9%A0/"><span>HDL复习</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2022 By gzwang</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>