<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="常用数据结构及C++实现"><meta name="keywords" content="C++"><meta name="author" content="gzwang"><meta name="copyright" content="gzwang"><title>常用数据结构及C++实现 | Rubina の blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%EF%BC%88Array%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">数组（Array）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%EF%BC%88Linked-List%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">链表（Linked List）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-number">2.1.</span> <span class="toc-text">单链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-number">2.2.</span> <span class="toc-text">循环链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">2.3.</span> <span class="toc-text">双向链表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88%EF%BC%88Stack%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">栈（Stack）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%A0%88"><span class="toc-number">3.1.</span> <span class="toc-text">顺序栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E6%A0%88"><span class="toc-number">3.2.</span> <span class="toc-text">链式栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">3.3.</span> <span class="toc-text">栈的应用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%98%9F%E5%88%97%EF%BC%88Queue%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">队列（Queue）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97"><span class="toc-number">4.1.</span> <span class="toc-text">循环队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97"><span class="toc-number">4.2.</span> <span class="toc-text">链式队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E5%BA%94%E7%94%A8"><span class="toc-number">4.3.</span> <span class="toc-text">队列应用</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://gzwangu.github.io/img/avatar.jpg"></div><div class="author-info__name text-center">gzwang</div><div class="author-info__description text-center">Study and Life growth record</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">21</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">30</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">8</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://crownz.run/">crownZ</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://blog.zyuanlee.cn/">Pandalzy</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://blog.zguolee.cn/">Lee</a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Rubina の blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">常用数据结构及C++实现</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-09-16</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">5.5k</span><span class="post-meta__separator">|</span><span>阅读时长: 23 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>最近刷算法题发现能想到用什么数据结构来高效率解题，太弱了具体实现和用法却不会。以前上学没好好听课，现在来恶补一下数据结构。</p>
<p>按照视点的不同，数据结构分为<strong>逻辑结构</strong>和<strong>物理结构</strong>。</p>
<ul>
<li>逻辑结构：指数据元素之间的逻辑关系，这里的逻辑关系是指数据元素之间的前后关系，与数据在计算机中的存储位置无关。</li>
<li>物理结构：指数据的逻辑结构在计算机中的存储形式，也叫做存储结构。</li>
</ul>
<p>数据的逻辑结构主要分为<strong>线性结构</strong>和<strong>非线性结构</strong>。</p>
<ul>
<li>线性结构：数据元素之间是一对一线性关系，所有结点都最多只有一个直接前趋结点和一个直接后继结点。常见的有<em>数组、队列、链表、栈</em>。</li>
<li>非线性结构：数据元素之间具有多个对应关系，一个结点可能有多个直接前趋结点和多个直接后继结点。常见的有<em>多维数组、广义表、树结构和图结构等。</em></li>
</ul>
<p>数据的<strong>物理结构（存储结构）</strong>，表示数据元素之间的逻辑关系的存储形式，数据的逻辑结构根据需要可以采用多种存储结构，常用的存储结构有：</p>
<ol>
<li>顺序存储：存储顺序是连续的，在内存中用一组地址连续的存储单元依次存储线性表的各个数据元素，其数据间的逻辑关系和物理关系是一致的。</li>
<li>链式存储：把数据元素存放在任意的存储单元里，这组存储单元不一定是连续的，元素节点存放数据元素和通过指针指向相邻元素的地址信息。</li>
<li>索引存储：除建立存储结点信息外，还建立附加的索引表来标识节点的地址。索引表由若干索引项组成。</li>
<li>散列存储：也称Hash存储，由节点的关键码值决定节点的存储地址。</li>
</ol>
<p>常用的数据结构有：</p>
<ul>
<li>数组（Array）</li>
<li>链表（Linked List）</li>
<li>栈（Stack）</li>
<li>队列（Queue）</li>
<li>串（String）</li>
<li>树（Tree）</li>
<li>散列表（Hash）</li>
<li>堆（Heap）</li>
<li>图（Graph）</li>
</ul>
<h1 id="数组（Array）"><a href="#数组（Array）" class="headerlink" title="数组（Array）"></a>数组（Array）</h1><p>数组是最基本最常用的数据结构，是一种线性表顺序存储结构，用一段地址连续的内存空间来存储相同类型的数据元素，可通过数组名和下标进行数据的访问和更新。</p>
<p>优点：</p>
<ul>
<li>无须为表示数组元素之间的逻辑关系而增加额外的存储空间</li>
<li>可以快速地存取表中任一位置的元素</li>
</ul>
<p>缺点：</p>
<ul>
<li>插入和删除操作需要移动大量元素</li>
<li>当数组长度变化较大时，难以确定存储空间的容量</li>
<li>造成存储空间的“碎片”</li>
</ul>
<h1 id="链表（Linked-List）"><a href="#链表（Linked-List）" class="headerlink" title="链表（Linked List）"></a>链表（Linked List）</h1><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p>用一组任意的存储单元存储线性表的数据元素，是一种物理存储单元上非连续的存储结构。</p>
<p>在链式结构中，除了存储数据元素信息（<strong>数据域</strong>），还要存储它的后继元素的地址（<strong>指针域</strong>），这两部分信息组成<strong>结点</strong>。链表的每个结点只包含一个指针域称为单链表，对指针域进行反向链接，还可以形成双向链表或者循环链表。</p>
<p><img src="Node.png"></p>
<p>为了更加方便地对链表进行操作，会在单链表的第一个结点前附设一结点，称为<strong>头结点</strong>。头结点的数据域可以不储存任何信息，也可以储存链表的长度等公共数据。若链表为空表，则头结点的指针域为空（NULL）。</p>
<p><img src="LinkedList.png" alt="带头结点的单链表"></p>
<p>链表和数组在实际的使用过程中需要根据自身的优劣势进行选择，区别对比如下：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">数组</th>
<th align="center">链表</th>
</tr>
</thead>
<tbody><tr>
<td align="center">内存地址</td>
<td align="center">连续的内存空间</td>
<td align="center">任意的内存空间</td>
</tr>
<tr>
<td align="center">访问方式</td>
<td align="center">随机访问</td>
<td align="center">顺序访问</td>
</tr>
<tr>
<td align="center">线性表长度</td>
<td align="center">长度固定，一般不可动态扩展</td>
<td align="center">长度可动态变化</td>
</tr>
<tr>
<td align="center">增删效率</td>
<td align="center">低，需要移动被修改元素后的所有元素</td>
<td align="center">高，只需修改指针指向</td>
</tr>
<tr>
<td align="center">查询效率</td>
<td align="center">高，可通过数组名和下标直接访问O(1)</td>
<td align="center">低，只能通过遍历节点一次查询O(n)</td>
</tr>
</tbody></table>
<p>单链表及常用操作C++实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构建结点类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> data;</span><br><span class="line">        Node *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构建单链表类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkList</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">LinkList</span>();  <span class="comment">//</span></span><br><span class="line">        ~<span class="built_in">LinkList</span>();  <span class="comment">//</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">CreateLinkList</span><span class="params">(<span class="keyword">int</span> n)</span></span>; </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">TravalLinkList</span><span class="params">()</span></span>;        <span class="comment">//遍历线性表</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">GetLength</span><span class="params">()</span></span>;              <span class="comment">//获取线性表长度</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>;               <span class="comment">//判断单链表是否为空</span></span><br><span class="line">        <span class="function">Node *<span class="title">Find</span><span class="params">(<span class="keyword">int</span> data)</span></span>; <span class="comment">//查找节点</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">InsertElemAtEnd</span><span class="params">(<span class="keyword">int</span> data)</span></span>;            <span class="comment">//在尾部插入指定的元素</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">InsertElemAtIndex</span><span class="params">(<span class="keyword">int</span> data,<span class="keyword">int</span> n)</span></span>;    <span class="comment">//在指定位置插入指定元素</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">InsertElemAtHead</span><span class="params">(<span class="keyword">int</span> data)</span></span>;           <span class="comment">//在头部插入指定元素</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">DeleteElemAtEnd</span><span class="params">()</span></span>;       <span class="comment">//在尾部删除元素</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">DeleteAll</span><span class="params">()</span></span>;             <span class="comment">//删除所有数据</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">DeleteElemAtPoint</span><span class="params">(<span class="keyword">int</span> data)</span></span>;     <span class="comment">//删除指定的数据</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">DeleteElemAtHead</span><span class="params">()</span></span>;      <span class="comment">//在头部删除节点</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Node *head;              <span class="comment">//头结点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化单链表</span></span><br><span class="line">LinkList::<span class="built_in">LinkList</span>()&#123;</span><br><span class="line">    head = <span class="keyword">new</span> Node;</span><br><span class="line">    head-&gt;data = <span class="number">0</span>;</span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁单链表</span></span><br><span class="line">LinkList::~<span class="built_in">LinkList</span>()&#123;</span><br><span class="line">    Node *ptem = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(head-&gt;next)&#123;</span><br><span class="line">        ptem = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> ptem;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> head;</span><br><span class="line">    head = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建单链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkList::CreateLinkList</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;n error&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Node *pnew,*ptem;  <span class="comment">//声明新结点和临时结点</span></span><br><span class="line">        ptem = head;  <span class="comment">//临时结点指向头结点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            pnew = <span class="keyword">new</span> Node;  <span class="comment">//新结点分配内存</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;input &quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot; value &quot;</span> ;</span><br><span class="line">            cin&gt;&gt;pnew-&gt;data;</span><br><span class="line">            pnew-&gt;next = <span class="literal">nullptr</span>;  <span class="comment">//新结点指向地址为空</span></span><br><span class="line">            ptem-&gt;next = pnew;  <span class="comment">//临时结点指向新结点（链接）</span></span><br><span class="line">            ptem = pnew;  <span class="comment">//新结点设为临时结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历单链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkList::TravalLinkList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next==<span class="literal">nullptr</span>)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Empty LinkList&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Node *p = head;  <span class="comment">//p指向头结点</span></span><br><span class="line">        <span class="keyword">while</span> (p-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            p = p-&gt;next;  <span class="comment">//p指向下一个地址</span></span><br><span class="line">            cout&lt;&lt;p-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取单链表的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinkList::GetLength</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node *p = head;  <span class="comment">// p指向头结点</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断单链表是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LinkList::IsEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next)  <span class="comment">// 判断第一个结点为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找结点</span></span><br><span class="line"><span class="function">Node *<span class="title">LinkList::Find</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    Node *p = head;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data==data)</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        p = p-&gt;next;  <span class="comment">//p指向p的下一个地址</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在尾部插入指定的元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkList::InsertElemAtEnd</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    Node *p = head;  <span class="comment">//p指向头结点</span></span><br><span class="line">    Node *pnew = <span class="keyword">new</span> Node;  <span class="comment">//声明待插入结点</span></span><br><span class="line">    pnew-&gt;data = data;</span><br><span class="line">    pnew-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next)&#123; <span class="comment">//找到尾部结点</span></span><br><span class="line">        p = p-&gt;next; </span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next = pnew;  <span class="comment">// 尾部结点指向新结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在指定位置插入指定元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkList::InsertElemAtIndex</span><span class="params">(<span class="keyword">int</span> data,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">1</span> || n&gt;<span class="built_in">GetLength</span>())  <span class="comment">//位置小于或大于链表长</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;n error&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Node *p = head;</span><br><span class="line">        Node *pnew = <span class="keyword">new</span> Node;</span><br><span class="line">        pnew-&gt;data = data;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;n)&#123;  <span class="comment">//找到待插入位置上一个结点</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        pnew-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next = pnew;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在头部插入指定元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkList::InsertElemAtHead</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    Node *pnew = <span class="keyword">new</span> Node;</span><br><span class="line">    pnew-&gt;data = data;</span><br><span class="line">    pnew-&gt;next = head-&gt;next;</span><br><span class="line">    head-&gt;next = pnew;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在尾部删除元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkList::DeleteElemAtEnd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node *p = head;</span><br><span class="line">    Node *ptem = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next)&#123;</span><br><span class="line">        ptem = p;  <span class="comment">// ptem倒数第二个结点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    p = <span class="literal">nullptr</span>;</span><br><span class="line">    ptem-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除所有数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkList::DeleteAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node *p = head-&gt;next;</span><br><span class="line">    Node *ptem = <span class="keyword">new</span> Node;</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        ptem = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        head-&gt;next = p;</span><br><span class="line">        <span class="keyword">delete</span> ptem;</span><br><span class="line">        <span class="comment">//ptem= nullptr;</span></span><br><span class="line">    &#125;</span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除指定的数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkList::DeleteElemAtPoint</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    Node *ptem = <span class="keyword">new</span> Node;</span><br><span class="line">    Node *p = head;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;data!=data)&#123;</span><br><span class="line">        ptem = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ptem-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    p = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在头部删除节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkList::DeleteElemAtHead</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node *p = head-&gt;next;</span><br><span class="line">    head-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    p = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表（circuar linkedlist)。循环链表解决了一个很麻烦的问题即如何从当中一个结点出发，访问到链表的全部结点。</p>
<p><img src="CircuarLinkedList.png" alt="循环链表"></p>
<p>为了方便查找开始结点和终端结点，不再使用头指针，而是用指向终端结点的<strong>尾指针</strong>来表示循环链表。</p>
<p><strong>约瑟夫环问题</strong>：已知n个人（以编号0,1,2,3,…,n）分别表示）围坐在一张圆桌周围。从编号0的人开始报数，数到m的那个人出列；他的下一个人又从1开始报数，数到m的那个人又出列：依此规律重复下去，知道圆桌周围的人全都出列。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环链表结点类</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环链表类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleList</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node *head;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CircleList</span>();</span><br><span class="line">    ~<span class="built_in">CircleList</span>();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CreateCircleList</span><span class="params">(<span class="keyword">int</span> n)</span></span>;  <span class="comment">// 创建循环链表</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InsertCircleList</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> data)</span></span>;  <span class="comment">// 第pos个元素后插入data</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DeleteCircleList</span><span class="params">()</span></span>;  <span class="comment">// 删除循环链表</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DeleteNode</span><span class="params">(<span class="keyword">int</span> pos)</span></span>;  <span class="comment">// 删除第pos个结点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TravalCircleList</span><span class="params">()</span></span>;  <span class="comment">// 遍历链表</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetLength</span><span class="params">()</span></span>;  <span class="comment">// 获取链表长度 </span></span><br><span class="line">    <span class="function">Node *<span class="title">GetHead</span><span class="params">()</span></span>;  <span class="comment">//获取头结点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CircleList::<span class="built_in">CircleList</span>()&#123;</span><br><span class="line">    head = <span class="keyword">new</span> Node;</span><br><span class="line">    head-&gt;data = <span class="number">0</span>;</span><br><span class="line">    head-&gt;next = head; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CircleList::~<span class="built_in">CircleList</span>()&#123;</span><br><span class="line">    Node *ptem = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (ptem!=head)&#123;</span><br><span class="line">        head-&gt;next = ptem-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> ptem;</span><br><span class="line">        ptem = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> head;</span><br><span class="line">    head = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CircleList::CreateCircleList</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;n error&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Node *pnew, *ptem = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            pnew = <span class="keyword">new</span> Node;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;input &quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot; value &quot;</span> ;</span><br><span class="line">            cin&gt;&gt;pnew-&gt;data;</span><br><span class="line">            pnew-&gt;next= head;</span><br><span class="line">            ptem-&gt;next = pnew;</span><br><span class="line">            ptem = pnew;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CircleList::GetLength</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    Node *p = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p!=head)&#123;</span><br><span class="line">        len++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CircleList::InsertCircleList</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos&gt;<span class="built_in">GetLength</span>()||pos&lt;<span class="number">1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;pos error&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Node *pnew = <span class="keyword">new</span> Node;</span><br><span class="line">        Node *p = head;</span><br><span class="line">        <span class="keyword">while</span> ((pos--)&gt;<span class="number">1</span>)&#123;  <span class="comment">// 找到待插入结点的上个结点</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pnew-&gt;data = data;</span><br><span class="line">        pnew-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next = pnew;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CircleList::DeleteNode</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    Node *p = head,*pd;</span><br><span class="line">    <span class="keyword">if</span>(pos==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next!=head)&#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head-&gt;next;  <span class="comment">// 新头结点</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (pos&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(pos--&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    pd = p-&gt;next;</span><br><span class="line">    p-&gt;next = pd-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> pd;</span><br><span class="line">    pd = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CircleList::DeleteCircleList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node *ptem = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (ptem!=head)</span><br><span class="line">    &#123;</span><br><span class="line">        head-&gt;next = ptem-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> ptem;</span><br><span class="line">        ptem = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CircleList::TravalCircleList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node *ptem = head-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(ptem==head)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;empty&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(ptem!=head)&#123;</span><br><span class="line">            cout&lt;&lt;ptem-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            ptem = ptem-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">CircleList::GetHead</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n;  <span class="comment">// n 个旅客，m 报数值</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;n m&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    CircleList clist;</span><br><span class="line">    clist.<span class="built_in">CreateCircleList</span>(n<span class="number">-1</span>);  <span class="comment">// 用上头结点</span></span><br><span class="line">    Node *p = clist.<span class="built_in">GetHead</span>(),*pre;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;m;j++)&#123;</span><br><span class="line">            pre = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;delete: &quot;</span>&lt;&lt;p-&gt;data&lt;&lt;endl;</span><br><span class="line">        pre-&gt;next = p-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">        p = pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用数学方式解决属实没看懂，<a target="_blank" rel="noopener" href="https://blog.csdn.net/u011500062/article/details/72855826">参考</a>：在 n 个数中最后留下来的数 = 在 n 中去除第 m 个数后剩下 n-1 个数中留下来的数。在0-n-1个数：0，1，2，m-2，m-1，m，…，n-1，去除一个m-1后，剩下为：0，1，2，m-2，m，…，n-1，在这 n-1 个数中，每次计数需要从 m 开始，推导公式 <strong>f(n,m)=(f(n−1,m)+m)%n</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;<span class="comment">// 约瑟夫环</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 判断边界</span></span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;   <span class="comment">// 最后留下的数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            s = (s + m) % i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>双向链表（double linkedlist）是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。</p>
<p>在插入和删除时，需要修改两个指针变量。假设存储元素 e 的结点为 s，要实现将结点 s 插入到结点 p 和 p-&gt;next 之间需要下面几步。<strong>先搞定 s 的前驱和后继，再搞定后结点的前驱，最后解决前结点的后继。</strong></p>
<p><img src="DoubleLinkedlistInsertion.png" alt="双向链表的插入"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s-&gt;prior = p;  <span class="comment">//(1) </span></span><br><span class="line">s-&gt;next = p-&gt;next;  <span class="comment">//(2)</span></span><br><span class="line">p-&gt;next-&gt;prior = s;  <span class="comment">//(3)</span></span><br><span class="line">p-&gt;next = s;  <span class="comment">//(4)</span></span><br></pre></td></tr></table></figure>

<p>若要删除结点 p，只需要下面两个步骤</p>
<p><img src="DoubleLinkedlistDeletion.png" alt="双向链表的删除"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;prior-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next-&gt;prior = p-&gt;prior;</span><br><span class="line"><span class="built_in"><span class="keyword">delete</span></span>(p);</span><br></pre></td></tr></table></figure>

<h1 id="栈（Stack）"><a href="#栈（Stack）" class="headerlink" title="栈（Stack）"></a>栈（Stack）</h1><p><strong>栈（Stack）</strong>是限定仅在表尾进行插入和删除操作的线性表。</p>
<p>允许插入和删除的一端称为<strong>栈顶(top)<strong>，另一端称为</strong>栈底(bottom)<strong>，不含任何数据元素的栈称为</strong>空栈</strong>。栈又称为**后进先出(LIFO)**的线性表，简称 LIFO 结构。</p>
<p>栈是线性表的特例，也有两种典型的存储方式：基于数组的顺序存储（<strong>顺序栈</strong>）和基于链表的链式存储（<strong>链式栈</strong>）</p>
<h2 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h2><p>用数组下标为 0 的一端作为栈底，数组最大允许存放元素个数为 maxSize，定义一个 top 变量来指示栈顶元素在数组中的位置，top = -1 时，置栈为空。</p>
<p><img src="SeqStack.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SeqStack</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> *data;  <span class="comment">// 数组指针</span></span><br><span class="line">    <span class="keyword">int</span> top;  <span class="comment">// 栈顶下标</span></span><br><span class="line">    <span class="keyword">int</span> maxSize;  <span class="comment">// 栈容量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SeqStack</span>(<span class="keyword">int</span> ms=<span class="number">10</span>);</span><br><span class="line">    ~<span class="built_in">SeqStack</span>();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetTop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsEmoty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MakeEmpty</span><span class="params">()</span></span>&#123;top = <span class="number">-1</span>;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetSize</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> top+<span class="number">1</span>;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SeqStack::<span class="built_in">SeqStack</span>(<span class="keyword">int</span> ms)&#123;</span><br><span class="line">    maxSize = ms;</span><br><span class="line">    data = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">    top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SeqStack::~<span class="built_in">SeqStack</span>()&#123;</span><br><span class="line">    <span class="keyword">delete</span> []data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeqStack::Push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(top == maxSize<span class="number">-1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;stack overflow!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        data[++top] = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeqStack::Pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(top == <span class="number">-1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;stack empty!&quot;</span>&lt;&lt;endl; </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        top--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SeqStack::GetTop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(top == <span class="number">-1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;stack empty!&quot;</span>&lt;&lt;endl; </span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data[top];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SeqStack::IsEmoty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (top == <span class="number">-1</span>)? <span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有两个相同类型的栈，我们为它们各自开辟了数组空间，极有可能是第一个栈已经满了，再进栈就溢出了，而另一个栈还有很多存储空间空闲。我们完全可以用一个数组来存储两个栈，数组有两个端点，两个栈有两个栈底，让一个栈的栈底为数组的始端，即下标为 0 处，另一个栈为栈的末端，即下标为数组长度 maxSize-1 处。这样两个栈如果增加元素，就是两端点向中间延伸。</p>
<p><img src="SeqDoubleStack.png"></p>
<p>当然，这只是针对两个具有相同数据类型的栈的一个设计上的技巧，如果不是相同数据类型的栈，或者是多个栈共享栈空间，这种办法不但不能更好地处理问题，反而会使问题变得更复杂。</p>
<h2 id="链式栈"><a href="#链式栈" class="headerlink" title="链式栈"></a>链式栈</h2><p>栈的链式存储结构，简称为链式栈。链式栈的栈顶在链表的表头，栈的插入和删除操作都在表头（不需要头结点）。</p>
<p><img src="LinkStack.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkStack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node *top;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LinkStack</span>()&#123;top = <span class="literal">nullptr</span>;&#125;;</span><br><span class="line">    ~<span class="built_in">LinkStack</span>();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetTop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetSize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MakeEmpty</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LinkStack::~<span class="built_in">LinkStack</span>()&#123;</span><br><span class="line">    Node *p;</span><br><span class="line">    <span class="keyword">while</span> (top != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        p = top;</span><br><span class="line">        top = top-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkStack::Push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    Node *pnew = <span class="keyword">new</span> Node;</span><br><span class="line">    pnew-&gt;data = x;</span><br><span class="line">    pnew-&gt;next = top;</span><br><span class="line">    top = pnew;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkStack::Pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(top != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        Node *pd = top;</span><br><span class="line">        top = top-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> pd;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;stack empty&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinkStack::GetTop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(top != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> top-&gt;data;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;stack empty&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinkStack::GetSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node *p = top;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkStack::MakeEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node *p;</span><br><span class="line">    <span class="keyword">while</span> (top != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        p = top;</span><br><span class="line">        top = top-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h2><p>现在许多高级语言，都对栈结构进行了封装，可以不用关注它的实现细节，可以直接使用 stack 的 push 和 pop 等方法。</p>
<p>把一个直接或间接调用自己的函数，称为<strong>递归函数</strong>。每个递归定义必须至少有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出。</p>
<p>利用<strong>后缀表达</strong>法书写表达式不需要括号，也称为逆波兰表示(RPN)。后缀表达式的计算：<strong>从左到右遍历表达式的每个数字和操作符，遇到是数字就进栈，遇到是操作符 op，就将栈顶连续两个数字 X(先) 和 Y(后) 出栈，进行运算 Y op  X，计算结果进栈，直到表达式所有项都遍历处理完，栈顶存放的就是表达式最终的结果。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string exp;  <span class="comment">// 后缀表达式</span></span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; st;  <span class="comment">// int 类型栈</span></span><br><span class="line">    cin&gt;&gt;exp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;exp.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(exp[i]&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; exp[i]&lt;=<span class="string">&#x27;9&#x27;</span>)  <span class="comment">// 如果是数字</span></span><br><span class="line">            st.<span class="built_in">push</span>(exp[i]-<span class="string">&#x27;0&#x27;</span>);  <span class="comment">// 字符转数字并进栈</span></span><br><span class="line">        <span class="keyword">else</span>&#123;  <span class="comment">// 操作符</span></span><br><span class="line">            <span class="keyword">int</span> x = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">int</span> y = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in"><span class="keyword">switch</span></span> (exp[i])&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: st.<span class="built_in">push</span>(y+x);<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: st.<span class="built_in">push</span>(y-x);<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: st.<span class="built_in">push</span>(y*x);<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: st.<span class="built_in">push</span>(y/x);<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;st.<span class="built_in">top</span>()&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;st.top()&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码看着正确，运行也正确，可是有个很大的缺陷，只能计算 10 以内的加减乘除表达式。</p>
<p>编译程序利用后缀表达法仅用一个栈就可以很快算出表达式的值，而我们平时用的都是标准的四则运算表达式(中缀表达式)，如何<strong>将中缀表达转换为后缀表达</strong>？</p>
<ol>
<li>手工方式</li>
</ol>
<ul>
<li><p>按先乘除后加减的原则给表达式加括号</p>
</li>
<li><p>由内到外把每个括号里的表达式换成后缀</p>
<p>eg：a+b*c+(d*e+f)*g = ((a+(b*c))+(((d*e)+f)*g)) = ((a+bc*)+(de*+f)*g) = ((abc*+)+(de*f+g*)) = abc*+de*f+g*+</p>
</li>
</ul>
<ol>
<li><p>栈的方式</p>
<p>规则：从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级不高于栈顶符号(乘除优先加减），则栈顶元素依次出栈并输出操作符元素，并将当前符号进栈，一直到最终输出后缀表达式为止。</p>
</li>
</ol>
<h1 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h1><p>队列是只允许在表的一端插入，另一端删除的线性表。是一种先进先出(FIFO)结构的线性表，运行插入的一端为队尾，允许删除的一端为队头。</p>
<p><img src="Queue.png"></p>
<h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><p>循环队列是基于数组的存储方式，把数组的前端和后端连接起来，形成一个环形的表，用 front 和 rear 分别指示队列的队头和队尾元素下一位置，初始化时都置为 0，maxSize 是数组的最大长度。在队尾插入新元素和队头删除元素时，队尾和队头指针分别按顺时针方向进 1，两指针进到 maxSize -1 后，再进一个位置就自动到 0。</p>
<ul>
<li>队头指针进 1：front = (front+1)%maxSize</li>
<li>队尾指针进 1：rear = (rear+1)%maxSize</li>
</ul>
<p>如果循环列表读取元素速度快于存储速度，队头很快追上队尾，当 front == rear 时，队列就变成空队列；如果列表存储元素速度快于读取速度，队尾很快追上队头，当 (rear+1)%maxSize  == front 时，队列已满。在循环列表中，最多存放 maxSize-1 个元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SeqQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> rear,front;</span><br><span class="line">    <span class="keyword">int</span> *data;</span><br><span class="line">    <span class="keyword">int</span> maxSize;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SeqQueue</span>(<span class="keyword">int</span> ms = <span class="number">10</span>);</span><br><span class="line">    ~<span class="built_in">SeqQueue</span>();</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsFull</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> ((rear+<span class="number">1</span>)%maxSize==front)?<span class="literal">true</span>:<span class="literal">false</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DeQueue</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetFront</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetSize</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> (rear-front+maxSize)%maxSize;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SeqQueue::<span class="built_in">SeqQueue</span>(<span class="keyword">int</span> ms)&#123;</span><br><span class="line">    maxSize = ms;</span><br><span class="line">    rear = front = <span class="number">0</span>;</span><br><span class="line">    data = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SeqQueue::~<span class="built_in">SeqQueue</span>()&#123;</span><br><span class="line">    <span class="keyword">delete</span> []data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeqQueue::EnQueue</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">IsFull</span>()==<span class="literal">true</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Queue is full&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        data[rear] = x;</span><br><span class="line">        rear = (rear+<span class="number">1</span>)%maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeqQueue::DeQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rear == front)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Queue is empty&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        front = (front+<span class="number">1</span>)%maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SeqQueue::GetFront</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rear == front)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Queue is empty&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data[front];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h2><p>链式队列是基于单链表的存储方式，队列的队头指针指向单链表的第一个结点，队尾指针指向单链表的最后一个结点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkQueue</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node *front,*rear;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LinkQueue</span>();</span><br><span class="line">    ~<span class="built_in">LinkQueue</span>();</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Isempty</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> (front==<span class="literal">nullptr</span>)? <span class="literal">true</span>:<span class="literal">false</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DeQueue</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetFront</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetSize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MakeEmpty</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LinkQueue::<span class="built_in">LinkQueue</span>(<span class="comment">/* args */</span>)&#123;</span><br><span class="line">    front = rear = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LinkQueue::~<span class="built_in">LinkQueue</span>()&#123;</span><br><span class="line">    <span class="built_in">MakeEmpty</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkQueue::EnQueue</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(front == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        front = rear = <span class="keyword">new</span> Node;</span><br><span class="line">        rear-&gt;data = x;</span><br><span class="line">        rear-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Node *pn = <span class="keyword">new</span> Node;</span><br><span class="line">        pn-&gt;data = x;</span><br><span class="line">        pn-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        rear-&gt;next = pn;</span><br><span class="line">        rear = pn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkQueue::DeQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Isempty</span>())&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Queue is empty&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Node *p = front;</span><br><span class="line">        front = front-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinkQueue::GetFront</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Isempty</span>())&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Queue is empty&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> front-&gt;data;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinkQueue::GetSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node *p = front;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkQueue::MakeEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node *pd;</span><br><span class="line">    <span class="keyword">while</span> (front!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        pd = front;</span><br><span class="line">        front = front-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> pd;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="队列应用"><a href="#队列应用" class="headerlink" title="队列应用"></a>队列应用</h2><p>二项展开式 (a+b)^i 的系数，其系数构成杨辉三角。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="comment">// 打印的行数</span></span><br><span class="line">    <span class="keyword">int</span> i,j,t,s=<span class="number">0</span>;  <span class="comment">// 第i行j列的数值为t </span></span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);  <span class="comment">// 预先放入i=1的系数</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="number">0</span>);  <span class="comment">// 每行尾部加入0</span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=(i+<span class="number">2</span>);j++)&#123;</span><br><span class="line">            t = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            q.<span class="built_in">push</span>(s+t);  <span class="comment">// 下一行的数值进队列</span></span><br><span class="line">            s = t;</span><br><span class="line">            <span class="keyword">if</span>(s) cout&lt;&lt;s&lt;&lt;<span class="string">&quot; &quot;</span>;  <span class="comment">// 0不输出</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





























































</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">gzwang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://gzwangu.github.io/2021/09/16/常用数据结构及C++实现/">https://gzwangu.github.io/2021/09/16/常用数据结构及C++实现/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://gzwangu.github.io">Rubina の blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/10/21/C-%E4%B8%ADstring%E7%9A%84%E7%94%A8%E6%B3%95/"><i class="fa fa-chevron-left">  </i><span>C++中string的用法</span></a></div><div class="next-post pull-right"><a href="/2021/03/31/%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%BD%91%E7%BB%9C%E2%80%94MobileNetV1/"><span>轻量级网络—MobileNetV1</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By gzwang</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>