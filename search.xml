<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>DevOps导论-中国大学MOOC</title>
      <link href="2021/11/25/DevOps%E5%AF%BC%E8%AE%BA-%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6MOOC/"/>
      <url>2021/11/25/DevOps%E5%AF%BC%E8%AE%BA-%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6MOOC/</url>
      
        <content type="html"><![CDATA[<h1 id="DevOps概述"><a href="#DevOps概述" class="headerlink" title="DevOps概述"></a>DevOps概述</h1><p>1、下列描述中，不属于典型软件发展三大阶段的是：</p><p>A.网络化和服务化</p><p>B.软硬件一体化阶段</p><p>C.软件成为独立产品</p><p>D.软件作坊</p><p>正确答案：D </p><p>2、”Measure twice, Cut once” 是哪个阶段的典型开发特征？</p><p>A.软件成为独立产品阶段</p><p>B.软硬件一体化阶段</p><p>C.网络化阶段</p><p>D.软件作坊阶段</p><p>正确答案：B </p><p>3、‎关于软件过程管理，以下哪一种说法是比较贴切的：</p><p>A.软件过程管理是软件企业发展到较高层次才需要关心的话题。</p><p>B.软件过程管理主要关注软件成本和质量目标的达成。</p><p>C.软件过程管理关注的是企业软件过程能力的稳定输出和提升。</p><p>D.进入互联网时代，软件过程管理是过于老套的话题。</p><p>正确答案：C </p><p>4、软件开发的本质难题中哪一个与软件发展阶段没有直接关系？</p><p>A.一致性</p><p>B.可变性</p><p>C.复杂性</p><p>D.不可见性</p><p>正确答案：D </p><p>5、‏”Code and Fix” 是软件发展哪个阶段的典型开发特征？ </p><p>A.网络化和服务化</p><p>B.软硬件一体化</p><p>C.软件作为独立产品</p><p>D.互联网时代</p><p>正确答案：B </p><p>6、以下哪个因素促成了软件成为独立的产品？</p><p>A.互联网的出现</p><p>B.个人电脑的出现</p><p>C.操作系统的出现</p><p>D.高级程序设计语言的出现</p><p>正确答案：C </p><p>7‌、软件危机和软件工程这两个概念提出时间是？</p><p>A.上世纪七十年代</p><p>B.上世纪六十年代</p><p>C.上世纪八十年代</p><p>D.上世纪五十年代</p><p>正确答案：B </p><p>8、以下描述中，哪几种是网络化和服务化这个阶段的典型软件应用特征？</p><p>A.通过CD和DVD等方式支持大容量和快速分发软件拷贝</p><p>B.通过SaaS等方式来发布软件系统</p><p>C.快速演化、需求不确定</p><p>D.用户数量急剧增加</p><p>正确答案：B、C、D </p><p>9‌、关于形式化方法的描述当中，不正确的有哪些？</p><p>A.这种方法应用范围有限，例如：不适合跟客户讨论需求。</p><p>B.这种方法的主要目的是解决软件开发的效率问题</p><p>C.这种方法对开发人员技能有较高的要求</p><p>D.这种方法是网络化和服务化阶段用来应对软件开发本质四大难题而提出来的</p><p>正确答案：B、D </p><p>10、关于迭代式方法的说法哪些是比较恰当的？</p><p>A.迭代式方法主要特征在于将软件开发过程视作一个逐步学习和交流的过程</p><p>B.迭代式方法是指一类具有类似特征的方法</p><p>C.迭代式方法是上世纪九十年代中后期才出现的一种方法</p><p>D.迭代式方法主要是为了解决软件开发的质量问题</p><p>正确答案：A、B </p><p>11、‎DevOps方法的出现具有一定的必然性，与以下哪些软件应用特征相匹配？</p><p>A.软件定义世界，软件随处可见</p><p>B.软件在社会生活当中扮演了越来越关键的角色</p><p>C.软件系统部署环境越来越错综复杂</p><p>D.用户需求多变所带来了软件系统的快速演化的要求</p><p>正确答案：A、B、C、D </p><p>12、DevOps的哪些特点可以有效支撑当前社会对软件系统的期望？</p><p>A.虚拟机技术的大量应用</p><p>B.敏捷开发、精益思想以及看板方法，支持快速开发、交付、迭代和演化</p><p>C.微服务架构设计</p><p>D.工具链支持高效率的自动化</p><p>正确答案：A、B、C、D </p><p>13、在DevOps化的three ways当中，关注质量问题是第二个阶段才需要考虑的。</p><p>A.√</p><p>B.×</p><p>正确答案：B </p><p>14、DevOps中的XaaS特指 SaaS、PaaS以及IaaS这三种。</p><p>A.√</p><p>B.×</p><p>正确答案：B </p><p>15、DevOps化的Three ways当中，建立反馈机制是二阶段应该实现的目标。</p><p>A.×</p><p>B.√</p><p>正确答案：B </p><h1 id="个体软件过程"><a href="#个体软件过程" class="headerlink" title="个体软件过程"></a>个体软件过程</h1><p>1、下述各个度量项中，哪一个不是PSP的基本度量项？</p><p>A.缺陷</p><p>B.风险</p><p>C.规模</p><p>D.时间</p><p>正确答案：B  </p><p>2、‏关于面向用户的质量观，我们应该关注如下哪些问题：</p><p>A.用户期望的优先级对软件开发的影响？</p><p>B.用户期望是否有优先级？</p><p>C.真实用户是谁？</p><p>D.界面和可操作性是首要的，因为这是用户能直接感受到的。</p><p>正确答案：A、B、C </p><p>3、‎PSP当中为什么用缺陷管理替代质量管理？下述说法中正确的是：</p><p>A.因为缺陷管理相关的活动（例如，测试等）本来就是软件开发中必须要开展的活动。</p><p>B.因为单纯质量管理很难操作。</p><p>C.因为缺陷管理和质量管理其实是一回事。</p><p>D.因为缺陷往往对应了面向用户质量观中的首要用户期望。</p><p>正确答案：B、D </p><p>4、关于PROBE估算法，下述各种说法中，不正确的有哪些？</p><p>A.PROBE估算结果带着小数，肯定不准确，因而， 不应该在项目估算的时候使用。</p><p>B.PROBE方法不需要历史数据。</p><p>C.PROBE方法不能用来估算质量。</p><p>D.PROBE不能给出精确估算，因而适合用来跟用户讨论需求和规模。</p><p>正确答案：A、B、D </p><p>5‍、关于质量路径（Quality Journey），下列说法中哪些不恰当。</p><p>A.质量路径与个体软件工程师无关，是团队层面的集体努力。</p><p>B.高质量软件产品最终还是需要依赖测试来确保。</p><p>C.进入测试之前的高质量，是获得测试之后高质量软件系统的前提条件。</p><p>D.质量路径中所列举的方法都是提升开发质量的有效手段，可以随意选择使用。</p><p>正确答案：A、D </p><p>6、关于评审检查表，下述说法中不恰当的是：</p><p>A.项目团队所有人应该共用一份评审检查表，体现统一性</p><p>B.评审检查表应该是个性化的</p><p>C.评审检查表应该定期更新</p><p>D.评审检查表应该保持稳定，确保缺陷不会被遗漏</p><p>正确答案：A、D  </p><p>7、关于PQI，下述说法中不恰当的是：</p><p>A.PQI五个分指标都可以超过1.0，比如，设计时间多于编码时间的时候，该分指标就超过1.0了</p><p>B.PQI可以用来辅助判断模块开发的质量</p><p>C.PQI可以为过程改进提供依据</p><p>D.PQI越高越好，最好达到1.0</p><p>正确答案：A、D  </p><p>8、‏关于评审，下述说法中不恰当是：</p><p>A.代码的个人评审也应该通过评审检查表来进行。</p><p>B.如果安排了代码的小组评审，那么代码个人评审就可以不用做。</p><p>C.代码的个人评审应该安排在单元测试之后，确保评审对象有着较高的质量，提升评审价值。</p><p>D.代码的个人评审最好交叉进行，因为阅读自己代码容易产生思维定式，不利于缺陷发现。</p><p>正确答案：C、D  </p><p>9、关于质量的各种定义当中，下述哪些质量属性属于内部属性？</p><p>A.可扩展性</p><p>B.可移植性</p><p>C.可靠性</p><p>D.安全性</p><p>正确答案：A、B  </p><p>10、PSP鼓励使用瀑布型生命周期模型。</p><p>A.√</p><p>B.×</p><p>正确答案：B </p><p>11、‍对于初学者来说，代码评审速度可以控制到每小时不超过400行。</p><p>A.×</p><p>B.√</p><p>正确答案：A  </p><p>12、‌“高质量的软件开发是计划出来的”</p><p>A.√</p><p>B.×</p><p>正确答案：A  </p><h1 id="敏捷软件开发"><a href="#敏捷软件开发" class="headerlink" title="敏捷软件开发"></a>敏捷软件开发</h1><p>1、‌下列哪一项更好地描述了敏捷宣言？</p><p>A.它包含了许多敏捷团队使用的实践</p><p>B.它包含了建立敏捷思维方式的价值观</p><p>C.它定义了构建软件的规则</p><p>D.它概述了构建软件的最有效方法</p><p>正确答案：B </p><p>2、你是一家社交媒体公司的开发人员，正在开发一个项目，项目需要一个为企业客户创建私有网站的新功能。 您需要与公司的网络工程师一起确定部署策略，并提出一组工程师可以用于管理站点的服务和工具。 网络工程师希望在你的网络内部部署所有服务，但您和您的团队成员不同意，并且认为服务应该部署在客户的网络上。 为了达成一个协议，该项目的工作已经停止。 哪种敏捷价值最适合这种情况？</p><p>A.工作的软件 高于 详尽的文档</p><p>B.响应变化 高于 遵循计划</p><p>C.客户合作 高于 合同谈判</p><p>D.个体和互动 高于 流程和工具</p><p>正确答案：C </p><p>3、‍你是一个软件团队的开发人员。 一个用户向你的团队询问有关构建新功能的信息，并以规范的形式提供了需求。 她非常确定这个功能要如何工作，并承诺不会有任何变化。 哪种敏捷价值最适用于这种情况？</p><p>A.响应变化 高于 遵循计划</p><p>B.工作的软件 高于 详尽的文档</p><p>C.客户合作 高于 合同谈判</p><p>D.个体和互动 高于 流程和工具</p><p>正确答案：B </p><p>4、‏Sean是一个正在构建财务软件的团队的开发人员。 他的团队被要求开发一个新的交易系统。 他和他的团队召开会议来提出他们正在使用的工作流的图景。 然后，他们将流程放在白板上，流程中的每个步骤都有一列。 经过对团队在白板上的工作项目进行了几周观察，他们注意到这个过程中有几个步骤似乎过载了。对于他们来说，下一步应该做什么？</p><p>‍A.在较慢的步骤中使用更多的人力</p><p>B.对过载步骤中正在进行的工作项目的数量进行限制</p><p>C.与团队合作，在工作进展缓慢的阶段更好地完成工作</p><p>D.专注于完成看板上的工作</p><p>正确答案：B </p><p>5、‎下列哪一个不是精益原则？</p><p>A.识别所有的步骤</p><p>B.尽可能晚的做决定</p><p>C.消除浪费</p><p>D.实施反馈循环</p><p>正确答案：D </p><p>6、下列哪一个更好地描述了如何使用看板？</p><p>A.观察特征如何流经过程，以便团队可以确定如何限制WIP并通过工作流程中的步骤确定最均匀的工作流程</p><p>B.跟踪缺陷和问题，并创建解决产品问题的最快途径</p><p>C.帮助团队自我组织，并了解工作流程中的瓶颈所在</p><p>D.跟踪WIP限制和当前任务状态，以便团队知道他们还有多少工作要做</p><p>正确答案：A </p><p>7、‍以下不是经常出现在Kanban上记事贴中的内容</p><p>A.完成时间</p><p>B.谁在处理这个工作项</p><p>C.工作项描述</p><p>D.团队名词</p><p>正确答案：D </p><p>8、‍一个公司内，各个团队的Kanban列设置应当一致，便于公司管理。</p><p>A.×</p><p>B.√</p><p>正确答案：A </p><p>9、‏在制品规模越小越好，因为这样可以优化前置时间，并且团队的效率会变高。</p><p>A.√</p><p>B.×</p><p>正确答案：B </p><p>10、‏ 在DevOps中，可以使用Kanban方法，也可以使用Scrum等其他敏捷方法。</p><p>A.√</p><p>B.×</p><p>正确答案：A </p><h1 id="软件架构演化"><a href="#软件架构演化" class="headerlink" title="软件架构演化"></a>软件架构演化</h1><p>1、‍下面关于软件架构的描述哪个是不正确的？</p><p>A.软件架构即一系列重要的设计决策。</p><p>B.软件架构是一组特定的架构元素，包括处理元素、数据元素和上下文元素。</p><p>C.软件架构包含一系列重要决策，包括软件组织、构成系统的结构要素等。</p><p>D.软件架构包括系统组件、连接件和约束的集合。</p><p>正确答案：B<br>解析：  B、软件架构不包含上下文元素。</p><p>2、在应用分层架构的软件系统中，最先处理外部请求的是：</p><p>A.应用层</p><p>B.表现层</p><p>C.业务层</p><p>D.数据层</p><p>正确答案：B<br>解析：  B、在应用分层架构的软件系统中，各层处理外部请求的顺序依次是表现层、业务层、持久层和数据层。</p><p>3、以下哪个关于面向服务架构的描述是错误的？</p><p>A.面向服务架构包含服务提供者组件和服务消费者组件</p><p>B.在SOA中，服务消费者消费其他组件提供的服务不需要知道其具体的实现细节</p><p>C.SOA依赖企业服务总线为服务间的相互调用提供支持环境</p><p>D.面向服务架构是一个集中式组件的集合</p><p>正确答案：D<br>解析：  D、面向服务架构应该是分布式组件的集合。</p><p>4、‏以下对于微服务优点的描述中，哪一个是错误的？</p><p>A.微服务可以使用RPC进行服务间通信</p><p>B.微服务系统测试变得非常简单</p><p>C.单个微服务很简单，只关注一个业务功能</p><p>D.不同的微服务可以使用不同的语言进行开发</p><p>正确答案：B<br>解析：  B、分布式系统的复杂性使得系统测试变得复杂</p><p>5、在微服务架构中，ZooKeeper的主要作用是？</p><p>A.开发服务</p><p>B.调用服务</p><p>C.注册服务</p><p>D.封装服务</p><p>正确答案：C</p><p>6、‍除Spring Boot之外，主流的微服务开发框架还有什么？</p><p>A.Django</p><p>B.Apache Dubbo</p><p>C.Kubernetes</p><p>D.MyBaits</p><p>正确答案：B</p><p>7、‎在组成派看来，软件架构是指？</p><p>A.软件架构由软件元素、这些元素的外部可见属性，以及元素之间的关系组成。</p><p>B.软件架构包括系统组件、连接件和约束的集合。</p><p>C.软件架构将系统定义为计算组件及组件间的交互。</p><p>D.软件架构是一系列重要决策的集合，包括构成系统的结构要素及其接口的选择。</p><p>正确答案：A、B、C<br>解析：  D、决策派的观点</p><p>8、分层架构将软件系统的组件分成多个互不重叠的层，包括</p><p>A.应用层</p><p>B.物理层</p><p>C.表现层</p><p>D.数据层</p><p>正确答案：C、D<br>解析：  A、网络分层  B、网络分层</p><p>9、‎分层架构模式的缺点包括：</p><p>A.不易于持续发布和部署</p><p>B.代码调整通常比较麻烦</p><p>C.额外的性能开销</p><p>D.软件升级需要暂停整个服务</p><p>正确答案：A、B、C、D<br>解析：  C、见分层架构部分“分层架构模式特点”。</p><p>10、‍以下哪几个不是面向服务架构强调的实现原则？</p><p>A.服务去中心化</p><p>B.服务简单</p><p>C.服务解耦</p><p>D.服务自治</p><p>正确答案：A、B<br>解析：  A、微服务架构强调的实现原则。  B、微服务架构强调的实现原则。</p><p>11、‍以下选项中，哪些属于微服务架构的特点？</p><p>A.围绕业务能力组织</p><p>B.通过服务组件化</p><p>C.基础设施自动化</p><p>D.内聚和解耦</p><p>正确答案：A、B、C、D你</p><p>12、‎以下选项中，API网关模式的优点有哪些?</p><p>A.确保客户端不受服务实例位置的影响</p><p>B.增加请求往返次数</p><p>C.为每套客户端提供最优API</p><p>D.确保客户端不必关心应用程序的微服务拆分方式</p><p>正确答案：A、C、D<br>解析：  B、应为“减少”</p><p>13、‎与面向服务架构相关的Web服务标准包括：</p><p>A.HTTPS</p><p>B.UML</p><p>C.WSDL</p><p>D.UDDI</p><p>正确答案：A、C、D<br>解析：  B、应改为XML</p><p>14、‏单体应用的所有功能都被集成在一起作为一个单一的单元。</p><p>A.√</p><p>B.×</p><p>正确答案：A </p><p>15、单体架构更多地作为应用的部署架构，单体应用只运行在一个进程中。</p><p>A.√</p><p>B.×</p><p>正确答案：B<br>解析：可能存在单体应用的多个实例运行在多个进程中。</p><p>16、‍微服务架构架构风格是一种将一个单一应用程序开发为一个小型服务的方法。</p><p>A.×</p><p>B.√</p><p>正确答案：A<br>解析：一组小型服务，而非一个。</p><p>17、‍本质上，微服务架构是SOA的一种扩展。</p><p>A.√</p><p>B.×</p><p>正确答案：A </p><p>18、‏核心模式即针对采用微服务系统在通用场景下的所有问题，所使用的成熟的架构解决方案集合。</p><p>A.√</p><p>B.×</p><p>正确答案：B<br>解析：是在特定场景下的特定问题</p><h1 id="云原生与容器技术"><a href="#云原生与容器技术" class="headerlink" title="云原生与容器技术"></a>云原生与容器技术</h1><p>1、‍下列哪项不是Docker容器的特点：</p><p>A.资源使用较少</p><p>B.可以共享操作系统的资源</p><p>C.启动时间是分钟级</p><p>D.创建速度很快</p><p>正确答案：C </p><p>2、下列哪项不是Docker的网络模式</p><p>A.None模式</p><p>B.Host模式</p><p>C.其他全是</p><p>D.Bridge 模式</p><p>正确答案：C </p><p>3、以下哪些是Docker的存储驱动：‎</p><p>A.其他都是</p><p>B.Device mapper</p><p>C.AUFS</p><p>D.OverlayFS</p><p>正确答案：A </p><p>4、‍以下哪个命令可以查看当前运行容器：</p><p>A.docker logs</p><p>B.docker top</p><p>C.docker run</p><p>D.docker ps</p><p>正确答案：D </p><p>5、‏Kubernetes集群将元数据保存在以下哪个组件：</p><p>A.Etcd</p><p>B.Kubelet</p><p>C.Kube-apiserver</p><p>D.以上都不是</p><p>正确答案：A </p><p>6、‎以下哪些是Kubernetes的控制器：</p><p>A.ReplicaSet</p><p>B.Both ReplicaSet and Deployment</p><p>C.Deployment</p><p>D.Rolling Updates</p><p>正确答案：B </p><p>7、‍以下哪些是Kubernetes的核心概念</p><p>A.Services</p><p>B.其他都是</p><p>C.Volumes</p><p>D.Pods</p><p>正确答案：B </p><p>8、‎Kubernetes里面的Replication控制器的职责是：</p><p>A.帮助达到预期的状态</p><p>B.删除或者更新多个Pod</p><p>C.其他都是</p><p>D.当已存在的Pod异常退出后，创建新的Pod</p><p>正确答案：C </p><p>9、‏如何通过命令行创建一个容器</p><p>A.docker create</p><p>B.docker poll</p><p>C.docker start</p><p>D.docker run</p><p>正确答案：D </p><p>10、‏Dockerfile中的命令 RUN, CMD 和ENTRYPOINT几者有何区别?</p><p>A.ENTRYPOINT 配置容器启动时运行的命令</p><p>B.RUN 执行命令并创建新的镜像层，RUN 经常用于安装软件包。</p><p>C.其他都是</p><p>D.CMD 设置容器启动后默认执行的命令及其参数，但 CMD 能够被 docker run 后面跟的命令行参数替换</p><p>正确答案：C </p><p>11、‏使用Kubernetes带来的好处有哪些</p><p>A.自动调度</p><p>B.其他都是</p><p>C.横向扩展</p><p>D.自动回滚</p><p>正确答案：B </p><p>12、‌以下哪项用于确保pod不会被调度到不适当的节点上？</p><p>A.以上都不是</p><p>B.Taints</p><p>C.Taints 和 Tolerations</p><p>D.Tolerations</p><p>正确答案：C </p><p>13、‎Docker容器的状态有</p><p>A.Restarting</p><p>B.Running</p><p>C.Paused</p><p>D.Exited</p><p>正确答案：B、D </p><p>14、‌关于Kubernetes的namespace的论述是否正确：命名空间是在多个用户之间划分群集资源的方法</p><p>A.×</p><p>B.√</p><p>正确答案：B </p><p>15、‎以下描述是否正确：多步构建允许在Dockerfile中使用多个FROM指令。两个FROM指令之间的所有指令会生产一个中间镜像，最后一个FROM指令之后的指令将生成最终镜像。中间镜像中的文件可以通过COPY –from=<image-number>指令拷贝，其中image-number为镜像编号，0为第一个基础镜像。没有被拷贝的文件都不会存在于最终生成的镜像，这样可以减小镜像大小，同时避免出现安全问题。</p><p>A.√</p><p>B.×</p><p>正确答案：A </p><h1 id="DevOps工具链"><a href="#DevOps工具链" class="headerlink" title="DevOps工具链"></a>DevOps工具链</h1><p>1、‎下列哪项不属于DevOps工具生态圈？</p><p>A.编译</p><p>B.持续集成</p><p>C.持续部署</p><p>D.监控</p><p>正确答案：C </p><p>2、‎下列哪项不属于协同开发工具？</p><p>A.Confluence</p><p>B.Kanban</p><p>C.Rally</p><p>D.JIRA</p><p>正确答案：A </p><p>3、下列哪种持续集成工具是目前DevOps领域使用最广泛的？</p><p>A.Jenkins</p><p>B.Travis CI</p><p>C.TeamCity</p><p>D.VSTS</p><p>正确答案：A </p><p>4、‎下列哪种版本管理工具不是同宗同源的？</p><p>A.Git</p><p>B.Subversion</p><p>C.GitHub</p><p>D.GitLab</p><p>正确答案：B </p><p>5、‌以下哪项不是Git的文件目录？</p><p>A.工作目录</p><p>B.git目录</p><p>C.加载区</p><p>D.Documents</p><p>正确答案：D </p><p>6、‏下列哪种编译工具无法编译JAVA语言？</p><p>A.Ant</p><p>B.MSBuild</p><p>C.Maven</p><p>D.Gradle</p><p>正确答案：B </p><p>7、‍下列哪种工具无法实现对远程服务器的配置操作？</p><p>A.JIRA</p><p>B.Puppt</p><p>C.Ansible</p><p>D.Chef</p><p>正确答案：A </p><p>8、‍下列不属于测试的是</p><p>A.SIT部署</p><p>B.单元测试</p><p>C.UI测试</p><p>D.API测试</p><p>正确答案：A </p><p>9、 使用（）工具完成DevOps持续交付流水线编排配置？</p><p>A.Java</p><p>B.Jenkins</p><p>C.JUnit</p><p>D.SonarQube</p><p>正确答案：B </p><p>10、‏Git是何种工具？</p><p>A.单元测试工具</p><p>B.监控工具</p><p>C.版本管理工具</p><p>D.持续集成工具</p><p>正确答案：C </p><p>11、‌以下哪种工具是开源工具？</p><p>A.JUnit</p><p>B.TeamCity</p><p>C.Zabbix</p><p>D.JIRA</p><p>正确答案：A </p><p>12、下列哪种工具能模拟市场上主流浏览器的操作？</p><p>A.Jenkins</p><p>B.JUnit</p><p>C.Selenium</p><p>D.FitNesse</p><p>正确答案：C </p><p>13、JIRA Software不支持极限编程这种敏捷开发方法。</p><p>A.√</p><p>B.×</p><p>正确答案：A </p><p>14、Jenkins支持工作流即代码（pipeline-as-code）。</p><p>A.√</p><p>B.×</p><p>正确答案：A </p><p>15、‏Git使用副本方式存储文件版本。</p><p>A.×</p><p>B.√</p><p>正确答案：A </p><p>16、‏Selenium能实现自动化单元测试。</p><p>A.×</p><p>B.√</p><p>正确答案：A </p><p>17、‌Nagios不属于监控工具。</p><p>A.×</p><p>B.√</p><p>正确答案：A </p><p>18、Zabbix有两种工作模式。</p><p>A.√</p><p>B.×</p><p>正确答案：A </p><p>19、‏SonarQube能完成持续交付流水线编排配置</p><p>A.×</p><p>B.√</p><p>正确答案：A<br>解析：静态代码扫描</p><p>20、Ansible只需要在Server端安装就能实现对远程服务器的配置管理？</p><p>A.×</p><p>B.√</p><p>正确答案：B </p>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令</title>
      <link href="2021/11/24/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>2021/11/24/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>南京大学软件学院2021级研一《高级Linux系统》课程实验</p><h1 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a>实验一</h1><p>1、按以下磁盘分区规划安装CentOS 7.x：</p><p>/分区：40GB；</p><p>/boot分区：1GB；</p><p>SWAP分区：2GB。</p><p>2、配置FirewallD防火墙，在public区域中添加http服务，5801端口（TCP协议），并保证firewalld服务是启动的。</p><h2 id="CentOS系统安装"><a href="#CentOS系统安装" class="headerlink" title="CentOS系统安装"></a>CentOS系统安装</h2><p>宿主机：Windows 10 64位家庭中文版；Intel(R) Core(TM) i7-7500U CPU @ 2.70GHz  2.90 GHz；12.0 GB RAM；硬盘 1T<br>虚拟机：VMware Workstation 16 Pro<br>ISO镜像：<a href="http://mirrors.nju.edu.cn/centos/7.9.2009/isos/x86_64/">CentOS-7-x86_64-DVD-2009</a><br>安装CentOS-7之前，需要创建新的虚拟机</p><p><img src="101.png"></p><p>选择自定义(高级)，点击下一步</p><p><img src="102.png"></p><p>选择虚拟机硬件兼容性，默认最新</p><p><img src="103.png"></p><p>在新建虚拟机安装向导里选择稍后安装操作系统</p><p><img src="104.png"></p><p>客户机操作系统选择Linux，版本选择CentOS 7 64位</p><p><img src="105.png"></p><p>给虚拟机起名，并选择安装位置</p><p><img src="106.png"></p><p>根据电脑CPU性能为虚拟机选择处理器数量和每个处理器的内核数</p><p><img src="107.png"></p><p>设置虚拟机内存大小，这里设置4GB</p><p><img src="108.png"></p><p>选择虚拟机与真机网络连接方式，选择使用网络地址转换(NAT)</p><p><img src="109.png"></p><p>选择I/O控制器类型，默认即可</p><p><img src="110.png"></p><p>默认选择SCSI(S)磁盘类型</p><p><img src="111.png"></p><p>选择使用哪个磁盘，创建新虚拟磁盘</p><p><img src="112.png"></p><p>选择磁盘大小，设置50GB，不要勾选立即分配所有磁盘空间</p><p><img src="113.png"></p><p>指定存储磁盘的文件，默认即可</p><p><img src="114.png"></p><p>完成创建虚拟机向导</p><p><img src="115.png"></p><p>打开新创建的虚拟机里的编辑虚拟机设置，找到CD/DVD(IDE)一栏，点击使用ISO镜像文件，把本地光盘镜像挂载上</p><p><img src="116.png"></p><p><img src="117.png"></p><p>点击开启此虚拟机，开始安装CentOS 7系统</p><p><img src="118.png"></p><p>选择第一项Install CentOS 7，直接安装CentOS 7等待即可</p><p><img src="119.png"></p><p>选择安装语言，简体中文</p><p><img src="120.png"></p><p>安装信息摘要</p><p><img src="121.png"></p><p>时间和日期设置为亚洲地区，上海城市</p><p><img src="122.png"></p><p>选择汉语键盘布局，点击完成即可</p><p><img src="123.png"></p><p>软件选择GNOME桌面</p><p><img src="124.png"></p><p>点击安装位置，选择我要配置分区，点击完成</p><p><img src="125.png"></p><p><img src="126.png"></p><p>点击加号，选择/boot，给boot分区分1GB，点击添加挂载点</p><p><img src="127.png"></p><p>设置SWAP分区2GB</p><p><img src="128.png"></p><p>设置/分区40GB</p><p><img src="129.png"></p><p>按照上面步骤都分区完毕，点击完成，弹出更改摘要，点击接受更改</p><p><img src="130.png"></p><p>点击网络和主机名，先打开网卡获取到IP地址，再更改主机名</p><p><img src="131.png"></p><p>最后点击开始安装</p><p><img src="132.png"></p><p>设置ROOT密码</p><p><img src="133.png"></p><p>创建用户</p><p><img src="134.png"></p><p>等待系统安装完毕重启系统即可</p><p><img src="135.png"></p><p>初始设置里接受许可证，完成配置</p><p><img src="136.png"></p><p>安装成功界面如下</p><p><img src="137.png"></p><h2 id="FirewallD防火墙配置"><a href="#FirewallD防火墙配置" class="headerlink" title="FirewallD防火墙配置"></a>FirewallD防火墙配置</h2><p>配置FirewallD防火墙，依次点击应用程序—&gt;杂项—防火墙</p><p><img src="138.png"></p><p>配置选择永久，区域选择public，服务里勾选http</p><p><img src="139.png"></p><p>点击端口—&gt;添加，配置5801端口（TCP协议）</p><p><img src="140.png"></p><p>重启后查看防火墙状态、5801端口和public区域的详细信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl status firewalld </span><br><span class="line">firewall-cmd --query-port=5801/tcp</span><br><span class="line">firewall-cmd --list-all</span><br></pre></td></tr></table></figure><p><img src="141.png"></p><p>最后设置防火墙开机启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable firewalld</span><br></pre></td></tr></table></figure><p><img src="142.png"></p><h1 id="实验二"><a href="#实验二" class="headerlink" title="实验二"></a>实验二</h1><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><p>1、使用shutdown命令设定在30分钟之后关闭计算机。</p><ul><li>shutdown -h +30</li></ul><p><img src="201.png"></p><p>2、使用命令将“cat /etc/inittab”设置为别名name，然后再取消别名。</p><ul><li>alias name=’cat /etc/inittab’</li><li>unalias name</li></ul><p><img src="202.png"></p><p>3、使用echo命令和输出重定向创建文本文件/root/nn，内容是Hello，然后再使用追加重定向输入内容为Linux。</p><ul><li>echo Hello&gt; /root/nn</li><li>echo Linux &gt;&gt; /root/nn</li></ul><p><img src="203.png"></p><p>4、使用管道方式分页显示/var目录下的内容。</p><ul><li>ls /var |more</li></ul><p><img src="204.png"></p><p>5、使用cat命令显示文件/etc/passwd和/etc/shadow，只有正确显示第一个文件时才显示第二个文件。</p><ul><li>cat /etc/passwd &amp;&amp; cat /etc/shadow</li></ul><p><img src="205.png"></p><p>6、使用vi编辑器创建文本文件/root/v，文件内容为hell，最后保存退出。</p><ul><li>vi  /root/v</li><li>a</li><li>hell</li><li>“ESC” Enter</li><li>ZZ</li></ul><p><img src="206.png"></p><p>系统默认进入到命令模式，按字母键“a”进入插入模式</p><p><img src="207.png"></p><p>在插入模式下进行文本编辑，内容为hell</p><p><img src="208.png"></p><p>编辑完成，按“Esc”键回到命令模式，再输入ZZ保存退出。</p><p><img src="209.png"></p><h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><p>1、使用命令切换到/etc目录，并显示当前工作目录路径。</p><ul><li>cd /etc</li><li>pwd</li></ul><p><img src="210.png"></p><p>2、使用命令显示/root目录下所有文件目录的详细信息，包括隐藏文件。</p><ul><li>ls -al /root</li></ul><p><img src="211.png"></p><p>3、使用命令创建空文件/root/ab，并将该文件的时间记录更改为2019年8月8日8点8分。</p><ul><li>touch /root/ab</li><li>touch -t 201908080808 /root/ab</li></ul><p><img src="212.png"></p><p>4、使用命令创建具有默认权限为744的目录/root/ak，然后将/etc/inittab文件复制到该目录中，最后再将该目录及其目录下的文件一起删除。</p><ul><li>mkdir -m 744 /root/ak</li><li>cp /etc/inittab /root/ak</li><li>rm -rf /root/ak</li></ul><p><img src="213.png"></p><p>5、统计文件/etc/inittab的行数、单词和字节数。</p><ul><li>wc /etc/inittab</li></ul><p><img src="214.png"></p><p>6、使用命令创建/root/a文件的硬链接文件/root/b和软链接文件/root/c。</p><ul><li>ln /root/a /root/b</li><li>ln -s /root/a /root/c</li></ul><p><img src="215.png"></p><p>先创建空文件/root/a，再创建/root/a文件的硬链接文件/root/b和软链接文件/root/c。a和b文件inode相同，链接数2为硬链接文件，c文件inode不同于a、b，链接数1为软链接文件。</p><h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><p>1、使用命令一次3行显示/etc/inittab文件内容。</p><ul><li>more -3 /etc/inittab</li></ul><p><img src="216.png"></p><p>2、使用cat命令创建mm.txt文件，文件内容为Hello。</p><ul><li>cat &gt;mm.txt&lt;&lt;EOF</li><li>Hello</li><li>EOF</li></ul><p><img src="217.png"></p><p>3、使用命令查找/etc目录下的文件fstab。</p><ul><li>find /etc -name fstab</li></ul><p><img src="218.png"></p><p>4、使用命令将当前计算机的主机名修改为IT。</p><ul><li>hostname IT</li></ul><p><img src="219.png"></p><p>5、使用命令显示公元2018年8月的月历。</p><ul><li>cal 8 2018</li></ul><p><img src="220.png"></p><p>6、使用命令将当前计算机时间设置为2018年8月6日。</p><ul><li>date -s 180806</li></ul><p><img src="221.png"></p><p>7、使用命令显示/etc/fstab文件的文件类型。</p><ul><li>ll /etc/fstab</li></ul><p><img src="222.png"></p><p>8、使用命令显示/root目录的磁盘占用量。</p><ul><li>du -h /root</li></ul><p><img src="223.png"></p><h1 id="实验三"><a href="#实验三" class="headerlink" title="实验三"></a>实验三</h1><h2 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h2><p>1、使用命令创建用户账户zhangsan，并设置其密码为111111，设置用户名全称为“张三”。</p><ul><li>useradd zhangsan</li><li>passwd zhangsan</li><li>usermod -c 张三 zhangsan</li></ul><p><img src="301.png"></p><p>2、使用命令修改用户账户zhangsan的UID为1700，其Shell类型为/bin/ksh。</p><ul><li>usermod -u 1700 zhangsan</li><li>usermod -s /bin/ksh zhangsan</li></ul><p><img src="302.png"></p><p>3、使用命令删除用户账户zhangsan，并且在删除该用户的同时一起删除其主目录。</p><ul><li>userdel -r zhangsan</li></ul><p><img src="303.png"></p><p>4、使用命令创建组群group1，并且在创建时设置其GID为1800。</p><ul><li>groupadd -g 1800 group1</li></ul><p><img src="304.png"></p><p>5、使用命令修改组群group1的新组群名称为“shanghai”。</p><ul><li>groupmod -n shanghai group1</li></ul><p><img src="305.png"></p><h2 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h2><p>1、对硬盘上的剩余空间进行分区，创建两个逻辑驱动器，容量分别为1GB和3GB。</p><p>(1)查看磁盘分区情况：</p><ul><li>fdisk -l</li></ul><p><img src="306.png"></p><p>(2)创建扩展分区，将剩余磁盘空间全都划分给扩展分区：</p><ul><li>fdisk /dev/sda</li></ul><p><img src="307.png"></p><p><img src="308.png"></p><p>(3)创建两个逻辑分区，容量分别为1GB和3GB：</p><p><img src="309.png"></p><p><img src="310.png"></p><p>(4)使用partprobe命令手动将分区信息同步到内核：</p><p><img src="311.png"></p><p>(5)格式化逻辑分区（非必要）：</p><p><img src="312.png"></p><p><img src="313.png"></p><p>2、对1GB分区创建文件系统为xfs，并将其以只读的方式挂载到/mnt/kk目录中。</p><ul><li>mkfs -t xfs /dev/sda5  #若上步格式化成ext4，需要强制格式化使用-f</li><li>mount -o ro /dev/sda5 /mnt/kk</li></ul><p><img src="314.png"></p><p>3、修改/etc/fstab文件，使得1GB分区开机时自动挂载到/mnt/kk目录中。</p><ul><li>blkid /dev/sda5</li><li>nano /etc/fstab</li><li>UUID={UUID} /mnt/kk xfs defaults 1 2</li></ul><p><img src="315.png"></p><p><img src="316.png"></p><p>4、在计算机上添加交换文件，文件大小为1GB。</p><ul><li>dd if=/dev/zero of=/swapfile bs=1024 count=1048576  #1024*1024</li><li>chown root:root /swapfile   #不加权限可能会报错</li><li>chomd 0600 /swapfile </li><li>mkswap /swapfile</li><li>swapon /swapfile</li><li>nano /etc/fstab</li><li>/swapfile swap swap defaults 0 0</li></ul><p><img src="317.png"></p><p><img src="318.png"></p><h2 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h2><p>1、使用rpm命令安装bind-chroot软件包，安装完毕后查看该软件包的描述信息。</p><p>依次安装bind-license-9.11.4-26.P2.el7_9.7.noarch.rpm</p><p>bind-libs-lite-9.11.4-26.P2.el7_9.7.x86_64.rpm</p><p>bind-libs-9.11.4-26.P2.el7_9.7.x86_64.rpm</p><p>bind-9.11.4-26.P2.el7_9.7.x86_64.rpm</p><p>bind-chroot-9.11.4-26.P2.el7_9.7.x86_64.rpm</p><ul><li>rpm -ivh bind-chroot-9.11.4-26.P2.el7_9.7.x86_64.rpm</li></ul><p><img src="319.png"></p><p>2、使用rpm命令查询crontabs软件包所包含的文件列表。</p><ul><li>rpm -ql crontabs</li></ul><p><img src="320.png"></p><p>3、使用rpm命令查询/etc/crontab文件属于哪个软件包。</p><ul><li>rpm -qf /etc/crontab</li></ul><p><img src="321.png"></p><p>4、在Linux系统上修改软件仓库为<a href="https://mirrors.nju.edu.cn./">https://mirrors.nju.edu.cn。</a></p><p><a href="http://mirrors.nju.edu.cn/help/centos">参考CentOS 镜像使用帮助</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo sed -e &#x27;s|^mirrorlist=|#mirrorlist=|g&#x27; \</span><br><span class="line">         -e &#x27;s|^#baseurl=http://mirror.centos.org|baseurl=https://mirror.nju.edu.cn|g&#x27; \</span><br><span class="line">         -i.bak \</span><br><span class="line">         /etc/yum.repos.d/CentOS-Base.repo</span><br><span class="line">         </span><br><span class="line">sudo yum makecache         </span><br></pre></td></tr></table></figure><p><img src="322.png"></p><p><img src="323.png"></p><p>5、使用yum命令安装samba软件包。</p><ul><li>yum install samba</li></ul><p><img src="324.png"></p><p><img src="325.png"></p><p>6、使用yum命令删除bind软件包。</p><ul><li>yum remove bind</li></ul><p><img src="326.png"></p><p>7、归档/root/abc目录，生成文件为/root/abc.tar。</p><ul><li>tar cvf /root/abc.tar /root/abc </li></ul><p><img src="327.png"></p><p>8、使用tar命令调用gzip压缩程序将/root/abc目录压缩成/root/abc.tar.gz文件。</p><ul><li>tar zcvf /root/abc.tar.gz /root/abc </li></ul><p><img src="328.png"></p><h1 id="实验四"><a href="#实验四" class="headerlink" title="实验四"></a>实验四</h1><h2 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h2><p>1、使用文字设定法对/root/ab文件设置权限，所有者为读取、写入和执行权限，同组用户为读取和写入权限，而其他用户没有任何权限。</p><p>2、使用数字设定法设置/root/ab文件的权限，所有者只拥有读取和写入权限。</p><p>3、将/root/ab文件的所有者更改为用户zhangsan。</p><h2 id="第十一章"><a href="#第十一章" class="headerlink" title="第十一章"></a>第十一章</h2><p>1、使用ps命令显示root用户的进程。</p><p>2、强制杀死crond进程。</p><p>3、修改/etc/crontab文件实现自动化，使得每星期一的11:00将/boot目录及其子目录和文件复制到/root/abc目录下。</p><p>4、将网卡名称eno16777736更改为eth0。</p><p>5、使用GRUB2破解root用户的密码。</p><p>6、设置GRUB2 PBKDF2加密口令。</p><h2 id="第十二章"><a href="#第十二章" class="headerlink" title="第十二章"></a>第十二章</h2><p>1、通过修改/etc/sysconfig/network-scripts/ifcfg-eno16777736文件，设置计算机IP地址为192.168.0.2，子网掩码为255.255.255.0，网关IP地址为192.168.0.1。</p><p>2、设置计算机解析域名时所指向的主DNS服务器IP地址为202.96.209.5。</p><p>3、配置网卡eno16777736别名设备eno16777736:1的IP地址为192.168.0.3，并且激活网卡eno16777736:1设备。</p><p>4、使用命令显示当前计算机系统的内核路由表信息。</p><p>5、显示端口号为22的连接情况。</p><p>6、捕获经过网络接口eno16777736的数据包。</p><p>7、使用命令启动named服务，并且设置该服务在计算机启动时一起启动。</p>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中string的用法</title>
      <link href="2021/10/21/C-%E4%B8%ADstring%E7%9A%84%E7%94%A8%E6%B3%95/"/>
      <url>2021/10/21/C-%E4%B8%ADstring%E7%9A%84%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>串（String）是由 n(n&gt;=0) 个字符组成的有限序列，又名字符串。通常记为 s = “a0a1a2…an-1”，其中 ai 是串中的字符，n 是串的字符个数，也是串的长度，它不包括串结束符 ‘\0’，长度为 0 的串称为空串。</p><p>串空是任意串的子串；任一串是它自身的字串。除它本身外，一个串的其他子串都是他的真子串。</p><p>C++ 有关字符串的库函数名称为 <strong># include&lt;string&gt;</strong></p><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">string s;  <span class="comment">// 初始化一个空字符串  </span></span><br><span class="line">s = <span class="string">&quot;12345&quot;</span>;  <span class="comment">// 拷贝初始化 string s = &quot;12345&quot;;</span></span><br><span class="line">string ss[<span class="number">5</span>];  <span class="comment">// 初始化一个空字符串数组</span></span><br><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;123&quot;</span>)</span></span>;  <span class="comment">// 直接初始化</span></span><br><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(s1)</span></span>;  <span class="comment">// s2是s1的副本</span></span><br><span class="line">string s3=s2;  <span class="comment">// s3是s2的副本</span></span><br><span class="line"><span class="function">string <span class="title">s4</span><span class="params">(<span class="number">5</span>,<span class="string">&#x27;a&#x27;</span>)</span></span>;  <span class="comment">// s4 = &quot;aaaaa&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> cs[]=<span class="string">&quot;12345&quot;</span>;</span><br><span class="line"><span class="function">string <span class="title">s5</span><span class="params">(cs,<span class="number">3</span>)</span></span>;  <span class="comment">// 复制字符串cs的前3个字符到s5中</span></span><br><span class="line">string s6=<span class="string">&quot;0123456&quot;</span>;</span><br><span class="line"><span class="function">string <span class="title">s7</span><span class="params">(s6,<span class="number">2</span>)</span></span>;  <span class="comment">//从s6下标为2的字符开始拷贝至结束</span></span><br><span class="line"><span class="function">string <span class="title">s8</span><span class="params">(s6,<span class="number">2</span>,<span class="number">4</span>)</span></span>;  <span class="comment">// 从s6下标2开始4个字符的拷贝，若超过s6.size只拷贝到s6尾部</span></span><br><span class="line"><span class="function">string <span class="title">s9</span><span class="params">(s6,<span class="number">2</span>,<span class="number">10</span>)</span></span>;  <span class="comment">// s9.size = 5</span></span><br><span class="line"></span><br><span class="line">cout&lt;&lt;s,s1...s9&lt;&lt;endl;</span><br><span class="line"><span class="number">12345</span></span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="number">123</span></span><br><span class="line">aaaaa</span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="number">0123456</span></span><br><span class="line"><span class="number">23456</span></span><br><span class="line"><span class="number">2345</span></span><br><span class="line"><span class="number">23456</span>  </span><br></pre></td></tr></table></figure><h1 id="串处理"><a href="#串处理" class="headerlink" title="串处理"></a>串处理</h1><p><strong>substr 操作</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;0123456&quot;</span>;</span><br><span class="line"><span class="comment">// s.substr(pos,n)返回从位置为pos后面的n个字符组成的串</span></span><br><span class="line">string s1 = s.<span class="built_in">substr</span>(<span class="number">1</span>,<span class="number">5</span>); <span class="comment">// 12345</span></span><br><span class="line"><span class="comment">// s.substr(pos)得到一个从pos到结尾的串</span></span><br><span class="line">string s2 = s.<span class="built_in">substr</span>(<span class="number">4</span>); <span class="comment">// 456</span></span><br></pre></td></tr></table></figure><p><strong>insert 操作</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;0123456789&quot;</span>;</span><br><span class="line">string str1 = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">string str2 = <span class="string">&quot;ABCDEFGHIJKLMN&quot;</span>;</span><br><span class="line">string::iterator it;</span><br><span class="line"><span class="comment">//s.insert(pos,str)在s的pos位置插入str</span></span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">6</span>,str1); <span class="comment">// 012345abcd6789</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//s.insert(pos,str,a,n)在s的pos位置插入str中位置a到后面的n个字符</span></span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">6</span>,str2,<span class="number">3</span>,<span class="number">4</span>); <span class="comment">// 012345DEFGabcd6789</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//s.insert(pos,cstr,n)//在pos位置插入cstr字符串从开始到后面的n个字符</span></span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">10</span>,<span class="string">&quot;must be string&quot;</span>,<span class="number">8</span>); <span class="comment">// 012345DEFGmust be abcd6789</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//s.insert(pos,cstr)在s的pos位置插入cstr</span></span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">10</span>,<span class="string">&quot;string &quot;</span>); <span class="comment">// 012345DEFGstring must be abcd6789</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//s.insert(pos,n,ch)在s.pos位置上面插入n个ch</span></span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">10</span>,<span class="number">2</span>,<span class="string">&#x27;:&#x27;</span>); <span class="comment">// 012345DEFG::string must be abcd6789</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//s.insert(s.it,ch)在s的it指向位置插入一个字符ch，返回新插入的位置的迭代器</span></span><br><span class="line">it = str.<span class="built_in">insert</span>(str.<span class="built_in">begin</span>()+<span class="number">6</span>,<span class="string">&#x27;-&#x27;</span>); <span class="comment">// 012345-DEFG::string must be abcd6789</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//s.insert(s.it,n,ch)在s的it所指向位置插入n个ch</span></span><br><span class="line">str.<span class="built_in">insert</span> (str.<span class="built_in">end</span>(),<span class="number">3</span>,<span class="string">&#x27;.&#x27;</span>); <span class="comment">// 012345-DEFG::string must be abcd6789...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//s.insert(it,str.ita,str.itb)在it所指向的位置插入[ita,itb)的字符串</span></span><br><span class="line">str.<span class="built_in">insert</span> (it+<span class="number">1</span>,str2.<span class="built_in">begin</span>(),str2.<span class="built_in">begin</span>()+<span class="number">3</span>); <span class="comment">// 012345-ABCDEFG::string must be abcd6789...</span></span><br></pre></td></tr></table></figure><p><strong>erase 操作</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;0123456789&quot;</span>;</span><br><span class="line"><span class="comment">//s.erase(pos,n)删除pos位置开始n个字符</span></span><br><span class="line">str.<span class="built_in">erase</span>(<span class="number">3</span>,<span class="number">2</span>); <span class="comment">// 01256789</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//s.erase(s.it)删除迭代器指向的字符</span></span><br><span class="line">str.<span class="built_in">erase</span>(str.<span class="built_in">begin</span>()+<span class="number">3</span>); <span class="comment">// 0126789</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//s.erase(str.ita,str.itb)删除迭代器范围的字符</span></span><br><span class="line">str.<span class="built_in">erase</span>(str.<span class="built_in">begin</span>()+<span class="number">3</span>, str.<span class="built_in">end</span>()<span class="number">-1</span>); <span class="comment">// 0129</span></span><br></pre></td></tr></table></figure><p><strong>append 操作</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">string str1 = <span class="string">&quot;12345&quot;</span>;</span><br><span class="line">string str2 = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//s.append(str)直接追加一个str的字符串</span></span><br><span class="line">str.<span class="built_in">append</span>(str1); <span class="comment">// 012345</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//s.append(str,pos,n)追加str中pos位置开始的n个字符</span></span><br><span class="line">str.<span class="built_in">append</span>(str2,<span class="number">4</span>,<span class="number">2</span>); <span class="comment">// 012345ef</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//s.append(cstr,n)追加字符串形参cstr的前n个字符</span></span><br><span class="line">str.<span class="built_in">append</span>(<span class="string">&quot;string&quot;</span>,<span class="number">2</span>); <span class="comment">// 012345efst</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//s.append(cstr)直接追加cstr</span></span><br><span class="line">str.<span class="built_in">append</span>(<span class="string">&quot;haha&quot;</span>); <span class="comment">// 012345efsthaha</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//s.append(n,ch)添加n个ch</span></span><br><span class="line">str.<span class="built_in">append</span>(<span class="number">3</span>,<span class="string">&#x27;.&#x27;</span>); <span class="comment">// 012345efsthaha...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//s.append(str.ita,str.itb)添加str迭代器范围的字符串</span></span><br><span class="line">str.<span class="built_in">append</span>(str2.<span class="built_in">begin</span>()+<span class="number">2</span>,str2.<span class="built_in">end</span>()<span class="number">-2</span>); <span class="comment">// 012345efsthaha...cde</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串追加也可以用重载运算符实现</span></span><br><span class="line">str += <span class="string">&quot;add&quot;</span>; <span class="comment">// 012345efsthaha...cdeadd</span></span><br></pre></td></tr></table></figure><p>replace 操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;012345678&quot;</span>;</span><br><span class="line">string str1 = <span class="string">&quot;12345&quot;</span>;</span><br><span class="line">string str2 = <span class="string">&quot;abcd&quot;</span>;    </span><br><span class="line"></span><br><span class="line"><span class="comment">//s.replace(pos,n,str)从pos位置开始n个字符被str代替</span></span><br><span class="line">str.<span class="built_in">replace</span>(<span class="number">4</span>,<span class="number">3</span>,str1); <span class="comment">// 01231234578</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//s.replace(pos1,n1,str,pos2,n2)从pos1位置开始n1个字符被str串pos2位置开始n2个字符代替</span></span><br><span class="line">str.<span class="built_in">replace</span>(<span class="number">3</span>,<span class="number">5</span>,str2,<span class="number">1</span>,<span class="number">2</span>); <span class="comment">// 012bc578</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//s.replace(pos,n,cstr)从pos位置开始n个字符被cstr代替</span></span><br><span class="line">str.<span class="built_in">replace</span>(<span class="number">3</span>,<span class="number">4</span>,<span class="string">&quot;string&quot;</span>); <span class="comment">// 012string8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//s.replace(pos,n1,cstr,n2)从pos位置开始n1个字符被cstr的前n2个字符代替</span></span><br><span class="line">str.<span class="built_in">replace</span>(<span class="number">3</span>,<span class="number">5</span>,<span class="string">&quot;sample&quot;</span>,<span class="number">4</span>);  <span class="comment">// 012sampg8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//s.replace(pos,n1,n2,ch)从pos位置开始n1个字符被n2个ch字符代替</span></span><br><span class="line">str.<span class="built_in">replace</span>(<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">&#x27;!&#x27;</span>); <span class="comment">// 012sam!!!8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用迭代器同上</span></span><br><span class="line">str.<span class="built_in">replace</span>(str.<span class="built_in">begin</span>()+<span class="number">3</span>,str.<span class="built_in">end</span>()<span class="number">-1</span>,str1); <span class="comment">// 012123458</span></span><br><span class="line">str.<span class="built_in">replace</span>(str.<span class="built_in">begin</span>()+<span class="number">3</span>,str.<span class="built_in">end</span>()<span class="number">-4</span>,str2.<span class="built_in">begin</span>(),str2.<span class="built_in">end</span>()<span class="number">-1</span>); <span class="comment">// 012abc3458</span></span><br><span class="line">str.<span class="built_in">replace</span>(str.<span class="built_in">begin</span>()+<span class="number">3</span>,str.<span class="built_in">begin</span>()+<span class="number">5</span>,<span class="string">&quot;it-str&quot;</span>); <span class="comment">// 012it-strc3458</span></span><br><span class="line">str.<span class="built_in">replace</span>(str.<span class="built_in">begin</span>()+<span class="number">4</span>,str.<span class="built_in">begin</span>()+<span class="number">8</span>,<span class="string">&quot;sample&quot;</span>,<span class="number">3</span>); <span class="comment">// 012isamrc3458</span></span><br><span class="line">str.<span class="built_in">replace</span>(str.<span class="built_in">begin</span>()+<span class="number">1</span>,str.<span class="built_in">end</span>()<span class="number">-4</span>,<span class="number">1</span>,<span class="string">&#x27;.&#x27;</span>); <span class="comment">// 0.3458</span></span><br></pre></td></tr></table></figure><p><strong>assign 操作</strong></p><p>assign 操作在一起列容器当中都存在，比如 vector 等等。是一个很基本的操作函数，string 使用 assign 可以灵活的对其进行赋值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">string str;</span><br><span class="line">string str1 = <span class="string">&quot;01234567&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//s.assign(str)直接把str赋值给s</span></span><br><span class="line">str.<span class="built_in">assign</span>(str1); <span class="comment">// 01234567</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//s.assign(str,pos,n)把str中pos位置开始的n个字符赋给s</span></span><br><span class="line">str.<span class="built_in">assign</span>(str1,<span class="number">4</span>,<span class="number">3</span>); <span class="comment">//456</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//s.assign(cstr)直接使用参数赋值</span></span><br><span class="line">str.<span class="built_in">assign</span>(<span class="string">&quot;c-string&quot;</span>); <span class="comment">// c-string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//s.assign(n,ch)赋值n个ch字符</span></span><br><span class="line">str.<span class="built_in">assign</span>(<span class="number">5</span>,<span class="string">&#x27;*&#x27;</span>); <span class="comment">// *****</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//s.assign(str.ita,str.itb)指定str迭代器范围的字符串</span></span><br><span class="line">str.<span class="built_in">assign</span>(str1.<span class="built_in">begin</span>()+<span class="number">1</span>,str1.<span class="built_in">end</span>()<span class="number">-2</span>); <span class="comment">// 12345</span></span><br></pre></td></tr></table></figure><h1 id="串搜索"><a href="#串搜索" class="headerlink" title="串搜索"></a>串搜索</h1><p><strong>find 和 rfind 用法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//（1）size_t find (const string&amp; str, size_t pos = 0) const;  //查找对象--string类对象</span></span><br><span class="line"><span class="comment">//（2）size_t find (const char* s, size_t pos = 0) const; //查找对象--字符串</span></span><br><span class="line"><span class="comment">//（3）size_t find (const char* s, size_t pos, size_t n) const;  //查找对象--字符串的前n个字符</span></span><br><span class="line"><span class="comment">//（4）size_t find (char c, size_t pos = 0) const;  //查找对象--字符</span></span><br><span class="line">string str1 = <span class="string">&quot;I will find you and love you.&quot;</span>;</span><br><span class="line">string str2 = <span class="string">&quot;you&quot;</span>;</span><br><span class="line"><span class="keyword">size_t</span> ff_index;</span><br><span class="line"><span class="keyword">size_t</span> lf_index;</span><br><span class="line"></span><br><span class="line"><span class="comment">// s.find(str)在s中查找第一个出现的str，找到则返回出现的位置，否则返回-1</span></span><br><span class="line">ff_index = str1.<span class="built_in">find</span>(str2); <span class="comment">// 12</span></span><br><span class="line">ff_index = str1.<span class="built_in">find</span>(<span class="string">&quot;will&quot;</span>); <span class="comment">// 2</span></span><br><span class="line">lf_index = str1.<span class="built_in">rfind</span>(str2); <span class="comment">// 25</span></span><br><span class="line">lf_index = str1.<span class="built_in">rfind</span>(<span class="string">&quot;will&quot;</span>); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// // s.find(cstr,pos,n)从s的第pos位置查找ctsr参数字符串的前n个字符</span></span><br><span class="line">ff_index = str1.<span class="built_in">find</span>(<span class="string">&quot;you are cute&quot;</span>,<span class="number">13</span>,<span class="number">3</span>); <span class="comment">// 25</span></span><br><span class="line">lf_index = str1.<span class="built_in">rfind</span>(<span class="string">&quot;you are cute&quot;</span>,<span class="number">30</span>,<span class="number">4</span>); <span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// // s,find(ch)查找第一个ch字符</span></span><br><span class="line">ff_index = str1.<span class="built_in">find</span>(<span class="string">&#x27;f&#x27;</span>); <span class="comment">// 7</span></span><br><span class="line">lf_index = str1.<span class="built_in">rfind</span>(<span class="string">&#x27;o&#x27;</span>); <span class="comment">// 26</span></span><br></pre></td></tr></table></figure><p><strong>find….of 用法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// find_first_of(args) 查找args中任何一个字符第一次出现的位置</span></span><br><span class="line"><span class="comment">// find_last_of(args) 最后一个出现的位置</span></span><br><span class="line"><span class="comment">// find_fist_not_of(args) 查找第一个不在args中的字符</span></span><br><span class="line"><span class="comment">// find_last_not_of 查找最后一个不在args中出现的字符</span></span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;software string find is hard.&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">size_t</span> ffo,flo,ffno,flno;</span><br><span class="line">ffo = str.<span class="built_in">find_first_of</span>(<span class="string">&quot;aeiou&quot;</span>); <span class="comment">// 1</span></span><br><span class="line">flo = str.<span class="built_in">find_last_of</span>(<span class="string">&quot;aeiou&quot;</span>); <span class="comment">// 25</span></span><br><span class="line">ffno = str.<span class="built_in">find_first_not_of</span>(<span class="string">&quot;aeiou&quot;</span>); <span class="comment">// 0</span></span><br><span class="line">flno = str.<span class="built_in">find_last_not_of</span>(<span class="string">&quot;aeiou&quot;</span>); <span class="comment">// 28</span></span><br></pre></td></tr></table></figure><p><strong>compare 用法</strong></p><p>如果两个字符串相等，那么返回0，调用对象大于参数返回1，小于返回-1。string 重载了运算符，可以直接用 &gt;、&lt; 和 ==来进行比较。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">string s1=<span class="string">&quot;123&quot;</span>,s2=<span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> cmp = s1.<span class="built_in">compare</span>(s2); <span class="comment">// 0</span></span><br><span class="line">s1 = <span class="string">&quot;223&quot;</span>;</span><br><span class="line">s2 = <span class="string">&quot;1234&quot;</span>;</span><br><span class="line">cmp =  s1.<span class="built_in">compare</span>(s2); <span class="comment">// 1</span></span><br><span class="line">s1 = <span class="string">&quot;012345&quot;</span>;</span><br><span class="line">s2 = <span class="string">&quot;12345&quot;</span>;</span><br><span class="line">cmp = s1.<span class="built_in">compare</span>(s2); <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//s.compare(pos,n,str)s串pos位置开始的n个字符和str比较</span></span><br><span class="line">cmp = s1.<span class="built_in">compare</span>(<span class="number">1</span>,<span class="number">5</span>,s2); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//s.compare(pos1,n1,str,pos2,n2)s串pos1位置开始的n1个字符和str串pos2位置开始的n2个字符比较</span></span><br><span class="line">cmp = s1.<span class="built_in">compare</span>(<span class="number">2</span>,<span class="number">3</span>,s2,<span class="number">2</span>,<span class="number">3</span>); <span class="comment">// -1 234&lt;345</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用数据结构及C++实现</title>
      <link href="2021/09/16/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8AC++%E5%AE%9E%E7%8E%B0/"/>
      <url>2021/09/16/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8AC++%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>最近刷算法题发现能想到用什么数据结构来高效率解题，太弱了具体实现和用法却不会。以前上学没好好听课，现在来恶补一下数据结构。</p><p>按照视点的不同，数据结构分为<strong>逻辑结构</strong>和<strong>物理结构</strong>。</p><ul><li>逻辑结构：指数据元素之间的逻辑关系，这里的逻辑关系是指数据元素之间的前后关系，与数据在计算机中的存储位置无关。</li><li>物理结构：指数据的逻辑结构在计算机中的存储形式，也叫做存储结构。</li></ul><p>数据的逻辑结构主要分为<strong>线性结构</strong>和<strong>非线性结构</strong>。</p><ul><li>线性结构：数据元素之间是一对一线性关系，所有结点都最多只有一个直接前趋结点和一个直接后继结点。常见的有<em>数组、队列、链表、栈</em>。</li><li>非线性结构：数据元素之间具有多个对应关系，一个结点可能有多个直接前趋结点和多个直接后继结点。常见的有<em>多维数组、广义表、树结构和图结构等。</em></li></ul><p>数据的<strong>物理结构（存储结构）</strong>，表示数据元素之间的逻辑关系的存储形式，数据的逻辑结构根据需要可以采用多种存储结构，常用的存储结构有：</p><ol><li>顺序存储：存储顺序是连续的，在内存中用一组地址连续的存储单元依次存储线性表的各个数据元素，其数据间的逻辑关系和物理关系是一致的。</li><li>链式存储：把数据元素存放在任意的存储单元里，这组存储单元不一定是连续的，元素节点存放数据元素和通过指针指向相邻元素的地址信息。</li><li>索引存储：除建立存储结点信息外，还建立附加的索引表来标识节点的地址。索引表由若干索引项组成。</li><li>散列存储：也称Hash存储，由节点的关键码值决定节点的存储地址。</li></ol><p>常用的数据结构有：</p><ul><li>数组（Array）</li><li>链表（Linked List）</li><li>栈（Stack）</li><li>队列（Queue）</li><li>串（String）</li><li>树（Tree）</li><li>散列表（Hash）</li><li>堆（Heap）</li><li>图（Graph）</li></ul><h1 id="数组（Array）"><a href="#数组（Array）" class="headerlink" title="数组（Array）"></a>数组（Array）</h1><p>数组是最基本最常用的数据结构，是一种线性表顺序存储结构，用一段地址连续的内存空间来存储相同类型的数据元素，可通过数组名和下标进行数据的访问和更新。</p><p>优点：</p><ul><li>无须为表示数组元素之间的逻辑关系而增加额外的存储空间</li><li>可以快速地存取表中任一位置的元素</li></ul><p>缺点：</p><ul><li>插入和删除操作需要移动大量元素</li><li>当数组长度变化较大时，难以确定存储空间的容量</li><li>造成存储空间的“碎片”</li></ul><h1 id="链表（Linked-List）"><a href="#链表（Linked-List）" class="headerlink" title="链表（Linked List）"></a>链表（Linked List）</h1><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p>用一组任意的存储单元存储线性表的数据元素，是一种物理存储单元上非连续的存储结构。</p><p>在链式结构中，除了存储数据元素信息（<strong>数据域</strong>），还要存储它的后继元素的地址（<strong>指针域</strong>），这两部分信息组成<strong>结点</strong>。链表的每个结点只包含一个指针域称为单链表，对指针域进行反向链接，还可以形成双向链表或者循环链表。</p><p><img src="Node.png"></p><p>为了更加方便地对链表进行操作，会在单链表的第一个结点前附设一结点，称为<strong>头结点</strong>。头结点的数据域可以不储存任何信息，也可以储存链表的长度等公共数据。若链表为空表，则头结点的指针域为空（NULL）。</p><p><img src="LinkedList.png" alt="带头结点的单链表"></p><p>链表和数组在实际的使用过程中需要根据自身的优劣势进行选择，区别对比如下：</p><table><thead><tr><th align="center"></th><th align="center">数组</th><th align="center">链表</th></tr></thead><tbody><tr><td align="center">内存地址</td><td align="center">连续的内存空间</td><td align="center">任意的内存空间</td></tr><tr><td align="center">访问方式</td><td align="center">随机访问</td><td align="center">顺序访问</td></tr><tr><td align="center">线性表长度</td><td align="center">长度固定，一般不可动态扩展</td><td align="center">长度可动态变化</td></tr><tr><td align="center">增删效率</td><td align="center">低，需要移动被修改元素后的所有元素</td><td align="center">高，只需修改指针指向</td></tr><tr><td align="center">查询效率</td><td align="center">高，可通过数组名和下标直接访问O(1)</td><td align="center">低，只能通过遍历节点一次查询O(n)</td></tr></tbody></table><p>单链表及常用操作C++实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构建结点类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> data;</span><br><span class="line">        Node *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构建单链表类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkList</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">LinkList</span>();  <span class="comment">//</span></span><br><span class="line">        ~<span class="built_in">LinkList</span>();  <span class="comment">//</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">CreateLinkList</span><span class="params">(<span class="keyword">int</span> n)</span></span>; </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">TravalLinkList</span><span class="params">()</span></span>;        <span class="comment">//遍历线性表</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">GetLength</span><span class="params">()</span></span>;              <span class="comment">//获取线性表长度</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>;               <span class="comment">//判断单链表是否为空</span></span><br><span class="line">        <span class="function">Node *<span class="title">Find</span><span class="params">(<span class="keyword">int</span> data)</span></span>; <span class="comment">//查找节点</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">InsertElemAtEnd</span><span class="params">(<span class="keyword">int</span> data)</span></span>;            <span class="comment">//在尾部插入指定的元素</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">InsertElemAtIndex</span><span class="params">(<span class="keyword">int</span> data,<span class="keyword">int</span> n)</span></span>;    <span class="comment">//在指定位置插入指定元素</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">InsertElemAtHead</span><span class="params">(<span class="keyword">int</span> data)</span></span>;           <span class="comment">//在头部插入指定元素</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">DeleteElemAtEnd</span><span class="params">()</span></span>;       <span class="comment">//在尾部删除元素</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">DeleteAll</span><span class="params">()</span></span>;             <span class="comment">//删除所有数据</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">DeleteElemAtPoint</span><span class="params">(<span class="keyword">int</span> data)</span></span>;     <span class="comment">//删除指定的数据</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">DeleteElemAtHead</span><span class="params">()</span></span>;      <span class="comment">//在头部删除节点</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Node *head;              <span class="comment">//头结点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化单链表</span></span><br><span class="line">LinkList::<span class="built_in">LinkList</span>()&#123;</span><br><span class="line">    head = <span class="keyword">new</span> Node;</span><br><span class="line">    head-&gt;data = <span class="number">0</span>;</span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁单链表</span></span><br><span class="line">LinkList::~<span class="built_in">LinkList</span>()&#123;</span><br><span class="line">    Node *ptem = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(head-&gt;next)&#123;</span><br><span class="line">        ptem = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> ptem;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> head;</span><br><span class="line">    head = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建单链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkList::CreateLinkList</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;n error&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Node *pnew,*ptem;  <span class="comment">//声明新结点和临时结点</span></span><br><span class="line">        ptem = head;  <span class="comment">//临时结点指向头结点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            pnew = <span class="keyword">new</span> Node;  <span class="comment">//新结点分配内存</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;input &quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot; value &quot;</span> ;</span><br><span class="line">            cin&gt;&gt;pnew-&gt;data;</span><br><span class="line">            pnew-&gt;next = <span class="literal">nullptr</span>;  <span class="comment">//新结点指向地址为空</span></span><br><span class="line">            ptem-&gt;next = pnew;  <span class="comment">//临时结点指向新结点（链接）</span></span><br><span class="line">            ptem = pnew;  <span class="comment">//新结点设为临时结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历单链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkList::TravalLinkList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next==<span class="literal">nullptr</span>)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Empty LinkList&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Node *p = head;  <span class="comment">//p指向头结点</span></span><br><span class="line">        <span class="keyword">while</span> (p-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            p = p-&gt;next;  <span class="comment">//p指向下一个地址</span></span><br><span class="line">            cout&lt;&lt;p-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取单链表的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinkList::GetLength</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node *p = head;  <span class="comment">// p指向头结点</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断单链表是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LinkList::IsEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next)  <span class="comment">// 判断第一个结点为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找结点</span></span><br><span class="line"><span class="function">Node *<span class="title">LinkList::Find</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    Node *p = head;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data==data)</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        p = p-&gt;next;  <span class="comment">//p指向p的下一个地址</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在尾部插入指定的元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkList::InsertElemAtEnd</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    Node *p = head;  <span class="comment">//p指向头结点</span></span><br><span class="line">    Node *pnew = <span class="keyword">new</span> Node;  <span class="comment">//声明待插入结点</span></span><br><span class="line">    pnew-&gt;data = data;</span><br><span class="line">    pnew-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next)&#123; <span class="comment">//找到尾部结点</span></span><br><span class="line">        p = p-&gt;next; </span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next = pnew;  <span class="comment">// 尾部结点指向新结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在指定位置插入指定元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkList::InsertElemAtIndex</span><span class="params">(<span class="keyword">int</span> data,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">1</span> || n&gt;<span class="built_in">GetLength</span>())  <span class="comment">//位置小于或大于链表长</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;n error&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Node *p = head;</span><br><span class="line">        Node *pnew = <span class="keyword">new</span> Node;</span><br><span class="line">        pnew-&gt;data = data;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;n)&#123;  <span class="comment">//找到待插入位置上一个结点</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        pnew-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next = pnew;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在头部插入指定元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkList::InsertElemAtHead</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    Node *pnew = <span class="keyword">new</span> Node;</span><br><span class="line">    pnew-&gt;data = data;</span><br><span class="line">    pnew-&gt;next = head-&gt;next;</span><br><span class="line">    head-&gt;next = pnew;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在尾部删除元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkList::DeleteElemAtEnd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node *p = head;</span><br><span class="line">    Node *ptem = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next)&#123;</span><br><span class="line">        ptem = p;  <span class="comment">// ptem倒数第二个结点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    p = <span class="literal">nullptr</span>;</span><br><span class="line">    ptem-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除所有数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkList::DeleteAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node *p = head-&gt;next;</span><br><span class="line">    Node *ptem = <span class="keyword">new</span> Node;</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        ptem = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        head-&gt;next = p;</span><br><span class="line">        <span class="keyword">delete</span> ptem;</span><br><span class="line">        <span class="comment">//ptem= nullptr;</span></span><br><span class="line">    &#125;</span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除指定的数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkList::DeleteElemAtPoint</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    Node *ptem = <span class="keyword">new</span> Node;</span><br><span class="line">    Node *p = head;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;data!=data)&#123;</span><br><span class="line">        ptem = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ptem-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    p = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在头部删除节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkList::DeleteElemAtHead</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node *p = head-&gt;next;</span><br><span class="line">    head-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    p = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表（circuar linkedlist)。循环链表解决了一个很麻烦的问题即如何从当中一个结点出发，访问到链表的全部结点。</p><p><img src="CircuarLinkedList.png" alt="循环链表"></p><p>为了方便查找开始结点和终端结点，不再使用头指针，而是用指向终端结点的<strong>尾指针</strong>来表示循环链表。</p><p><strong>约瑟夫环问题</strong>：已知n个人（以编号0,1,2,3,…,n）分别表示）围坐在一张圆桌周围。从编号0的人开始报数，数到m的那个人出列；他的下一个人又从1开始报数，数到m的那个人又出列：依此规律重复下去，知道圆桌周围的人全都出列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环链表结点类</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环链表类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleList</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node *head;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CircleList</span>();</span><br><span class="line">    ~<span class="built_in">CircleList</span>();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CreateCircleList</span><span class="params">(<span class="keyword">int</span> n)</span></span>;  <span class="comment">// 创建循环链表</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InsertCircleList</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> data)</span></span>;  <span class="comment">// 第pos个元素后插入data</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DeleteCircleList</span><span class="params">()</span></span>;  <span class="comment">// 删除循环链表</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DeleteNode</span><span class="params">(<span class="keyword">int</span> pos)</span></span>;  <span class="comment">// 删除第pos个结点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TravalCircleList</span><span class="params">()</span></span>;  <span class="comment">// 遍历链表</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetLength</span><span class="params">()</span></span>;  <span class="comment">// 获取链表长度 </span></span><br><span class="line">    <span class="function">Node *<span class="title">GetHead</span><span class="params">()</span></span>;  <span class="comment">//获取头结点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CircleList::<span class="built_in">CircleList</span>()&#123;</span><br><span class="line">    head = <span class="keyword">new</span> Node;</span><br><span class="line">    head-&gt;data = <span class="number">0</span>;</span><br><span class="line">    head-&gt;next = head; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CircleList::~<span class="built_in">CircleList</span>()&#123;</span><br><span class="line">    Node *ptem = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (ptem!=head)&#123;</span><br><span class="line">        head-&gt;next = ptem-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> ptem;</span><br><span class="line">        ptem = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> head;</span><br><span class="line">    head = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CircleList::CreateCircleList</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;n error&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Node *pnew, *ptem = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            pnew = <span class="keyword">new</span> Node;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;input &quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot; value &quot;</span> ;</span><br><span class="line">            cin&gt;&gt;pnew-&gt;data;</span><br><span class="line">            pnew-&gt;next= head;</span><br><span class="line">            ptem-&gt;next = pnew;</span><br><span class="line">            ptem = pnew;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CircleList::GetLength</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    Node *p = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p!=head)&#123;</span><br><span class="line">        len++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CircleList::InsertCircleList</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos&gt;<span class="built_in">GetLength</span>()||pos&lt;<span class="number">1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;pos error&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Node *pnew = <span class="keyword">new</span> Node;</span><br><span class="line">        Node *p = head;</span><br><span class="line">        <span class="keyword">while</span> ((pos--)&gt;<span class="number">1</span>)&#123;  <span class="comment">// 找到待插入结点的上个结点</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pnew-&gt;data = data;</span><br><span class="line">        pnew-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next = pnew;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CircleList::DeleteNode</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    Node *p = head,*pd;</span><br><span class="line">    <span class="keyword">if</span>(pos==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next!=head)&#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head-&gt;next;  <span class="comment">// 新头结点</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (pos&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(pos--&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    pd = p-&gt;next;</span><br><span class="line">    p-&gt;next = pd-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> pd;</span><br><span class="line">    pd = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CircleList::DeleteCircleList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node *ptem = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (ptem!=head)</span><br><span class="line">    &#123;</span><br><span class="line">        head-&gt;next = ptem-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> ptem;</span><br><span class="line">        ptem = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CircleList::TravalCircleList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node *ptem = head-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(ptem==head)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;empty&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(ptem!=head)&#123;</span><br><span class="line">            cout&lt;&lt;ptem-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            ptem = ptem-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">CircleList::GetHead</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n;  <span class="comment">// n 个旅客，m 报数值</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;n m&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    CircleList clist;</span><br><span class="line">    clist.<span class="built_in">CreateCircleList</span>(n<span class="number">-1</span>);  <span class="comment">// 用上头结点</span></span><br><span class="line">    Node *p = clist.<span class="built_in">GetHead</span>(),*pre;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;m;j++)&#123;</span><br><span class="line">            pre = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;delete: &quot;</span>&lt;&lt;p-&gt;data&lt;&lt;endl;</span><br><span class="line">        pre-&gt;next = p-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">        p = pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用数学方式解决属实没看懂，<a href="https://blog.csdn.net/u011500062/article/details/72855826">参考</a>：在 n 个数中最后留下来的数 = 在 n 中去除第 m 个数后剩下 n-1 个数中留下来的数。在0-n-1个数：0，1，2，m-2，m-1，m，…，n-1，去除一个m-1后，剩下为：0，1，2，m-2，m，…，n-1，在这 n-1 个数中，每次计数需要从 m 开始，推导公式 <strong>f(n,m)=(f(n−1,m)+m)%n</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;<span class="comment">// 约瑟夫环</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 判断边界</span></span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;   <span class="comment">// 最后留下的数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            s = (s + m) % i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>双向链表（double linkedlist）是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。</p><p>在插入和删除时，需要修改两个指针变量。假设存储元素 e 的结点为 s，要实现将结点 s 插入到结点 p 和 p-&gt;next 之间需要下面几步。<strong>先搞定 s 的前驱和后继，再搞定后结点的前驱，最后解决前结点的后继。</strong></p><p><img src="DoubleLinkedlistInsertion.png" alt="双向链表的插入"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s-&gt;prior = p;  <span class="comment">//(1) </span></span><br><span class="line">s-&gt;next = p-&gt;next;  <span class="comment">//(2)</span></span><br><span class="line">p-&gt;next-&gt;prior = s;  <span class="comment">//(3)</span></span><br><span class="line">p-&gt;next = s;  <span class="comment">//(4)</span></span><br></pre></td></tr></table></figure><p>若要删除结点 p，只需要下面两个步骤</p><p><img src="DoubleLinkedlistDeletion.png" alt="双向链表的删除"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;prior-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next-&gt;prior = p-&gt;prior;</span><br><span class="line"><span class="built_in"><span class="keyword">delete</span></span>(p);</span><br></pre></td></tr></table></figure><h1 id="栈（Stack）"><a href="#栈（Stack）" class="headerlink" title="栈（Stack）"></a>栈（Stack）</h1><p><strong>栈（Stack）</strong>是限定仅在表尾进行插入和删除操作的线性表。</p><p>允许插入和删除的一端称为<strong>栈顶(top)<strong>，另一端称为</strong>栈底(bottom)<strong>，不含任何数据元素的栈称为</strong>空栈</strong>。栈又称为**后进先出(LIFO)**的线性表，简称 LIFO 结构。</p><p>栈是线性表的特例，也有两种典型的存储方式：基于数组的顺序存储（<strong>顺序栈</strong>）和基于链表的链式存储（<strong>链式栈</strong>）</p><h2 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h2><p>用数组下标为 0 的一端作为栈底，数组最大允许存放元素个数为 maxSize，定义一个 top 变量来指示栈顶元素在数组中的位置，top = -1 时，置栈为空。</p><p><img src="SeqStack.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SeqStack</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> *data;  <span class="comment">// 数组指针</span></span><br><span class="line">    <span class="keyword">int</span> top;  <span class="comment">// 栈顶下标</span></span><br><span class="line">    <span class="keyword">int</span> maxSize;  <span class="comment">// 栈容量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SeqStack</span>(<span class="keyword">int</span> ms=<span class="number">10</span>);</span><br><span class="line">    ~<span class="built_in">SeqStack</span>();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetTop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsEmoty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MakeEmpty</span><span class="params">()</span></span>&#123;top = <span class="number">-1</span>;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetSize</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> top+<span class="number">1</span>;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SeqStack::<span class="built_in">SeqStack</span>(<span class="keyword">int</span> ms)&#123;</span><br><span class="line">    maxSize = ms;</span><br><span class="line">    data = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">    top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SeqStack::~<span class="built_in">SeqStack</span>()&#123;</span><br><span class="line">    <span class="keyword">delete</span> []data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeqStack::Push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(top == maxSize<span class="number">-1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;stack overflow!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        data[++top] = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeqStack::Pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(top == <span class="number">-1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;stack empty!&quot;</span>&lt;&lt;endl; </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        top--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SeqStack::GetTop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(top == <span class="number">-1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;stack empty!&quot;</span>&lt;&lt;endl; </span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data[top];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SeqStack::IsEmoty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (top == <span class="number">-1</span>)? <span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有两个相同类型的栈，我们为它们各自开辟了数组空间，极有可能是第一个栈已经满了，再进栈就溢出了，而另一个栈还有很多存储空间空闲。我们完全可以用一个数组来存储两个栈，数组有两个端点，两个栈有两个栈底，让一个栈的栈底为数组的始端，即下标为 0 处，另一个栈为栈的末端，即下标为数组长度 maxSize-1 处。这样两个栈如果增加元素，就是两端点向中间延伸。</p><p><img src="SeqDoubleStack.png"></p><p>当然，这只是针对两个具有相同数据类型的栈的一个设计上的技巧，如果不是相同数据类型的栈，或者是多个栈共享栈空间，这种办法不但不能更好地处理问题，反而会使问题变得更复杂。</p><h2 id="链式栈"><a href="#链式栈" class="headerlink" title="链式栈"></a>链式栈</h2><p>栈的链式存储结构，简称为链式栈。链式栈的栈顶在链表的表头，栈的插入和删除操作都在表头（不需要头结点）。</p><p><img src="LinkStack.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkStack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node *top;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LinkStack</span>()&#123;top = <span class="literal">nullptr</span>;&#125;;</span><br><span class="line">    ~<span class="built_in">LinkStack</span>();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetTop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetSize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MakeEmpty</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LinkStack::~<span class="built_in">LinkStack</span>()&#123;</span><br><span class="line">    Node *p;</span><br><span class="line">    <span class="keyword">while</span> (top != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        p = top;</span><br><span class="line">        top = top-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkStack::Push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    Node *pnew = <span class="keyword">new</span> Node;</span><br><span class="line">    pnew-&gt;data = x;</span><br><span class="line">    pnew-&gt;next = top;</span><br><span class="line">    top = pnew;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkStack::Pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(top != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        Node *pd = top;</span><br><span class="line">        top = top-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> pd;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;stack empty&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinkStack::GetTop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(top != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> top-&gt;data;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;stack empty&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinkStack::GetSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node *p = top;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkStack::MakeEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node *p;</span><br><span class="line">    <span class="keyword">while</span> (top != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        p = top;</span><br><span class="line">        top = top-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h2><p>现在许多高级语言，都对栈结构进行了封装，可以不用关注它的实现细节，可以直接使用 stack 的 push 和 pop 等方法。</p><p>把一个直接或间接调用自己的函数，称为<strong>递归函数</strong>。每个递归定义必须至少有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出。</p><p>利用<strong>后缀表达</strong>法书写表达式不需要括号，也称为逆波兰表示(RPN)。后缀表达式的计算：<strong>从左到右遍历表达式的每个数字和操作符，遇到是数字就进栈，遇到是操作符 op，就将栈顶连续两个数字 X(先) 和 Y(后) 出栈，进行运算 Y op  X，计算结果进栈，直到表达式所有项都遍历处理完，栈顶存放的就是表达式最终的结果。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string exp;  <span class="comment">// 后缀表达式</span></span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; st;  <span class="comment">// int 类型栈</span></span><br><span class="line">    cin&gt;&gt;exp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;exp.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(exp[i]&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; exp[i]&lt;=<span class="string">&#x27;9&#x27;</span>)  <span class="comment">// 如果是数字</span></span><br><span class="line">            st.<span class="built_in">push</span>(exp[i]-<span class="string">&#x27;0&#x27;</span>);  <span class="comment">// 字符转数字并进栈</span></span><br><span class="line">        <span class="keyword">else</span>&#123;  <span class="comment">// 操作符</span></span><br><span class="line">            <span class="keyword">int</span> x = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">int</span> y = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in"><span class="keyword">switch</span></span> (exp[i])&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: st.<span class="built_in">push</span>(y+x);<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: st.<span class="built_in">push</span>(y-x);<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: st.<span class="built_in">push</span>(y*x);<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: st.<span class="built_in">push</span>(y/x);<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;st.<span class="built_in">top</span>()&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;st.top()&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码看着正确，运行也正确，可是有个很大的缺陷，只能计算 10 以内的加减乘除表达式。</p><p>编译程序利用后缀表达法仅用一个栈就可以很快算出表达式的值，而我们平时用的都是标准的四则运算表达式(中缀表达式)，如何<strong>将中缀表达转换为后缀表达</strong>？</p><ol><li>手工方式</li></ol><ul><li><p>按先乘除后加减的原则给表达式加括号</p></li><li><p>由内到外把每个括号里的表达式换成后缀</p><p>eg：a+b*c+(d*e+f)*g = ((a+(b*c))+(((d*e)+f)*g)) = ((a+bc*)+(de*+f)*g) = ((abc*+)+(de*f+g*)) = abc*+de*f+g*+</p></li></ul><ol><li><p>栈的方式</p><p>规则：从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级不高于栈顶符号(乘除优先加减），则栈顶元素依次出栈并输出操作符元素，并将当前符号进栈，一直到最终输出后缀表达式为止。</p></li></ol><h1 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h1><p>队列是只允许在表的一端插入，另一端删除的线性表。是一种先进先出(FIFO)结构的线性表，运行插入的一端为队尾，允许删除的一端为队头。</p><p><img src="Queue.png"></p><h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><p>循环队列是基于数组的存储方式，把数组的前端和后端连接起来，形成一个环形的表，用 front 和 rear 分别指示队列的队头和队尾元素下一位置，初始化时都置为 0，maxSize 是数组的最大长度。在队尾插入新元素和队头删除元素时，队尾和队头指针分别按顺时针方向进 1，两指针进到 maxSize -1 后，再进一个位置就自动到 0。</p><ul><li>队头指针进 1：front = (front+1)%maxSize</li><li>队尾指针进 1：rear = (rear+1)%maxSize</li></ul><p>如果循环列表读取元素速度快于存储速度，队头很快追上队尾，当 front == rear 时，队列就变成空队列；如果列表存储元素速度快于读取速度，队尾很快追上队头，当 (rear+1)%maxSize  == front 时，队列已满。在循环列表中，最多存放 maxSize-1 个元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SeqQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> rear,front;</span><br><span class="line">    <span class="keyword">int</span> *data;</span><br><span class="line">    <span class="keyword">int</span> maxSize;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SeqQueue</span>(<span class="keyword">int</span> ms = <span class="number">10</span>);</span><br><span class="line">    ~<span class="built_in">SeqQueue</span>();</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsFull</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> ((rear+<span class="number">1</span>)%maxSize==front)?<span class="literal">true</span>:<span class="literal">false</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DeQueue</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetFront</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetSize</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> (rear-front+maxSize)%maxSize;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SeqQueue::<span class="built_in">SeqQueue</span>(<span class="keyword">int</span> ms)&#123;</span><br><span class="line">    maxSize = ms;</span><br><span class="line">    rear = front = <span class="number">0</span>;</span><br><span class="line">    data = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SeqQueue::~<span class="built_in">SeqQueue</span>()&#123;</span><br><span class="line">    <span class="keyword">delete</span> []data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeqQueue::EnQueue</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">IsFull</span>()==<span class="literal">true</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Queue is full&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        data[rear] = x;</span><br><span class="line">        rear = (rear+<span class="number">1</span>)%maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeqQueue::DeQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rear == front)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Queue is empty&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        front = (front+<span class="number">1</span>)%maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SeqQueue::GetFront</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rear == front)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Queue is empty&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data[front];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h2><p>链式队列是基于单链表的存储方式，队列的队头指针指向单链表的第一个结点，队尾指针指向单链表的最后一个结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkQueue</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node *front,*rear;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LinkQueue</span>();</span><br><span class="line">    ~<span class="built_in">LinkQueue</span>();</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Isempty</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> (front==<span class="literal">nullptr</span>)? <span class="literal">true</span>:<span class="literal">false</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DeQueue</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetFront</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetSize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MakeEmpty</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LinkQueue::<span class="built_in">LinkQueue</span>(<span class="comment">/* args */</span>)&#123;</span><br><span class="line">    front = rear = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LinkQueue::~<span class="built_in">LinkQueue</span>()&#123;</span><br><span class="line">    <span class="built_in">MakeEmpty</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkQueue::EnQueue</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(front == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        front = rear = <span class="keyword">new</span> Node;</span><br><span class="line">        rear-&gt;data = x;</span><br><span class="line">        rear-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Node *pn = <span class="keyword">new</span> Node;</span><br><span class="line">        pn-&gt;data = x;</span><br><span class="line">        pn-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        rear-&gt;next = pn;</span><br><span class="line">        rear = pn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkQueue::DeQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Isempty</span>())&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Queue is empty&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Node *p = front;</span><br><span class="line">        front = front-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinkQueue::GetFront</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Isempty</span>())&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Queue is empty&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> front-&gt;data;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinkQueue::GetSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node *p = front;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkQueue::MakeEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node *pd;</span><br><span class="line">    <span class="keyword">while</span> (front!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        pd = front;</span><br><span class="line">        front = front-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> pd;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="队列应用"><a href="#队列应用" class="headerlink" title="队列应用"></a>队列应用</h2><p>二项展开式 (a+b)^i 的系数，其系数构成杨辉三角。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="comment">// 打印的行数</span></span><br><span class="line">    <span class="keyword">int</span> i,j,t,s=<span class="number">0</span>;  <span class="comment">// 第i行j列的数值为t </span></span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);  <span class="comment">// 预先放入i=1的系数</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="number">0</span>);  <span class="comment">// 每行尾部加入0</span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=(i+<span class="number">2</span>);j++)&#123;</span><br><span class="line">            t = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            q.<span class="built_in">push</span>(s+t);  <span class="comment">// 下一行的数值进队列</span></span><br><span class="line">            s = t;</span><br><span class="line">            <span class="keyword">if</span>(s) cout&lt;&lt;s&lt;&lt;<span class="string">&quot; &quot;</span>;  <span class="comment">// 0不输出</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>轻量级网络—MobileNetV1</title>
      <link href="2021/03/31/%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%BD%91%E7%BB%9C%E2%80%94MobileNetV1/"/>
      <url>2021/03/31/%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%BD%91%E7%BB%9C%E2%80%94MobileNetV1/</url>
      
        <content type="html"><![CDATA[<h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>MobileNet 是用于移动和嵌入式视觉应用的高效模型。基于一种流线型（streamlined）的架构，该架构使用深度可分离卷积（depthwise separable convolutions）来构建轻量级深度神经网络。同时引入两个简单的全局超参数，在延迟和准确率之间进行了有效的权衡。这些超参数允许模型构建者根据问题的约束为其应用程序选择适当大小的模型。论文在资源和精度权衡方面进行了大量的实验，并与其他流行的 ImageNet 分类模型对比显示了的强大性能。然后，论文在广泛的应用和用例中论证了移动网络的有效性，包括目标检测、细粒度分类、人脸属性和大规模地理定位。</p><p><img src="Figure1.png"></p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>深度卷积神经网络在计算机视觉中变得无处不在，为了获得更高的精度而使网络更加深更复杂。然而，这些提高准确性的进步并不一定使网络在规模和速度方面更有效。在许多现实世界的应用中，如机器人、自动驾驶汽车和增强现实，识别任务需要在一个计算有限的平台上及时执行。</p><p>本文描述了使用一种高效的网络架构和一组两个超参数（宽度和分辨率）来构建非常小、低延迟的模型，这模型可以轻松满足移动和嵌入式视觉应用的设计要求。</p><h1 id="Prior-Work"><a href="#Prior-Work" class="headerlink" title="Prior Work"></a>Prior Work</h1><p>在最近的文献中，构建小而高效的神经网络方法通常有两种：<strong>压缩预训练网络</strong>和<strong>直接训练小型网络</strong>。</p><h1 id="MobileNet-Architecture"><a href="#MobileNet-Architecture" class="headerlink" title="MobileNet Architecture"></a>MobileNet Architecture</h1><p>在本节中，首先描述构建 MobileNet 的核心层<strong>深度可分离卷积</strong>。然后描述 MobileNet 的网络结构，并对<strong>宽度乘法器</strong>和<strong>分辨率乘法器</strong>这两个模型超参数进行了描述。</p><h2 id="Depthwise-Separable-Convolution"><a href="#Depthwise-Separable-Convolution" class="headerlink" title="Depthwise Separable Convolution"></a>Depthwise Separable Convolution</h2><p>MobileNet 是基于深度可分离卷积构建的网络，它是将标准卷积拆分为了两个操作：<strong>深度卷积</strong>（depthwise convolution）和 <strong>逐点卷积</strong>（pointwise convolution）。</p><p>深度卷积和标准卷积不同，对于标准卷积而言其卷积核是用在所有的输入通道上（input channels），而深度卷积将卷积核拆分成为<strong>单通道</strong>形式，针对每个输入通道采用不同的卷积核，就是说一个卷积核对应一个输入通道，<strong>对每一通道进行卷积</strong>操作，这样就得到了和输入特征图通道数一致的输出特征图。而逐点卷积就是普通的卷积，只不过其采用 1x1 的卷积核，主要作用就是对特征图进行升维和降维。</p><p>这么做的好处就是可以大幅度<strong>降低参数量</strong>和<strong>计算量</strong>，但是能达到和标准卷积差不多的效果。</p><p><img src="Figure2.png"></p><ul><li>F 为输入特征图；DF 为输入的宽度和高度；M 为输入通道数</li><li>K 为卷积核；DK 为卷积核的维度</li><li>G 为输出特征图； DG 为输出的宽度和高度；N为输出通道数</li></ul><p><strong>假设步长（stride）为 1 且填充（padding），这时候卷积前后的尺寸不变（DG=DF）</strong></p><p><strong>标准卷积</strong></p><ul><li>卷积核的尺寸是 Dk×Dk×M，一共有N个，所以标准卷积的参数量（params）是：DK x DK x M x N    </li><li>输出特征图大小为 DF x DF，一共要做 DF x DF 次乘加运算，所以标准卷积的计算量是：DK x DK x M x N x DF x DF</li></ul><p><strong>深度可分离卷积</strong></p><p><img src="DepthwiseSeparableConvolution.png"></p><ul><li>深度卷积的卷积核尺寸 Dk×Dk×1，一共 M 个；逐点卷积的卷积核尺寸为 1×1×M，一共有 N 个，所以深度可分离卷积的参数量是：DK x DK x M + M x N</li><li>深度卷积和逐点卷积得到的输出特征图大小都是 DF x DF，各做 DF x DF 次乘运算，所以深度可分离卷积的计算量是：DK x DK x M x DF x DF + M x N x DF x DF</li></ul><p>可以减少如下的计算量:</p><p>（DK x DK x M x DF x DF + M x N x DF x DF）/（DK x DK x M x N x DF x DF）= 1 / N + 1 / DK^2</p><p>MobileNet 使用 3 × 3 深度可分离卷积，它比标准卷积的计算量少 8 到 9 倍，而精度只有 1% 很小的降低。</p><p><img src="Table4.png"></p><h2 id="Network-Structure-and-Training"><a href="#Network-Structure-and-Training" class="headerlink" title="Network Structure and Training"></a>Network Structure and Training</h2><p>下图左边是标准卷积层，右边是 MobileNet 的卷积层。首先使用 3×3 的深度卷积提取特征，接着是一个 BN（Batch Normalization，批量标准化）层，随后是一个 ReLU（非线性激活函数，这里使用的是 <strong>ReLU6</strong>） 层，在之后就会 1x1 逐点卷积，最后就是 BN 和 ReLU 了。这也很符合深度可分离卷积，将左边的标准卷积拆分成右边的一个深度卷积加一个逐点卷积。</p><p><img src="Figure3.png"></p><p>MobileNetV1 的具体结构如下:</p><p><img src="Table1.png"></p><ul><li>Conv：标准卷积</li><li>s2：卷积步长 stride 为 2</li><li>dw：深度卷积</li><li>Avg Pool：平均池化</li><li>FC：全连接层</li><li>将深度卷积和逐点卷积看做两层，共 28 层网络</li></ul><p>MobileNet 模型结构将几乎所有的计算都放到密集的 1×1 卷积中。这可以通过高度优化的通用矩阵乘法（GEMM）函数来实现。通常卷积是由 GEMM 实现的，但需要在内存中进行初始的重新排序称为 im2col，以便将其映射到 GEMM。例如，这种方法在流行的 Caffe 包中使用。1×1 卷积不需要在内存中重新排序，可以直接用 GEMM 实现，GEMM 是最优化的数值线性代数算法之一。MobileNet 在 1 × 1 的卷积中花费了 95% 的计算时间，也占有 75% 的参数，几乎所有的附加参数都在全连接层中。</p><p><img src="Table2.png"></p><h2 id="Width-Multiplier-Thinner-Models"><a href="#Width-Multiplier-Thinner-Models" class="headerlink" title="Width Multiplier: Thinner Models"></a>Width Multiplier: Thinner Models</h2><p>虽然基本的 MobileNe t架构已经很小并且延迟很低，但是很多时候特定的用例或应用程序可能需要模型更小更快。为了构建这些更小、计算成本更低的模型，论文引入了一个非常简单的参数 α，称为<strong>宽度乘数</strong>。宽度乘数 α 的作用是在每一层均匀地细化网络。</p><p>对于给定的层和宽度乘数 α，输入通道数 M 变为 αM，输出通道数 N 变为 αN。具有宽度乘数 α 的深度可分卷积的计算量为：DK x DK x αM x DF x DF + αM x αN x DF x DF  </p><p>其中 α∈(0，1]，通常设置为 1、0.75、0.5 和 0.25</p><h2 id="Resolution-Multiplier-Reduced-Representation"><a href="#Resolution-Multiplier-Reduced-Representation" class="headerlink" title="Resolution Multiplier: Reduced Representation"></a>Resolution Multiplier: Reduced Representation</h2><p>降低神经网络计算量的第二个超参数是<strong>分辨率乘数 ρ</strong>，将此方法应用到输入图像中，每一层的内部表示都由相同的乘法器减少。在实践中，可以通过设置输入分辨率隐式地设置 ρ 值。深度可分离的卷积计算量为：DK x DK x M x ρDF x ρDF + M x N x ρDF x ρDF</p><p>其中 ρ ∈ ( 0，1]，通常设置输入分辨率为 224 , 192 , 160 和 128 </p><p>用宽度乘子 α 和分辨率乘子 ρ 来表示网络核心层的计算代价为深度可分离的卷积：DK x DK x αM x ρDF x ρDF + αM x αN x ρDF x ρDF</p><p>此时看下计算量对比：</p><p>（DK x DK x αM x ρDF x ρDF + αM x αN x ρDF x ρDF）/ （DK x DK x M x N x DF x DF）= αρ / N + (αρ / DK)^2</p><p>下面例子是标准卷积和 MobileNet 深度可分离卷积及带有超参数的模型计算量和参数量对比，其中 DK= 3, M = 512, N = 512, DF= 14。</p><p><img src="Table3.png"></p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>论文提出了一种基于深度可分离卷积的新模型 MobileNet，同时提出了两个超参数用于快速调节模型适配到特定环境，来构建更小、更快的网络。实验部分将 MobileNet 与许多先进模型做对比，展现出 MobileNet 的在尺寸、速度、准确性上的优越性。最后，论文证明了 MobileNet 在广泛应用于各种任务时的有效性。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CNN </tag>
            
            <tag> MobileNetV1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卷积神经网络中的参数量和计算量</title>
      <link href="2021/03/30/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%E9%87%8F%E5%92%8C%E8%AE%A1%E7%AE%97%E9%87%8F/"/>
      <url>2021/03/30/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%E9%87%8F%E5%92%8C%E8%AE%A1%E7%AE%97%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<p>在设计一个 CNN 时，通常要考虑两个事情，即计算量和参数量。前者决定了网络训练的快慢，后者决定了计算设备需要多大的内存或显存。</p><p>参数量指的是卷积核中的参数的数量，计算量指的是卷积神经网络执行数值运算的次数。</p><p>由于参数共享，参数量只与特征图 feature map 的数量有关，而与 feature map 的大小无关，计算量与二者都有关。</p><table><thead><tr><th>符号</th><th>解释</th></tr></thead><tbody><tr><td>M</td><td>输入通道</td></tr><tr><td>N</td><td>输出通道</td></tr><tr><td>(K,K）</td><td>卷积核</td></tr><tr><td>(Hin,Win）</td><td>输入特征图</td></tr><tr><td>(Hout,Wout)</td><td>输出特征图</td></tr></tbody></table><table><thead><tr><th>卷积类型</th><th>参数量</th><th>计算量</th><th>特点</th></tr></thead><tbody><tr><td>标准卷积</td><td>K x K x M x N</td><td>K x K x M x N x Hout x Wout</td><td>卷积核 channel = 输入特征图 channel；输出特征图 channel = 卷积核个数</td></tr><tr><td>深度可分离卷积</td><td>K x K x M + M x N</td><td>K x K x M x Hout x Wout + M x N x Hout x Wout</td><td>深度卷积卷积核 channel = 1；输入特征图 channel = 卷积核个数 = 输出特征图 channel</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CNN </tag>
            
            <tag> 参数量 </tag>
            
            <tag> 计算量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MobileNet-SSD模型的训练与tflite格式转换</title>
      <link href="2021/03/27/MobileNet-SSD%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%AE%AD%E7%BB%83%E4%B8%8Etflite%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/"/>
      <url>2021/03/27/MobileNet-SSD%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%AE%AD%E7%BB%83%E4%B8%8Etflite%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>最近在做毕业设计嵌入式端的目标检测系统，看了前人写的论文大多数用的都是 MobileNet-SSD 模型，就去学习了一下。MobileNet v1 是 Google 2017年发表的用于移动和嵌入式视觉应用程序的高效模型，其核心思想就是提出了深度可分离卷积（Depthwise Separable Convolution）来代替标准卷积，同时引入两个全局超参数（宽度和分辨率）进一步缩小模型规模来构建更小、更快的移动网络。其后 v2 v3 版本（还没学）都是在 v1 基础上引入新技术不断缩小模型。</p><p>在树莓派 4B（Raspberry Pi OS、4GB、tensorflow 1.4）直接调用 <a href="https://github.com/tensorflow/models/blob/master/research/object_detection/g3doc/tf1_detection_zoo.md">TensorFlow object detection API</a> 中的 ssd_mobilenet_v2_coco 预训练模型卡的起飞，大概只有0.8-0.9 FPS，毫无目标检测体验。想着把模型在 VOC2012 数据集上再次训练，下面是 MobileNet-SSD 模型训练过程。</p><h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><ol><li>Github 下载/克隆 <a href="https://github.com/tensorflow/models">tensorflow-models</a>，后面的操作都要在这个目录下执行，建议创建 Python 虚拟环境</li><li>下载数据集 <a href="http://host.robots.ox.ac.uk/pascal/VOC/voc2012/VOCtrainval_11-May-2012.tar">VOC2012</a>，也可以使用 <a href="https://github.com/tzutalin/labelImg">LabelImg</a> 制作数据集训练自己的数据</li><li>下载 MobileNet-SSD 预训练模型，这里我下载的是 <a href="http://download.tensorflow.org/models/object_detection/ssd_mobilenet_v1_coco_2018_01_28.tar.gz">ssd_mobilenet_v1_coco</a></li></ol><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><table><thead><tr><th>基本配置</th><th>版本</th></tr></thead><tbody><tr><td>CPU</td><td>Intel(R) Core(TM) i7-7500U CPU @ 2.70GHz   2.90 GHz</td></tr><tr><td>GPU</td><td>AMD Radeon(TM) 530 (没用)</td></tr><tr><td>RAM</td><td>12 GB</td></tr><tr><td>OS</td><td>Windows 10</td></tr><tr><td>Python</td><td>3.7.9</td></tr><tr><td>TensorFlow</td><td>1.15.5</td></tr></tbody></table><h2 id="设置-PYTHONPATH"><a href="#设置-PYTHONPATH" class="headerlink" title="设置 PYTHONPATH"></a>设置 PYTHONPATH</h2><p>需要修改 PYTHONPATH 环境变量以指向刚下载的 tensorflow-models 内的某些目录，这里我把文件重命名为 <code>models</code>。</p><table><thead><tr><th>变量名</th><th>变量值（根据自己的路径修改）</th></tr></thead><tbody><tr><td>PYTHONPATH</td><td>path\to\models;path\to\models\research\slim;</td></tr></tbody></table><p><img src="PYTHONPATH.png"></p><h2 id="安装-protobuf"><a href="#安装-protobuf" class="headerlink" title="安装 protobuf"></a>安装 protobuf</h2><p>这是一个轻便高效的序列化数据结构的协议，可以用于网络通信和数据存储的工具库（类似Json），但相比于Json，Protobuf 有更高的转化效率。Windows 下的安装很简单，只需到 github 上下载 <a href="https://github.com/protocolbuffers/protobuf/releases">protobuf</a> 对应版本压缩包安装即可，如 protoc-3.15.6-win64.zip。</p><p>现在，使用 protoc 来编译目标检测 API 使用的协议 proto 文件来产生 py 文件。proto 文件放在 <code>models\research\object_detection\protos\</code> 中，从 <code>research/</code> 目录执行命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd models/research/</span></span><br><span class="line">protoc object_detection/protos/*.proto --python_out=.</span><br></pre></td></tr></table></figure><p>这时 protos 文件夹下会生成相应的 py 文件。</p><h2 id="安装-API"><a href="#安装-API" class="headerlink" title="安装 API"></a>安装 API</h2><p>继续在<code>research/</code>目录下执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python setup.py build</span><br><span class="line">python setup.py install</span><br><span class="line">python object_detection/builders/model_builder_test.py  <span class="comment"># 测试是否安装成功</span></span><br></pre></td></tr></table></figure><h1 id="配置和训练"><a href="#配置和训练" class="headerlink" title="配置和训练"></a>配置和训练</h1><p>在<code>object_detection/</code>目录下创建目录<code>ssd_model</code>，把下载好的 VOC2012 数据集解压进去，数据集路径为 <code>models\research\object_detection\ssd_model\VOCdevkit\</code>。执行以下命令将 VOC 数据集转换成 tfrecord 格式的数据。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python ./object_detection/dataset_tools/create_pascal_tf_record.py --label_map_path=object_detection/data/pascal_label_map.pbtxt --data_dir=object_detection/ssd_model/VOCdevkit/ --year=VOC2012 --<span class="built_in">set</span>=train --output_path=object_detection/ssd_model/pascal_train.record </span><br><span class="line">python ./object_detection/dataset_tools/create_pascal_tf_record.py --label_map_path=object_detection/data/pascal_label_map.pbtxt --data_dir=object_detection/ssd_model/VOCdevkit/ --year=VOC2012 --<span class="built_in">set</span>=val --output_path=object_detection/ssd_model/pascal_val.record</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后会在<code>ssd_model/</code>目录下生成<code>pascal_train.record</code>和<code>pascal_val.record</code>两个文件，分别有650M左右。</p><p><img src="pascal_train_val.png"></p><p>复制 <code>object_detection\data\pascal_label_map.pbtxt</code> 和<code>object_detection\samples\configs\ssd_mobilenet_v1_coco.config</code>到 <code>ssd_model/</code> 目录下，接着把之前下载的<code>ssd_mobilenet_v1_coco</code>解压到<code>ssd_model/ssd_mobilenet</code>下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp object_detection/data/pascal_label_map.pbtxt object_detection/ssd_model/ </span><br><span class="line">cp object_detection/samples/configs/ssd_mobilenet_v1_coco.config object_detection/ssd_model/</span><br></pre></td></tr></table></figure><p>此时 <code>ssd_model</code> 下应有以下文件：</p><p><img src="ssd_model.png"></p><p>打开 pascal_label_map.pbtxt，这个文件里面是类似 Json 格式的 label 集，列出了数据集里有哪些<code>label</code>。Pascal VOC 这个数据集<code>label</code>共有20个。然后打开配置文件 <code>ssd_mobilenet_v1_coco.config</code>，把<code>num_classes</code>改为<code>20</code><br>配置默认训练次数<code>num_steps: 200000</code>，根据自己需要改，注意这个训练是很慢的，差不多以天为单位，所以可以适当改小点。</p><p>然后根据自己文件路径修改一些文件路径：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 预训练模型 ckpt 文件的位置</span><br><span class="line">fine_tune_checkpoint: &quot;D:/Code/Python/tfmodels/models/research/object_detection/ssd_model/ssd_mobilenet/model.ckpt&quot;</span><br><span class="line"></span><br><span class="line"># 训练数据位置以及标签文件位置</span><br><span class="line">train_input_reader: &#123;</span><br><span class="line">  tf_record_input_reader &#123;</span><br><span class="line">    input_path: &quot;D:/Code/Python/tfmodels/models/research/object_detection/ssd_model/pascal_train.record&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  label_map_path: &quot;D:/Code/Python/tfmodels/models/research/object_detection/ssd_model/pascal_label_map.pbtxt&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 测试数据位置和相应标签文件位置，shuffle表示是否随机选取测试图片</span><br><span class="line">eval_input_reader: &#123;</span><br><span class="line">  tf_record_input_reader &#123;</span><br><span class="line">    input_path: &quot;D:/Code/Python/tfmodels/models/research/object_detection/ssd_model/pascal_val.record&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  label_map_path: &quot;D:/Code/Python/tfmodels/models/research/object_detection/ssd_model/pascal_label_map.pbtxt&quot;</span><br><span class="line">  shuffle: false</span><br><span class="line">  num_readers: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>object_detection\</code> 下新建文件夹 <code>train</code> 保存训练数据。完成之后，我们就可以训练了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd models/research/</span></span><br><span class="line">python object_detection/model_main.py \</span><br><span class="line">--pipeline_config_path=object_detection/ssd_model/ssd_mobilenet_v1_coco.config \</span><br><span class="line">--model_dir=object_detection/train \</span><br><span class="line">--alsologtostderr</span><br><span class="line"><span class="comment"># pipeline_config_path 为修改后的config文件的位置</span></span><br><span class="line"><span class="comment"># train_dir 为训练产生数据的保存位置</span></span><br></pre></td></tr></table></figure><p>训练可视化可以在 tensorboard 中查看训练情况，在浏览器中打开 <a href="http://localhost:6006/">http://localhost:6006/</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensorboard --logdir=path/to/object_detection/train  <span class="comment"># 保存训练数据文件夹</span></span><br></pre></td></tr></table></figure><p><img src="tensorboard.png"></p><p>经过漫长的等待，在<code>/object_detection/train</code>目录下生成了训练好的模型。（下图未训练完）</p><p><img src="train.png"></p><p>创建文件夹<code>ssd_model/model</code>导出训练好的模型，生成 pb 文件，再把 pascal_label_map.pbtxt 的内容改成<code>txt</code>作为 labe l文件，这个模型就可以使用了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">python object_detection/export_inference_graph.py \</span><br><span class="line">--input_type image_tensor \</span><br><span class="line">--pipeline_config_path object_detection/ssd_model/ssd_mobilenet_v1_coco.config \</span><br><span class="line">--trained_checkpoint_prefix object_detection/train/model.ckpt-77 \</span><br><span class="line">--output_directory object_detection/ssd_model/model/</span><br></pre></td></tr></table></figure><h1 id="测试模型"><a href="#测试模型" class="headerlink" title="测试模型"></a>测试模型</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> six.moves.urllib <span class="keyword">as</span> urllib</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> tarfile</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"><span class="keyword">from</span> object_detection.utils <span class="keyword">import</span> label_map_util</span><br><span class="line"><span class="keyword">from</span> object_detection.utils <span class="keyword">import</span> visualization_utils <span class="keyword">as</span> vis_util</span><br><span class="line"><span class="keyword">from</span> distutils.version <span class="keyword">import</span> StrictVersion</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># This is needed since the notebook is stored in the object_detection folder.</span></span><br><span class="line">sys.path.append(<span class="string">&quot;..&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> StrictVersion(tf.__version__) &lt; StrictVersion(<span class="string">&#x27;1.9.0&#x27;</span>):</span><br><span class="line">    <span class="keyword">raise</span> ImportError(<span class="string">&#x27;Please upgrade your TensorFlow installation to v1.9.* or later!&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">CWD_PATH = os.getcwd()</span><br><span class="line">PATH_TO_CKPT = os.path.join(CWD_PATH, <span class="string">&#x27;model&#x27;</span>, <span class="string">&#x27;frozen_inference_graph.pb&#x27;</span>)</span><br><span class="line"><span class="comment"># List of the strings that is used to add correct label for each box.</span></span><br><span class="line">PATH_TO_LABELS = os.path.join(CWD_PATH, <span class="string">&#x27;pascal_label_map.pbtxt&#x27;</span>)</span><br><span class="line"></span><br><span class="line">NUM_CLASSES = <span class="number">100</span></span><br><span class="line">start = time.time()</span><br><span class="line"></span><br><span class="line">detection_graph = tf.Graph()</span><br><span class="line"><span class="keyword">with</span> detection_graph.as_default():</span><br><span class="line">    od_graph_def = tf.compat.v1.GraphDef()</span><br><span class="line">    <span class="keyword">with</span> tf.io.gfile.GFile(PATH_TO_CKPT, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> fid:</span><br><span class="line">        serialized_graph = fid.read()</span><br><span class="line">        od_graph_def.ParseFromString(serialized_graph)</span><br><span class="line">        tf.import_graph_def(od_graph_def, name=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">label_map = label_map_util.load_labelmap(PATH_TO_LABELS)</span><br><span class="line">categories = label_map_util.convert_label_map_to_categories(label_map, max_num_classes=NUM_CLASSES, use_display_name=<span class="literal">True</span>)</span><br><span class="line">category_index = label_map_util.create_category_index(categories)</span><br><span class="line"><span class="keyword">with</span> detection_graph.as_default():</span><br><span class="line">    <span class="keyword">with</span> tf.compat.v1.Session(graph=detection_graph) <span class="keyword">as</span> sess:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            ret, image_np = cap.read()</span><br><span class="line">            <span class="comment"># Expand dimensions since the model expects images to have shape: [1, None, None, 3]</span></span><br><span class="line">            image_np_expanded = np.expand_dims(image_np, axis=<span class="number">0</span>)</span><br><span class="line">            image_tensor = detection_graph.get_tensor_by_name(<span class="string">&#x27;image_tensor:0&#x27;</span>)</span><br><span class="line">            <span class="comment"># Each box represents a part of the image where a particular object was detected.</span></span><br><span class="line">            boxes = detection_graph.get_tensor_by_name(<span class="string">&#x27;detection_boxes:0&#x27;</span>)</span><br><span class="line">            <span class="comment"># Each score represent how level of confidence for each of the objects.</span></span><br><span class="line">            <span class="comment"># Score is shown on the result image, together with the class label.</span></span><br><span class="line">            scores = detection_graph.get_tensor_by_name(<span class="string">&#x27;detection_scores:0&#x27;</span>)</span><br><span class="line">            classes = detection_graph.get_tensor_by_name(<span class="string">&#x27;detection_classes:0&#x27;</span>)</span><br><span class="line">            num_detections = detection_graph.get_tensor_by_name(<span class="string">&#x27;num_detections:0&#x27;</span>)</span><br><span class="line">            <span class="comment"># Actual detection.</span></span><br><span class="line">            (boxes, scores, classes, num_detections) = sess.run(</span><br><span class="line">                [boxes, scores, classes, num_detections],</span><br><span class="line">                feed_dict=&#123;image_tensor: image_np_expanded&#125;)</span><br><span class="line">            <span class="comment"># Visualization of the results of a detection.</span></span><br><span class="line">            image = image_np</span><br><span class="line">            vis_util.visualize_boxes_and_labels_on_image_array(</span><br><span class="line">                image_np, np.squeeze(boxes),</span><br><span class="line">                np.squeeze(classes).astype(np.int32),</span><br><span class="line">                np.squeeze(scores), category_index,</span><br><span class="line">                use_normalized_coordinates=<span class="literal">True</span>,</span><br><span class="line">                line_thickness=<span class="number">2</span>)</span><br><span class="line">            final_score = np.squeeze(scores)</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> scores <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> final_score[i] &gt; <span class="number">0.5</span>:</span><br><span class="line">                    count = count + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;the count of objects is: &quot;</span>, count)</span><br><span class="line">            im_shape = image.shape</span><br><span class="line">            im_width = im_shape[<span class="number">1</span>]</span><br><span class="line">            im_height = im_shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> count != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(count):</span><br><span class="line">                    <span class="comment"># print(boxes[0][i])</span></span><br><span class="line">                    y_min = boxes[<span class="number">0</span>][i][<span class="number">0</span>] * im_height</span><br><span class="line">                    x_min = boxes[<span class="number">0</span>][i][<span class="number">1</span>] * im_width</span><br><span class="line">                    y_max = boxes[<span class="number">0</span>][i][<span class="number">2</span>] * im_height</span><br><span class="line">                    x_max = boxes[<span class="number">0</span>][i][<span class="number">3</span>] * im_width</span><br><span class="line">                    cv2.rectangle(image, (<span class="built_in">int</span>(x_min), <span class="built_in">int</span>(y_min)), (<span class="built_in">int</span>(x_max), <span class="built_in">int</span>(y_max)), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line">                    <span class="comment">#print(&quot;object&#123;0&#125;: &#123;1&#125;&quot;.format(i, category_index[classes[0][i]][&#x27;name&#x27;]), &#x27;,Center_X:&#x27;, int((x_min + x_max) / 2), &#x27;,Center_Y:&#x27;, int((y_min + y_max) / 2))</span></span><br><span class="line">            <span class="comment"># print(x_min,y_min,x_max,y_max)</span></span><br><span class="line"></span><br><span class="line">            seconds = time.time() - start</span><br><span class="line">            start = time.time()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Time taken : &#123;0&#125; seconds&quot;</span>.<span class="built_in">format</span>(seconds))</span><br><span class="line">            cv2.imshow(<span class="string">&#x27;object detection&#x27;</span>, cv2.resize(image, (<span class="number">800</span>, <span class="number">600</span>))) <span class="comment"># cv2.resize(image_np, (800,600))</span></span><br><span class="line">            <span class="keyword">if</span> cv2.waitKey(<span class="number">25</span>) &amp; <span class="number">0xFF</span> == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">                cv2.destroyAllWindows()</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">cap.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h1 id="TFLite-模型转换"><a href="#TFLite-模型转换" class="headerlink" title="TFLite 模型转换"></a>TFLite 模型转换</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p><a href="https://www.tensorflow.org/lite/guide?hl=zh-cn">TensorFlow Lite</a> 是一组工具，可帮助开发者在移动设备、嵌入式设备和 IoT 设备上运行 TensorFlow 模型。包括两个主要组件：TensorFlow Lite 解释器和 TensorFlow Lite 转换器。</p><p>解释器可以在手机、嵌入式 Linux 设备和微控制器等很多不同类型的硬件上运行经过专门优化的模型（.tflite），转换器可将 TensorFlow 模型转换为方便解释器使用的格式，并可引入优化以减小二进制文件的大小和提高性能。下面详细讲下转换过程。</p><p>TensorFlow Lite 转换器提供两种转换方法：</p><ul><li>Python API：它让您可以更轻松地在模型开发流水线中转换模型、应用优化、添加元数据，并且拥有更多功能</li><li>命令行：它仅支持基本模型转换</li></ul><p>将 SavedModel 转换为 TensorFlow Lite 模型，官方给提供了两种方式的实例代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="comment"># Convert the model</span></span><br><span class="line"><span class="comment"># TensorFlow 1.x</span></span><br><span class="line">converter = tf.compat.v1.lite.TFLiteConverter.from_saved_model(saved_model_dir) <span class="comment"># path to the SavedModel directory</span></span><br><span class="line"><span class="comment"># TensorFlow 2.x</span></span><br><span class="line"><span class="comment"># converter = tf.lite.TFLiteConverter.from_saved_model(saved_model_dir) </span></span><br><span class="line">tflite_model = converter.convert()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Save the model.</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;model.tflite&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(tflite_model)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tflite_convert \</span><br><span class="line">  --saved_model_dir=/tmp/mobilenet_saved_model \</span><br><span class="line">  --output_file=/tmp/mobilenet.tflite</span><br></pre></td></tr></table></figure><p>示例代码中的 <code>saved_model_dir</code> 和 <code>mobilenet_saved_model</code> 路径一定要写对，正确的是上面训练好的模型 <code>model/saved_model</code> ，不要只写到 <code>model</code> ，否则会报下面错误。</p><blockquote><p>OSError: SavedModel file does not exist at: object_detection/ssd_model/model/{saved_model.pbtxt|saved_model.pb}</p></blockquote><p>当你开始转换，看着终端不断输出，然后它就又会报错了。</p><blockquote><p>ValueError: None is only supported in the 1st dimension. Tensor ‘image_tensor’ has invalid shape ‘[None, None, None, 3]’.</p></blockquote><h2 id="开始转换"><a href="#开始转换" class="headerlink" title="开始转换"></a>开始转换</h2><p>从我们上面训练好的模型转换成 tflite 只需要两步：</p><ol><li><p>先把 model.ckpt 转成 pb 和 pbtxt 文件，用的是 <code>object_detection/export_tflite_ssd_graph.py</code>，可以参考 <a href="https://github.com/tensorflow/models/blob/master/research/object_detection/export_tflite_ssd_graph.py">export_tflite_ssd_graph.py</a>，下面是示例代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd models/research/</span></span><br><span class="line">python object_detection/export_tflite_ssd_graph.py \</span><br><span class="line">  --pipeline_config_path path\to\ssd_model\model\pipeline.config \</span><br><span class="line">  --trained_checkpoint_prefix path\to\ssd_model\model\model.ckpt \</span><br><span class="line">  --output_directory path\to\ssd_model\model</span><br><span class="line">  </span><br><span class="line"><span class="comment"># pipeline_config_path pipeline 配置文件位置</span></span><br><span class="line"><span class="comment"># trained_checkpoint_prefix ckpt 文件位置</span></span><br><span class="line"><span class="comment"># output_directory 导出 pb 文件位置</span></span><br></pre></td></tr></table></figure><p>此时在 <code>ssd_model\model</code> 下会生成两个文件：<code>tflite_graph.pb</code> 和 <code>tflite_graph.pbtxt</code></p></li><li><p>接下来把 pb 转为 tflite 文件，官方给的示例代码总是报错原因就在这，我们少了第一步，直接转换了 <code>saved_model.pb</code> 到 <code>tflite</code>，同时也缺少模型转换参数，下面是示例代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tflite_convert \</span><br><span class="line">  --graph_def_file=path\to\ssd_model\model\tflite_graph.pb \</span><br><span class="line">  --output_file=path\to\ssd_model\model\ssd_mobilenet.tflite \</span><br><span class="line">  --input_arrays=normalized_input_image_tensor \</span><br><span class="line">  --output_arrays=<span class="string">&#x27;TFLite_Detection_PostProcess&#x27;</span>,<span class="string">&#x27;TFLite_Detection_PostProcess:1&#x27;</span>,<span class="string">&#x27;TFLite_Detection_PostProcess:2&#x27;</span>,<span class="string">&#x27;TFLite_Detection_PostProcess:3&#x27;</span> \</span><br><span class="line">  --input_shape=1,300,300,3 \</span><br><span class="line">  --allow_custom_ops</span><br><span class="line"></span><br><span class="line"><span class="comment"># graph_def_file 第一步中 tflite_graph.pb路径</span></span><br><span class="line"><span class="comment"># output_file tflite 导出路径</span></span><br><span class="line"><span class="comment"># input_shape 1,x,x,1 根据配置文件修改</span></span><br></pre></td></tr></table></figure><p>至此我们完成了 tflite 模型转换。</p><p>可以在嵌入式、移动端部署了，下图是使用的  ssd_mobilenet_v1_coco.tflite 模型在树莓派部署效果图。推断时间大概在 400-500 ms，实时性不是很好，使用最新的 ssd_mobilenet_v3_small 速度大约提高了一倍，ssd_mobilenet_v3_large 推断时间比 v1 略高100ms，但是准确率有很大的提升，大厂的产品不得不服啊！<img src="ssd_mobilenet_v1.jpg"></p></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://wossoneri.github.io/2017/12/12/%5BTensorflow%5DTrain-model-with-SSD-MobileNet/#toc-heading-1">[Tensorflow] 使用SSD-MobileNet训练模型</a></p><p><a href="https://www.jianshu.com/p/20f7f3755ddd">MobileNet SSD V2模型的压缩与tflite格式的转换（补充版）</a></p><p><a href="https://www.tensorflow.org/lite/convert/index?hl=zh-cn">TensorFlow Lite 转换器</a></p><p><a href="https://www.jianshu.com/p/630c27cb8c55?utm_campaign=haruki">30组-MobileNets论文解读和MobileNetV2简介</a></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CNN </tag>
            
            <tag> MobileNet-SSD </tag>
            
            <tag> tensorflow lite </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习基础知识</title>
      <link href="2021/03/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>2021/03/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>人工智能的浪潮正在席卷全球。</p><p>2016年，谷歌阿尔法围棋以 4:1 战胜围棋世界冠军、职业九段棋手李世石，不仅让深度学习为人们所知，而且掀起了人工智能的“大众热”。随之也产生了一些学术名词如：人工智能（Artificial Intelligence, AI）、机器学习（Machine Learning, ML）、深度学习（Deep Learning, DL）、强化学习（Reinforcement Learning, RL）等，很多人分不清他们彼此之间的关系。</p><p><img src="AI.jpg" alt="AI 研究分支"></p><p>简单说，人工智能范围最大，涵盖机器学习、深度学习和强化学习。机器学习是一种实现人工智能的方法，深度学习和强化学习都是实现机器学习的技术。</p><p>机器学习之父 Tom Mitchell 如此定义机器学习：“每个机器学习都可以被精准地定义为：1.任务 T；2.训练过程 E；3.模型表现 P。而学习过程则可以被拆解为为了实现任务 T，我们通过训练 E，逐步提高表现 P 的一个过程“。深度学习是用于建立、模拟人脑进行分析学习的神经网络，并模仿人脑的机制来解释数据的一种机器学习技术。强化学习用于描述和解决智能体在与环境的交互过程中通过学习策略以达成回报最大化或实现特定目标的问题。</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++字符串、字符数组长度</title>
      <link href="2020/08/20/C-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6/"/>
      <url>2020/08/20/C-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p>在 C++ 中常用的获取字符串长度或者字符串数组长度的函数有：</p><ul><li>length()</li><li>size()</li><li>strlen()</li><li>sizeof()</li></ul><p>str.length() 和 str.size() 用来求字符串（<strong>string 类型</strong>）的长度。</p><p>strlen(str) 是用于求<strong>字符数组</strong>的长度，其参数是char*。当数组名作为参数传入时，实际上数组就退化成指针了。</p><p>sizeof(str) 是运算符，在头文件中 typedef 为 unsigned int，其值在编译时即计算好了，参数可以是数组、指针、类型、对象、函数等。由于在编译时计算，因此 <strong>sizeof() 不能用来返回动态分配的内存空间的大小</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;01234&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> s2[<span class="number">10</span>] = <span class="string">&quot;0123456&quot;</span>;</span><br><span class="line">cout&lt;&lt;s1.<span class="built_in">length</span>()&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;s1.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="built_in">strlen</span>(s2)&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(s2)&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(s1)&lt;&lt;endl;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 字符串长度 </tag>
            
            <tag> 字符数组长度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中sort()函数强大功能</title>
      <link href="2020/08/01/C-%E4%B8%ADsort-%E5%87%BD%E6%95%B0%E5%BC%BA%E5%A4%A7%E5%8A%9F%E8%83%BD/"/>
      <url>2020/08/01/C-%E4%B8%ADsort-%E5%87%BD%E6%95%B0%E5%BC%BA%E5%A4%A7%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p>最近在刷王道考研机试指南（机试小白），惊奇的发现 sort() 函数功能不是简单排个序。</p><p>sort()函数原型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(start,end,cmp);</span><br><span class="line"><span class="comment">// start表示要排序数组的起始地址</span></span><br><span class="line"><span class="comment">// end表示数组结束地址的下一位</span></span><br><span class="line"><span class="comment">// cmp用于规定排序的方法，可不填，默认升序</span></span><br></pre></td></tr></table></figure><p>sort() 函数包含在头文件为 <strong>#include &lt;algorithm&gt;</strong> 的 c++ 标准库中</p><p>一般我就使用两个参数的，第三个参数默认从小到大排序。例如对数组 a[n] 排序：sort(a,a+n);</p><p>sort() 函数的强大之处是在它的第三个参数排序方法，<strong>可以任意的设定自己的规则，使排序对象按照自己指定的规则进行排序</strong>。</p><p><strong>cmp 函数定义规则</strong>：当 cmp 的返回值为 true 时，即表示 cmp 函数的第一个参数将会排在第二个参数之前，反之，第一个参数将会排在第二个参数之后。</p><p><strong>例 2.2 成绩排序</strong>：有 N 个学生的数据，将学生数据按成绩高低排序，如果成绩相同则按姓名字符的字母序排序，如果姓名的字母序也相同则按照学生的年龄排序，并输出N个学生排序后的信息。</p><p>输入：测试数据有多组，每组输入第- 行有一个整数 N (N&lt;=1000) ,接下来的N行包括N个学生的数据。每个学生的数据包括姓名(长度不超过 100 的字符串)、年龄(整型数)、成绩(小于等于 100 的正数)。</p><p>输出：将学生信息按成绩进行排序，成绩相同的则按姓名的字母序进行排序。然后输出学生信息，按照如下格式：姓名 年龄 成绩</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span> <span class="comment">// 万能头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stu</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">int</span> grade;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Stu a,Stu b)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a.grade!=b.grade)</span><br><span class="line"><span class="keyword">return</span> a.grade&lt;b.grade;  <span class="comment">// 分数不一样</span></span><br><span class="line"><span class="keyword">int</span> tmp = <span class="built_in">strcmp</span>(a.name,b.name); <span class="comment">// 以下分数相同 </span></span><br><span class="line"><span class="keyword">if</span>(tmp!=<span class="number">0</span>) <span class="keyword">return</span> tmp&lt;<span class="number">0</span>;<span class="comment">// 姓名字母序不同 </span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> a.age&lt;b.age;<span class="comment">// 姓名字母序相同、年龄不同 </span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">Stu s[n];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">cin&gt;&gt;s[i].name&gt;&gt;s[i].age&gt;&gt;s[i].grade;</span><br><span class="line"><span class="built_in">sort</span>(s,s+n,cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">cout&lt;&lt;s[i].name&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;s[i].age&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;s[i].grade&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学建模之预测模型</title>
      <link href="2020/07/29/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E4%B9%8B%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%9E%8B/"/>
      <url>2020/07/29/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E4%B9%8B%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>在数学建模中，常常会涉及一些预测类问题。预测方法种类繁多，从经典的单耗法、弹性系数法、统计分析法，到现在的灰色预测法、专家系统法和模糊数学法、甚至刚刚兴起的神经元网络法、优选组合法和小波分析法等200余种算法。下面将简要介绍几类预测方法：灰色预测模型、微分方程模型、差分方程模型、马尔可夫预测、插值与拟合、时间序列预测、神经元网络。</p><table><thead><tr><th>模型名称</th><th>模型简介</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>灰色预测模型</td><td>该模型使用的不是原始数据的序列，而是生成的数据序列。核心体系是Grey Model，即对原始数据作累加生成（或其他处理生成）得到近似的指数规律再进行建模的方法。</td><td>在处理较少的特征值数据，不需要数据的样本空间足够大，就能解决历史数据少、序列的完整性以及可靠性低的问题，能将无规律的原始数据进行生成得到规律较强的生成序列。</td><td>只适用于中短期的预测，只适合近似于指数增长的预测</td></tr><tr><td>微分方程模型</td><td>因果预测模型，大多为物理、几何方面的典型问题，其基本规律随着时间的增长呈指数增长，根据变量个数确定微分方程模型。</td><td>适用于短、中、长期的预测，既能反映内部规律以及事物的内在关系，也能够分析两个因素之间的相关关系，精度高便与改进。如传染病的预测模型、经济增长（或人口）的预测模型、Lanchester 战争预测模型。</td><td>由于反映的内部规律，方程建立与局部规律的独立性为假定基础，长期预测的偏差性较大，且微分方程的解比较难以得到。</td></tr><tr><td>差分方程模型</td><td>利用差分方程建模研究实际问题，常常需要根据统计数据用最小二乘法来拟合出差分方程的系数。</td><td>差分方程代替微分方程描述，在方程中避免了导函数，可以用迭代的方式求解。适用于商品销售量的预测、投资保险收益率的预测。</td><td>精度较低（用割线代替切线）</td></tr><tr><td>马尔可夫预测</td><td>某一系统在已知情况下，系统未来时刻的情况只与现在时刻有关，与历史数据无关的情况。</td><td>对过程的状态预测效果良好，可考虑用于生产现场危险状态的预测。研究一个商店的未来某一时刻的销售额，当现在时刻的累计销售额已知。</td><td>不适宜用于系统中长期预测</td></tr><tr><td>插值与拟合</td><td>适用于物体轨迹图像的模型。例如，导弹的运动轨迹测量的预测分析。</td><td>分为曲面拟合和曲线拟合，拟合就是要找出一种方法（函数）使得得到的仿真曲线（曲面）最大程度的接近原来的曲线（曲线），甚至重合。这个拟合的好坏程度可以用一个指标来判断。</td><td></td></tr><tr><td>时间序列预测</td><td>根据客观事物发展的这种连续规律性，运用过去的历史数据，通过统计分析，进一步推测市场未来的发展趋势。时间序列在时间序列分析预测法处于核心位置</td><td>一般用ARMA模型拟合时间序列，预测该时间序列未来值。Daniel 检验平稳性。自动回归 AR(Auto regressive)和移动平均 MA(Moving Average)预测模型。</td><td>经济类问题，从长期看具有一定的规律，而短期可能受到宏观调控、市场现时期的需求供应变化使得预测困难。</td></tr><tr><td>神经元网络</td><td>在控制与优化、预测与管理、模式识别与图像处理、通信等方面有十分广泛的应用。常用的是 BP 神经网络和径向基函数神经网络。</td><td>多层前向 BP 网络适用于求解内部机制复杂的问题，有一定的推广、概括能力。预测某水库的年径流量和因子特征值</td><td>多层前向BP网络学习速度较慢，训练失败的可能性较大。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 预测模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理</title>
      <link href="2020/07/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
      <url>2020/07/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机系统概论"><a href="#计算机系统概论" class="headerlink" title="计算机系统概论"></a>计算机系统概论</h1><p>计算机的基本组成：</p><ul><li>存储器——存放程序(指令)和数据</li><li>运算器——算术和逻辑运算</li><li>控制器——从内存中取出解题步骤加以分析，然后执行某种操作</li><li>输入输出设备——实现计算程序和原始数据的输入输出</li></ul><p><img src="Basic-composition.png" alt="计算机的基本组成"></p><h1 id="运算方法和运算器"><a href="#运算方法和运算器" class="headerlink" title="运算方法和运算器"></a>运算方法和运算器</h1><ol><li><p>原码</p><p>原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值。</p><p>[+1]原 = 0000 0001</p><p>[-1]原 = 1000 0001</p></li><li><p>反码</p><p>正数的反码是其本身；负数的反码是在其原码的基础上, 符号位不变，其余各个位取反。</p><p>[+1] = [00000001]原 = [00000001]反</p><p>[-1] = [10000001]原 = [11111110]反</p></li><li><p>补码</p><p>正数的补码就是其本身；负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1(即在反码的基础上+1)</p><p>[+1] = [00000001]原 = [00000001]反 = [00000001]补</p><p>[-1] = [10000001]原 = [11111110]反 = [11111111]补</p></li></ol><h1 id="多层次的存储器"><a href="#多层次的存储器" class="headerlink" title="多层次的存储器"></a>多层次的存储器</h1><p>多级存储器体系结构：高速缓冲存储器、主存储器和外存储器</p><p><img src="Hierarchical-structure.png" alt="存储器的分级结构"></p><p><strong>Cache</strong> 是一种高速缓冲存储器，缓存地址(虚拟地址或者物理地址)和数据，解决CPU和主存之间速度不匹配。</p><p>三种<strong>地址映象</strong>：</p><ul><li>全相联方式——Cache 利用率高，块冲突率低。地址变换复杂，需要较多的硬件（适用于小容量的Cache）</li><li>直接相连——地址变换速度快。Cache 利用率低，块冲突率高（适用于大容量的Cache）</li><li>组相联——折中方式</li></ul><h1 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h1><p>指令系统：又称指令集（Instruction Set）是计算机体系结构设计的核心，是计算机软、硬件接口，是用机器语言、汇编语言编写程序的用户所能看到的计算机的基本属性（CISC 和 RISC）</p><p>指令的一般<strong>结构形式</strong>：操作码字段 | 地址码字段</p><ul><li>操作码字段：表示指令的操作特性与功能</li><li>地址码字段：通常用于指定参与操作的操作数地址</li></ul><p>操作数<strong>寻址方式</strong></p><ol><li>隐含寻址</li><li>立即寻址</li><li>直接寻址</li><li>间接寻址</li><li>寄存器寻址和寄存器间接寻址</li><li>偏移寻址（相对寻址、基址寻址、变址寻址）</li><li>段寻址方式</li><li>堆栈寻址方式</li></ol><h1 id="中央处理器"><a href="#中央处理器" class="headerlink" title="中央处理器"></a>中央处理器</h1><p><strong>五级流水CPU</strong>：将计算机指令处理过程拆分为多个步骤，并通过多个硬件处理单元并行执行来加快指令执行速度。</p><ol><li>取指令（IF）</li><li>指令译码（ID）</li><li>执行运算（EX）</li><li>数据内存访问（MEM）</li><li>结果写回（WB）</li></ol><p><strong>相关冲突</strong>：资源相关、数据相关、控制相关</p><p><strong>多核 CPU</strong> 是一枚处理器中集成多个完整的计算引擎(内核)。多核 cpu 和单核 cpu 对于进程来说都是并发，并不是并行。但多核 cpu 每一个核心都可以独立执行一个线程，所以多核 cpu 可以真正实现多线程的并行。</p><p><strong>乱序执行</strong>是指CPU采用了将多条指令不按程序规定的顺序分发给各相应电路单元处理的技术。</p><p><strong>多发射</strong>是一个时钟周期内，从存储器内取出多条指令。</p><p><strong>超标量</strong>是每个时钟周期内能启动多条指令。</p><h1 id="总线系统"><a href="#总线系统" class="headerlink" title="总线系统"></a>总线系统</h1><ol><li>内部总线——CPU 内部连接各寄存器及运算部件之间的总线</li><li>系统总线——CPU 同计算机系统的其他高速功能部件(存储器、通道等)间互相连接的总线</li><li>I/O总线——中、低速 I/0 设备间互相连接的总线</li></ol><p>按照信号类型可分为数据总线、控制总线和地址总线。数据线和地址线常采用多路复用方式。</p><p><strong>仲裁方式</strong>分为集中式仲裁和分布式仲裁</p><ul><li>集中式仲裁<ol><li>链式查询方式</li><li>计数器定时查询方式</li><li>独立请求方式</li></ol></li><li>分布式仲裁</li></ul><h1 id="输入输出系统"><a href="#输入输出系统" class="headerlink" title="输入输出系统"></a>输入输出系统</h1><p>信息交换方式：</p><ul><li>程序查询方式</li><li>程序中断方式</li><li>直接内存访问（DMA）方式</li><li>通道方式</li></ul><p><strong>中断</strong>是指计算机在执行程序过程中，当出现异常或特殊请求时，计算机停止现行程序的运行，转去处理这些异常或特殊请求，处理结束后，再返回现行程序的间断处，继续执行原程序。</p><p>中断服务程序的基本流程：</p><ol><li>保护现场</li><li>中断服务</li><li>恢复现场</li><li>中断返回</li></ol>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="2020/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>2020/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>从互联网的工作方式上看，可以划分为两大块：边缘部分和核心部分</p><p>电路交换分为三个阶段：建立连接、通信、释放连接</p><p>分组交换的主要特点：</p><ul><li>采用存储转发技术</li><li>在发送端，先把较长的报文划分成较短的、固定长度的数据段</li><li>一个数据段前面添加上首部构成分组</li></ul><p>报文交换：基于存储转发原理</p><p><img src="Three-exchanges.png" alt="三种交换的比较"></p><p>计算机网络的性能指标：</p><ul><li>速率</li><li>带宽</li><li>吞吐量</li><li>时延</li><li>时延带宽积</li><li>往返时间 RTT</li><li>利用率</li></ul><p>网络协议三要素：</p><ul><li>语法</li><li>语义</li><li>同步</li></ul><p><img src="Five-layer-agreement.png" alt="计算机网络体系结构"></p><ul><li>应用层：交互的数据单元为报文，任务是通过应用进程间的交互来完成特定网络应用（包含会话层、表示层，应用层）</li><li>运输层：负责向两台主机进程之间的通信提供通用的数据传输服务，主要使用 TCP 和 UDP 协议</li><li>网络层：负责为分组交换网上的不同主机提供通信服务，使用 IP 协议，IP 数据报</li><li>数据链路层：将网络层交下的 IP 数据报封装成帧，在两个相邻结点间的链路上传送帧</li><li>物理层：连接各种计算机的传输媒体上传输数据比特流</li></ul><p><strong>计算机网络要采用分层结构：</strong></p><ol><li>各层之间相互独立：高层是不需要知道底层的功能是采取何种硬件技术实现的，它只需要知道通过与底层的接口就可以获得所需要的服务；</li><li>灵活性好：各层都可以采用最适当的技术来实现，例如某一层的实现技术发生了变化，只要这一层的功能与接口保持不变，实现技术的变化都并不会对其他各层以及整个系统的工作产生影响； </li><li>易于实现和标准化：采取了规范的层次结构去组织网络功能与协议，可以将计算机网络复杂的通信过程划分为有序的连续动作与有序的交互过程，有利于将网络复杂的通信工作过程化解为一系列可以控制和实现的功能模块，使得复杂的计算机网络系统变得易于设计，实现和标准化；</li></ol><h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>物理层考虑的是怎样才能在连接各种计算机的传输媒体上<em>传输数据比特流</em>，而不是指具体的<em>传输媒体</em>，尽可能地屏蔽掉不同传输媒体和通信手段的差异。</p><ul><li>机械特性</li><li>电气特性</li><li>功能特性</li><li>过程特性</li></ul><h2 id="数据通信的基础知识"><a href="#数据通信的基础知识" class="headerlink" title="数据通信的基础知识"></a>数据通信的基础知识</h2><p>一个数据通信系统包括三大部分：源系统（或发送端、发送方）、传输系统（或传输网络）和目的系统（或接收端、接收方）</p><p>单向通信（单工）——只能有一个方向的通信而没有反方向的交互<br>双向交替通信（半双工）——通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)<br>双向同时通信（全双工）——通信的双方可以同时发送和接收信息</p><p>基带信号（即基本频带信号）—— 来自信源的信号</p><p>调制分为两大类：</p><ul><li>基带调制——仅对基带信号的波形进行变换，使它能够与信道特性相适应<br>变换后的信号仍然是基带信号。把这种过程称为编码 (coding)</li><li>带通调制——使用载波进行调制，把基带信号的频率范围搬移到较高的频段，并转换为模拟信号<br>经过载波调制后的信号称为<em>带通信号</em> </li></ul><p>常用编码方式</p><ul><li>不归零制：正电平代表 1，负电平代表 0</li><li>归零制：正脉冲代表 1，负脉冲代表 0</li><li>曼彻斯特编码：位周期中心的向上跳变代表 0，位周期中心的向下跳变代表 1。也可反过来定义</li><li>差分曼彻斯特编码：在每一位的中心处始终都有跳变。位开始边界有跳变代表 0，而位开始边界没有跳变代表 1<img src="Encoding.png" alt="数字信号常用的编码方式"></li></ul><p>限制码元在信道上的传输速率的因素有两个：</p><ul><li>信道能够通过的频率范围<br>在任何信道中，码元传输的速率是有上限的，否则就会出现码间串扰的问题，使接收端对码元的判决（即识别）成为不可能。</li><li>信噪比<br>信噪比就是信号的平均功率和噪声的平均功率之比。常记为 S/N，并用分贝 (dB) 作为度量单位。即：信噪比(dB) = 10 log10(S/N)    (dB)<br>信道的极限信息传输速率 C 可表达为：C = W log2(1+S/N)    (bit/s)<br>其中：W 为信道的带宽（以 Hz 为单位）；S 为信道内所传信号的平均功率；N 为信道内部的高斯噪声功率。  </li></ul><p><strong>香农公式</strong>表明：信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高；只要信息传输速率低于信道的极限信息传输速率，就一定可以找到某种办法来实现无差错的传输。 </p><h2 id="物理层下面的传输媒体"><a href="#物理层下面的传输媒体" class="headerlink" title="物理层下面的传输媒体"></a>物理层下面的传输媒体</h2><p>导引型传输媒体：</p><ol><li>双绞线</li><li>同轴电缆</li><li>光缆</li></ol><p>非导引型传输媒体——自由空间</p><h2 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h2><p>信道复用技术——使用一个共享信道进行通信</p><p><strong>1.频分复用</strong></p><p>频分复用的所有用户在同样的时间占用不同的带宽资源<img src="FDM.png" alt="频分复用"></p><p><strong>2.时分复用</strong></p><p>时分复用的所有用户在不同的时间占用同样的频带宽度<img src="TDM.png" alt="时分复用"></p><p><img src="TDM1.png"></p><p><strong>3.统计时分复用</strong> </p><p>统计时分复用是一种改良的时分复用<img src="STDM.png" alt="统计时分复用"></p><p><strong>4.波分复用</strong></p><p>波分复用就是光的频分复用。使用一根光纤来同时传输多个光载波信号。</p><p><strong>5.码分复用</strong></p><p>每一个比特时间划分为 m 个短的间隔，称为<em>码片</em></p><p>每个站被指派一个唯一的 m bit 码片序列：</p><ul><li>如发送比特 1，则发送自己的 m bit 码片序列</li><li>如发送比特 0，则发送该码片序列的二进制反码</li></ul><p>每个站分配的码片序列不仅必须各不相同，并且还必须<em>互相正交</em> <img src="Normalized-inner-product.png"></p><p><img src="CDMA.png" alt="CDMA 的工作原理 "></p><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><h2 id="点对点信道的数据链路层"><a href="#点对点信道的数据链路层" class="headerlink" title="点对点信道的数据链路层"></a>点对点信道的数据链路层</h2><h3 id="数据链路和帧"><a href="#数据链路和帧" class="headerlink" title="数据链路和帧"></a>数据链路和帧</h3><p>链路 (link) 是一条无源的点到点的物理线路段，中间没有任何其他的交换结点。</p><p>数据链路 (data link) 除了物理线路外，还必须有通信协议来控制这些数据的传输。</p><p>数据链路层传送的是——<strong>帧</strong></p><h3 id="三个基本问题"><a href="#三个基本问题" class="headerlink" title="三个基本问题"></a>三个基本问题</h3><p>封装成帧、透明传输、差错检测</p><p><strong>1.封装成帧</strong></p><p>在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。确定帧的界限（帧定界）<img src="Encapsulation.png" alt="用帧首部和帧尾部封装成帧"></p><p>控制字符 SOH (Start Of Header) 表示帧的首部开始；</p><p>控制字符 EOT (End Of Transmission) 表示帧的结束；</p><p><strong>2.透明传输</strong></p><p>无论什么样的比特组合数据，都能放在帧中传输过去。</p><p>如果数据中的某个字节的二进制代码恰好和 SOH 或 EOT 一样，数据链路层就会错误地“找到帧的边界”。</p><p>解决方法：字节填充或字符填充——插入一个转义字符 “ESC” <img src="Byte-padding.png" alt="用字节填充法解决透明传输的问题"></p><p><strong>3.差错检测</strong></p><p>在传输过程中可能会产生比特差错：1 可能会变成 0 而 0 也可能变成 1。在一段时间内，传输错误的比特占所传输比特总数的比率称为误码率 BER。</p><p><code>循环冗余检验 CRC</code> </p><ol><li>假设待传送的一组数据 M = 101001（现在 k = 6）</li><li>用二进制的模 2 运算进行 2^n 乘 M 的运算，这相当于在 M 后面添加 n 个 0</li><li>得到的 (k + n) 位的数除以事先选定好的长度为 (n + 1) 位的除数 P，得出商是 Q 而余数是 R，余数 R 比除数 P 少 1 位，即 R 是 n 位</li><li>将余数 R 作为冗余码拼接在数据 M 后面发送出去<img src="CRC.png" alt="循环冗余检验例子"></li></ol><p>无差错接受是指：凡是接受的帧（即不包括丢弃的帧），我们都能以非常接近于 1 的概率认为这些帧在传输过程中没有产生差错。</p><h2 id="点对点协议-PPP"><a href="#点对点协议-PPP" class="headerlink" title="点对点协议 PPP"></a>点对点协议 PPP</h2><p>PPP 帧的首部和尾部分别为 4 个字段和 2 个字段；标志字段 F = 0x7E；</p><p>PPP 是面向字节的，所有的 PPP 帧的长度都是整数字节<img src="PPP.png" alt="PPP 帧格式"></p><p>透明传输问题——字节填充和零比特填充 </p><h2 id="广播信道的数据链路层"><a href="#广播信道的数据链路层" class="headerlink" title="广播信道的数据链路层"></a>广播信道的数据链路层</h2><h3 id="CSMA-CD-协议"><a href="#CSMA-CD-协议" class="headerlink" title="CSMA/CD 协议"></a>CSMA/CD 协议</h3><p>CSMA/CD 含义：载波监听多点接入 / 碰撞检测 </p><ul><li>“多点接入”表示许多计算机以多点接入的方式连接在一根总线上</li><li>“载波监听”是指每一个站在发送数据之前，用电子技术检测总线上有没有其他计算机发送的数据信号，如果有，则暂时不要发送数据，以免发生碰撞。 </li><li>“碰撞检测”就是计算机边发送数据边检测信道上的信号电压大小。每一个正在发送数据的站，一旦发现总线上出现了碰撞，就要立即停止发送，然后等待一段随机时间后再次发送。<img src="CSMACD.png"></li></ul><p>使用 CSMA/CD 协议的以太网不能进行全双工通信而只能进行<strong>双向交替通信</strong>（半双工通信）</p><p><img src="Contention-period.png" alt="争用期"></p><p>二进制指数类型退避算法：</p><ol><li>基本退避时间取为争用期 51.2 us（最短帧长64 B = 512 bit）</li><li>从整数集合[0,1,…, (2^k - 1)]中随机地取出一个数，记为 r。重传所需的时延就是 r 倍的基本退避时间，其中 k = Min[重传次数, 10]</li><li>当 k &lt;= 10 时，参数 k 等于重传次数，当重传达 16 次仍不能成功时即丢弃该帧，并向高层报告</li></ol><p>强化碰撞——当发送数据的站一旦发现发生了碰撞时：</p><ul><li>立即停止发送数据</li><li>继续发送若干比特的人为干扰信号，以便让所有用户都知道现在已经发生了碰撞。  </li></ul><p><strong>CSMA/CD 协议的要点</strong></p><ol><li>准备发送。在发送之前，必须先检测信道</li><li>检测信道。若检测到信道忙，则应不停地检测，一直等待信道转为空闲。若检测到信道空闲，并在 96 比特时间（帧间最小间隔）内信道保持空闲，就发送这个帧</li><li>检查碰撞。在发送过程中仍不停地检测信道，即网络适配器要边发送边监听。这里只有两种可能性：<ul><li>发送成功：在争用期内一直未检测到碰撞。这个帧肯定能够发送成功。发送完毕后，其他什么也不做。然后回到 1</li><li>发送失败：在争用期内检测到碰撞。这时立即停止发送数据，并按规定发送人为干扰信号。适配器接着就执行指数退避算法，等待 r 倍 512 比特时间后，返回到步骤 2，继续检测信道。但若重传达 16 次仍不能成功，则停止重传而向上报错</li></ul></li></ol><h3 id="使用集线器的星形拓扑"><a href="#使用集线器的星形拓扑" class="headerlink" title="使用集线器的星形拓扑"></a>使用集线器的星形拓扑</h3><p>集线器的一些特点：</p><ul><li>使用集线器的以太网在逻辑上仍是一个总线网，各工作站使用的还是 CSMA/CD 协议，并共享逻辑上的总线</li><li>集线器很像一个多接口的转发器，工作在<em>物理层</em></li></ul><h3 id="以太网的-MAC-层"><a href="#以太网的-MAC-层" class="headerlink" title="以太网的 MAC 层"></a>以太网的 MAC 层</h3><p>硬件地址又称为物理地址或 MAC 地址。类型字段用来标志上一层使用的是什么协议。</p><p><strong>MAC 帧的格式</strong> <img src="MAC.png" alt="以太网 V 2的 MAC 帧格式"></p><p>无效的 MAC 帧:</p><ul><li>帧的长度不是整数个字节</li><li>用收到的帧检验序列 FCS 查出有差错</li><li>数据字段的长度不在 46 ~ 1500 字节之间</li><li>有效的 MAC 帧长度为 64 ~ 1518 字节之间</li></ul><h2 id="扩展的以太网"><a href="#扩展的以太网" class="headerlink" title="扩展的以太网"></a>扩展的以太网</h2><p><strong>1.网桥</strong></p><ul><li>它根据 MAC 帧的目的地址对收到的帧进行转发和过滤 </li><li>工作在数据链路层</li><li>当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的 MAC 地址，然后再确定将该帧转发到哪一个接口，或把它丢弃</li></ul><p><strong>2.交换机</strong></p><ul><li>以太网交换机实质上就是一个多接口的网桥</li><li>根据 MAC 地址转发，有<em>存储转发</em> 方式和<em>直通</em> 方式</li><li>全双工方式工作在数据链路层</li><li>以太网交换机具有并行性，用户独享带宽</li><li><em>自学习功能</em></li></ul><p><strong>3.集线器</strong></p><ul><li>多个端口的转发器</li><li>半双工方式工作在物理层</li><li>工作原理广播形式</li><li>用户共享带宽</li></ul><p><strong>虚拟局域网</strong>——VLAN 是由一些局域网网段构成的与物理位置无关的逻辑组<img src="VLAN.png" alt="三个虚拟局域网"></p><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="网际协议-IP"><a href="#网际协议-IP" class="headerlink" title="网际协议 IP"></a>网际协议 IP</h2><p>网际协议 IP 是 TCP/IP 体系中两个最主要的协议之一</p><p>与 IP 协议配套使用的还有三个协议：</p><ul><li>地址解析协议 ARP</li><li>网际控制报文协议 ICMP</li><li>网际组管理协议 IGMP</li></ul><h3 id="分类的-IP-地址"><a href="#分类的-IP-地址" class="headerlink" title="分类的 IP 地址"></a>分类的 IP 地址</h3><p><img src="IP.png" alt="IP地址结构"></p><p><img src="IP-classification.png" alt="各类 IP 地址"></p><h3 id="IP-地址与硬件地址"><a href="#IP-地址与硬件地址" class="headerlink" title="IP 地址与硬件地址"></a>IP 地址与硬件地址</h3><ul><li>硬件地址是数据链路层和物理层使用的地址</li><li>IP 地址是网络层和以上各层使用的地址，是一种逻辑地址（IP 地址是用软件实现的）</li></ul><p>地址解析协议 ARP ——从网络层使用的 IP 地址，解析出在数据链路层使用的硬件地址</p><p>一个 IP 数据报由首部和数据两部分组成，首部的前一部分是固定长度，共 20 字节。</p><p><img src="IP-composition.png" alt="IP数据报组成"></p><h2 id="划分子网和构造超网"><a href="#划分子网和构造超网" class="headerlink" title="划分子网和构造超网"></a>划分子网和构造超网</h2><p>子网掩码——将 IP 地址的主机号进行子网划分。把子网掩码和 IP 地址进行逐位的与运算，就立即得出网络地址。</p><p><img src="Subnetting.png" alt="划分子网"></p><p><strong>CIDR</strong> 使用“斜线记法”，它又称为 CIDR 记法，即在 IP 地址面加上一个斜线“/”，然后写上网络前缀所占的位数。例如： 220.78.168.0 / 24</p><h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><ul><li>为了更有效地转发 IP 数据报和提高交付成功的机会，在网际层使用了网际控制报文协议 ICMP</li><li>ICMP 不是高层协议，而是 IP 层的协议</li></ul><p>ICMP 差错报告报文共有 4 种 </p><ol><li>终点不可达 </li><li>时间超过 </li><li>参数问题 </li><li>改变路由（重定向）</li></ol><h2 id="互联网的路由选择协议"><a href="#互联网的路由选择协议" class="headerlink" title="互联网的路由选择协议"></a>互联网的路由选择协议</h2><ul><li>内部网关协议 IGP</li><li>外部网关协议 EGP</li></ul><ol><li><p>内部网关协议 RIP</p><p>协议 RIP 是一种分布式的、基于距离向量的路由选择协议。实现简单，开销较小。</p><p>RIP协议特点：好消息传播得快，坏消息传播得慢</p><ul><li>仅和相邻路由器交换信息</li><li>交换的信息是当前本路由器所知道的全部信息 </li><li>按固定的时间间隔交换路由信息</li></ul></li><li><p>内部网关协议 OSPF</p><p>OSPF 最主要的特征就是使用分布式的链路状态协议</p><ul><li>向本自治系统中所有路由器发送信息（洪泛法）</li><li>发送的信息就是与本路由器相邻的所有路由器的链路状态</li><li>只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息</li></ul></li><li><p>外部网关协议 BGP</p><p>BGP 只能是力求寻找一条能够到达目的网络且比较好的路由（不能兜圈子），而并非要寻找一条最佳路由。  </p></li></ol><h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h1><p> 运输层向它上面的应用曾提供通信服务。通信的真正的端点并不是主机而是主机中的进程。</p><p>运输层的两个主要协议：用户数据报协议 <strong>UDP</strong> 和 传输控制协议 <strong>TCP</strong> </p><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><ul><li>UDP 是无连接的</li><li>UDP 使用尽最大努力交付</li><li>UDP 是面向报文的（UDP 一次交付一个完整的报文）</li><li>UDP 没有拥塞控制</li><li>UDP 支持一对一、一对多、多对一和多对多的交互通信</li><li>UDP 的首部开销小（只有 8 个字节）</li></ul><p><img src="UDP.png" alt="UDP 的首部格式 "></p><p>虽然在 UDP 之间的通信要用到其端口号，但由于 UDP 的通信是无连接的，因此不需要使用套接字。</p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><ul><li>TCP 是面向连接的运输层协议</li><li>每一条 TCP连接只能是点对点的</li><li>TCP 提供可靠的交付服务</li><li>TCP 提供全双工通信</li><li>面向字节流</li></ul><p><img src="TCP.png" alt="TCP 的首部格式 "></p><ul><li>端口是运输层与应用层的服务接口，运输层的复用和分用功能都要通过端口才能实现</li><li>序号字段的值则指的是本报文段所<em>发送</em> 的数据的第一个字节的序号</li><li>确认号字段是期望<em>收到</em> 对方的下一个报文段的数据的第一个字节的序号</li><li>数据偏移指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远</li><li>保留字段保留为今后使用，但目前应置为 0</li><li>紧急 URG = 1 时，表明紧急指针字段有效</li><li>确认 ACK = 1 时，确认号字段才有效</li><li>推送 PSH = 1 时，尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付</li><li>复位 RST = 1 时，TCP 连接中出现严重差错，必须释放连接，然后再重新建立运输连接</li><li>同步 SYN = 1 时，这是一个连接请求或连接接受报文</li><li>终止 FIN = 1 时，此报文段的发送端的数据已发送完毕，并要求释放运输连接</li><li>窗口字段用来让对方设置发送窗口</li><li>检验和字段检验的范围包括首部和数据这两部分</li><li>紧急指针字段指出在本报文段中紧急数据共有多少个字节</li><li>选项字段：最大报文段长度 MSS、窗口扩大选项、时间戳选项、选择确认选项</li><li>填充字段使整个首部长度是 4 字节的整数倍</li></ul><h2 id="TCP-的流量控制"><a href="#TCP-的流量控制" class="headerlink" title="TCP 的流量控制"></a>TCP 的流量控制</h2><p>流量控制就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。</p><p>发送方的发送窗口不能超过接收方给出的接收窗口的数值。TCP 的窗口单位是字节，不是报文段。</p><h2 id="TCP-的拥塞控制"><a href="#TCP-的拥塞控制" class="headerlink" title="TCP 的拥塞控制"></a>TCP 的拥塞控制</h2><p>拥塞——在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏</p><ul><li>慢开始（cwnd &lt; ssthresh、超时 ）</li><li>拥塞避免（cwnd &gt; ssthresh ）</li><li>快重传（3-ACK）</li><li>快恢复（3-ACK）</li></ul><p><img src="Congestion-control.png" alt="TCP 的拥塞控制"></p><h2 id="TCP-的运输连接管理"><a href="#TCP-的运输连接管理" class="headerlink" title="TCP 的运输连接管理"></a>TCP 的运输连接管理</h2><p>TCP 是面向连接的协议。运输连接有三个阶段：连接建立、数据传送、连接释放</p><p>TCP 连接建立过程中要解决的三个问题</p><ul><li>要使每一方能够确知对方的存在</li><li>要允许双方协商一些参数（如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等）</li><li>能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配</li></ul><p><strong>TCP 的连接建立</strong></p><p>握手需要在客户和服务器之间交换三个 TCP 报文段，称之为三报文握手。</p><p>三报文握手主要是为了防止已失效的连接请求报文段突然又传送到了，因而产生错误。</p><p><img src="TCP-connection-establishment.png" alt="三报文握手"></p><ol><li>A 向 B 发出连接请求报文段，其首部中的同步位 SYN = 1，并选择序号 seq = x</li><li>B 的 TCP 收到连接请求报文段后，如同意，B 在确认报文段中应使 SYN = 1，使 ACK = 1，其确认号 ack = x + 1，自己选择的序号 seq = y</li><li>A 收到此报文段后向 B 给出确认，其 ACK = 1，确认号 ack = y + 1</li></ol><p><strong>TCP 的连接释放</strong></p><p><img src="TCP-connection-release.png" alt="TCP 的连接释放"></p><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><p>应用层就是规定应用进程在通信时所遵循的协议。应用层的许多协议都是基于客户服务器方式。客户(client)和服务器(server)都是指通信中所涉及的两个应用进程。</p><h2 id="域名系统-DNS"><a href="#域名系统-DNS" class="headerlink" title="域名系统 DNS"></a>域名系统 DNS</h2><ul><li>主机向本地域名服务器的查询一般都是采用递归查询</li><li>本地域名服务器向根域名服务器的查询通常是采用迭代查询</li></ul>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="2020/06/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>2020/06/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h1><h2 id="操作系统的定义"><a href="#操作系统的定义" class="headerlink" title="操作系统的定义"></a>操作系统的定义</h2><p>操作系统（OS ）是管理计算机硬件与软件资源的计算机程序。</p><h2 id="操作系统的功能"><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a>操作系统的功能</h2><ol><li>进程管理——进程线程的状态、控制、同步互斥、通信调度等</li><li>内存管理——分配/回收、地址转换、存储保护等</li><li>设备管理——设备驱动、分配回收、缓冲技术等</li><li>文件管理——文件目录、文件操作、磁盘空间、文件存取控制</li></ol><h2 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h2><ol><li><strong>并发性</strong><br>并发性是两个或多个事件在同一时间间隔内发生的、同时处于活动状态的特性。</li><li><strong>共享性</strong><br>主要是指资源共享。内存中并发执行的多个程序可以共享计算机的硬件和软件资源。</li><li><strong>虚拟性</strong><br>虚拟性是指将一个物理实体映射为一个或多个逻辑对象。</li><li><strong>随机性</strong><br>随机性也叫异步性，指的是每道程序在何时执行、各个程序执行的顺序以及每道程序所需的时间都是不确定的，也是不可预知的。</li></ol><h2 id="操作系统的分类"><a href="#操作系统的分类" class="headerlink" title="操作系统的分类"></a>操作系统的分类</h2><ol><li>批处理操作系统</li><li>分时操作系统</li><li>实时操作系统</li><li>嵌入式操作系统</li><li>个人操作系统</li><li>网络操作系统</li><li>分布式操作系统</li></ol><h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><p>进程就是正在运行的程序及其占用的系统资源，是系统进行资源分配、保护和调度的基本单位。</p><h2 id="程序的执行"><a href="#程序的执行" class="headerlink" title="程序的执行"></a>程序的执行</h2><p><strong>程序的顺序执行</strong></p><p>一个具有独立功能的程序独占处理器直至最终结束的过程称为程序的顺序执行。</p><p>顺序执行有如下三个特点：</p><ul><li>顺序性</li><li>封闭性</li><li>可在现性</li></ul><p><strong>程序的并发执行与并行执行</strong></p><p>并行是指多个事件在同一时刻发生，而并发是指多个事件在同一时期内发生。</p><p>并行是并发的特例，程序并行执行的硬件前提是系统中有多个 CPU。</p><p>并发的本质是一个 CPU 在多个程序运行过程中的时分复用。</p><p>并发执行的特性有以下三点：</p><ul><li>间断性</li><li>开放/交互性</li><li>不可再现性</li></ul><h2 id="进程的特征与控制"><a href="#进程的特征与控制" class="headerlink" title="进程的特征与控制"></a>进程的特征与控制</h2><p>进程有以下特性：</p><ul><li>结构性</li><li>动态性</li><li>独立性</li><li>并发性</li></ul><p>进程通常分为两类：系统进程和用户进程</p><p><code>进程上下文</code>：进程的生命周期中，进程实体和支持进程运行的环境</p><h3 id="进程状态及转换"><a href="#进程状态及转换" class="headerlink" title="进程状态及转换"></a>进程状态及转换</h3><p><img src="Process-tristate.png" alt="进程三态模型"></p><p><strong>就绪状态</strong>——进程在内存中已经具备执行的条件，等待分配 CPU。<em>就绪队列</em></p><p><strong>运行状态</strong>——进程占用 CPU 并正在执行。</p><p><strong>阻塞状态</strong>——也成为等待状态。<em>阻塞队列</em></p><p><img src="Process-five-states.png" alt="进程五态模型"></p><p><strong>新建状态</strong>——进程被创建时所处的状态。</p><p><strong>终止状态</strong>——进程正常结束或出现严重错误时，会被操作系统终止或被其它有终止权的进程终止。</p><p><img src="Process-seven-states.png" alt="进程七态模型"></p><p><strong>挂起就绪</strong>——进程具备运行条件，但目前不在内存中，需要被系统调入内存才能运行。</p><p><strong>挂起阻塞</strong>——进程在等待某一事件或条件并且该进程目前不在内存中。</p><h3 id="进程控制块-PCB"><a href="#进程控制块-PCB" class="headerlink" title="进程控制块 PCB"></a>进程控制块 PCB</h3><p>描述和控制进程运行的数据结构——进程控制块（进程描述符）</p><p>PCB 是进程存在的<code>唯一标志</code></p><ol><li>进程标识信息——内部标识符和外部标识符 </li><li>现场信息——进程运行时 CPU 的即时状态即各寄存器的值</li><li>控制信息——操作系统控制进程需要的信息</li></ol><h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p>核心态（内核态）和用户态，也称为管态和目态</p><p><strong>进程控制</strong>——系统对进程生命周期的各个环节进行控制</p><p>进程控制通常由原语完成。<strong>原语</strong>是由若干条指令所组成，用来实现某个特定功能，在执行过程中不可被中断的程序段。</p><p>原语是不可分割的执行单位，原语的执行不可能是并发的。</p><ol><li>创建进程</li><li>撤消与终止进程</li><li>阻塞与唤醒进程</li><li>挂起与激活进程</li></ol><h2 id="进程的互斥与同步"><a href="#进程的互斥与同步" class="headerlink" title="进程的互斥与同步"></a>进程的互斥与同步</h2><p>并发运行的多个进程之间存在两种基本关系——竞争（互斥）和协作（同步）</p><p>竞争，会引起一下两种极端情况：</p><ul><li>死锁：一组进程均只占有部分所需资源而无法继续运行，陷入阻塞</li><li>饥饿：进程被调度程序长期忽视而分配不到 CPU 执行</li></ul><h3 id="临界资源与临界区"><a href="#临界资源与临界区" class="headerlink" title="临界资源与临界区"></a>临界资源与临界区</h3><p><strong>临界资源</strong>：在某段时间内只能允许一个进程使用的资源<br><strong>临界区</strong>：访问临界资源的代码段</p><p>临界区调度原则：</p><ol><li>一次至多一个进程能够进入临界区内执行；</li><li>如果已有进程在临界区，其它试图进入的进程应等待；</li><li>进入临界区内的进程应在有限时间内退出，以便让等待进程中的一个进入；</li></ol><h3 id="进程同步机制"><a href="#进程同步机制" class="headerlink" title="进程同步机制"></a>进程同步机制</h3><ol><li><p>信号量机制</p><p>P(s)：将信号量 s 的值减 1，若结果小于 0，则调用 P(s) 的进程被阻塞，并进入信号量 s 的阻塞队列中；若结果不小于 0，则调用 P(s) 的进程继续运行。</p><p>V(s)：将信号量 s 的值加 1，若结果不大于 0，则调用 V(s) 的进程从该信号量阻塞队列中释放、唤醒一个处于等待状态的进程，将其转换为就绪状态，调用 V(s) 的进程继续运行；若结果大于0，则调用V(s)的进程继续运行。</p><ul><li>P 操作意味进程申请一个资源，求而不得则阻塞进程，V 操作意味着释放一个资源，若此时还有进程在等待获取该资源，则被唤醒。</li><li>若信号量的值为正数，该正数表示可对信号量可进行的 P 操作的次数，即可用的资源数。信号量的初值一般设为系统中相关资源的总数，对于互斥信号量，初值一般设为 1。</li><li>若信号量的值为负，其绝对值表示有多个进程申请该资源而又不能得到，在阻塞队列等待，即在信号量阻塞队列中等待该资源的进程个数。</li></ul></li><li><p>管程同步机制</p><p>把临界区集中并封装成抽象数据类型，其中包括与临界资源相关、仅限管程内部访问的公共变量，供管程外的进程调用以访问这些公共变量的接口过程，并提供互斥机制确保进程互斥地使用管程 。</p><p>管程具有以下特点：</p><ul><li>模块化</li><li>隐蔽性</li><li>互斥性</li></ul><p>条件变量（condition variable）同步机制</p><ul><li>让进入管程却因资源不足而阻塞的进程暂时放弃管程控制权（开放管程），进入该条件变量的等待队列 </li><li>条件变量只能在管程中通过两个原语操作——wait 原语和 signal 原语 </li><li>一个进程已进入管程但无法继续执行，便在相应的条件变量 x 上调用 x.wait( )，将自己阻塞并移入 x 的等待队列中，放弃管程控制权（开放管程），另一进程可以通过对同一个条件变量执行 x.signal( ) 来唤醒之前在 x 上等待的进程  </li></ul></li></ol><p><strong>管程与进程的区别：</strong></p><ul><li>管程把共享变量上的同步操作集中起来，而临界区却分散在每个进程中；</li><li>管程是为管理共享资源而建立的，进程主要是为实现系统并发性而引入的；</li><li>管程被进程调用，管程和调用它的进程不能并行工作，而进程之间能并行工作，并发性是其固有特性；</li><li>管程是语言或操作系统的组成部分，随操作系统启动而装入内存，不必创建或撤销，而进程有生命周期；</li></ul><h3 id="进程同步经典问题"><a href="#进程同步经典问题" class="headerlink" title="进程同步经典问题"></a>进程同步经典问题</h3><ol><li><p>生产者-消费者问题</p><p>在并发环境下生产者、消费者进程访问缓冲区的速度不协调、不匹配——不同步，或者没有做到互不影响地使用、更新缓冲区——互斥，所以会出现运行错误甚至是死锁。<img src="Producer-consumer.png" alt="生产者-消费者问题"></p></li><li><p>读者-写者问题</p><ul><li>允许多个读者进程同时读文件</li><li>只允许一个写者进程写文件</li><li>任何一个写者进程在完成写操作之前不允许其它读者或写者工作</li><li>写者执行写操作前，应让已有的写者和读者全部退出</li></ul></li><li><p>哲学家就餐问题</p><p>五个哲学家围坐在一圆桌旁，桌中央有一盘通心面，每人面前有一只空盘子，每两人之间放一只筷子。每个哲学家的行为是思考，感到饥饿，然后吃通心面。为了吃面，每个哲学家必须拿到两只筷子，并且每个人只能直接从自己的左手边和右手边去取筷子。<img src="Philosopher-dining.png" alt="哲学家就餐问题"></p></li><li><p>睡眠理发师</p><p>理发店里有一个理发师，一把理发椅，N 个供等候顾客休息的椅子。若无顾客，理发师躺在理发椅上睡觉。顾客到来时唤醒理发师，若理发师正在理发，新来的顾客坐在空闲的休息椅上等候，如果没有空椅子，顾客离开。</p></li></ol><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><ol><li>消息传递通信</li><li>共享内存通信</li><li>管道通信</li></ol><h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><p>两种基本的进程调度方式，抢占方式和非抢占方式，也称剥夺式（preemptive）和非剥夺式（non_preemptive）调度</p><h3 id="进程调度模型"><a href="#进程调度模型" class="headerlink" title="进程调度模型"></a>进程调度模型</h3><ul><li>高级调度（High-Level Scheduling)，又称为作业调度，它决定把后备作业调入内存运行； </li><li>中级调度（Intermediate-Level Scheduling)，又称为平衡调度，在虚拟存储器中引入，在内、外存对换区进行进程对换；</li><li>低级调度 (Low-Level Scheduling)：又称为进程调度，它决定就绪队列的某进程获得CPU； <img src="Three-level-scheduling.png" alt="三级调度模型"></li></ul><h3 id="调度算法选择-评价准则"><a href="#调度算法选择-评价准则" class="headerlink" title="调度算法选择/评价准则"></a>调度算法选择/评价准则</h3><ul><li>处理器利用率（CPU utilization）= CPU有效工作时间 / CPU总的运行时间 </li><li>响应时间（response time）：交互环境下用户从键盘提交请求开始，到系统首次产生响应为止的时间</li><li>周转时间（turnaround time）Ti =  Tf – Ts，即：周转时间 = 完成时刻 - 提交时刻 </li><li>带权周转时间—— Wi = 作业的周转时间 Ti / 系统为作业提供的服务时间 Tsi，显然带权周转时间总大于 1 </li><li>平均作业周转时间 T = (ΣTi) / n</li><li>平均作业带权周转时间W = (ΣWi) / n</li></ul><h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><p>非剥夺方式：先来先服务、短作业优先、高响应比优先</p><p>剥夺方式：最短剩余时间优先、优先权、时间片轮转</p><ol><li><p>先来先服务（First-Come First-Served，FCFS）——按进程就绪的先后顺序来调度，到达得越早，就越先执行</p><ul><li>获得CPU的进程，未遇到其它情况时，一直运行下去</li><li>是一种非抢占式算法</li><li>没有考虑执行时间长短、运行特性和资源的要求</li></ul><p>系统中现有 5 个作业 A、B、C、D、E 同时提交（到达顺序也为ABCDE），其预计运行时间分别 10、1、2、1、5 个时间单位，如表所示，计算 FCFS 调度下作业的平均周转时间和平均带权周转时间。</p><table><thead><tr><th>作业ID</th><th>预计需运行时间</th></tr></thead><tbody><tr><td>A</td><td>10</td></tr><tr><td>B</td><td>1</td></tr><tr><td>C</td><td>2</td></tr><tr><td>D</td><td>1</td></tr><tr><td>E</td><td>5</td></tr></tbody></table><p>设作业到达时刻为0，根据定义计算，系统运行情况 </p><table><thead><tr><th>作业ID</th><th>运行时间</th><th>等待时间</th><th>开始时间</th><th>完成时间</th><th>周转时间</th><th>带权周转时间</th></tr></thead><tbody><tr><td>A</td><td>10</td><td>0</td><td>0</td><td>10</td><td>10</td><td>1</td></tr><tr><td>B</td><td>1</td><td>10</td><td>10</td><td>11</td><td>11</td><td>11</td></tr><tr><td>C</td><td>2</td><td>11</td><td>11</td><td>13</td><td>13</td><td>6.5</td></tr><tr><td>D</td><td>1</td><td>13</td><td>13</td><td>14</td><td>14</td><td>14</td></tr><tr><td>E</td><td>5</td><td>14</td><td>14</td><td>19</td><td>19</td><td>3.8</td></tr></tbody></table><p>平均周转时间：T =（10+11+13+14+19）/ 5 = 13.4<br>平均带权周转时间：W =（1+11+6.5+14+3.8）/ 5 = 7.26</p></li><li><p>短作业优先（Shortest-Job-First，SJF）——以进入系统的作业所要求的CPU服务时间为标准，总选取估计所需CPU时间最短的作业优先投入运行</p></li><li><p>最短剩余时间优先（Shortest Remaining Time First，SRTF）——若一就绪状态的新作业所需的CPU时间比当前正在执行的作业剩余任务所需CPU时间还短，SRTF将打断正在执行作业，将执行权分配给新作业</p></li><li><p>高响应比优先（Highest Response Ratio First，HRRF）——是 FCFS 与 SJF 两种算法的折衷——既考虑作业等待时间，又考虑作业的运行时间，既照顾短作业又不使长作业等待过久，改善了调度性能，仍属于非抢占式算法</p><p>响应比为作业的响应时间与作业所需运行时间之比，简化为：响应比 ＝1 +（已等待的时间 / 估计运行时间）</p></li><li><p>优先权（Highest-Priority-First，HPF）——根据进程的优先权进行进程调度，每次总是选取优先权高的进程调度，也称优先级调度算法，一般是抢占式调度</p></li><li><p>时间片轮转（Round-Ribon，RR）——调度程序把CPU分配给进程使用一个规定的时段，称为一个时间片（如100ms），就绪队列中的进程轮流获得CPU的一个时间片。当一个时间片结束时，系统剥夺该进程执行权，等候下一轮调度，属于抢占式调度</p></li></ol><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p> 死锁产生的原因主要有两个：</p><ul><li>并发进程对临界资源的竞争</li><li>并发进程推进顺序不当</li></ul><p>死锁发生的四个必要条件：</p><ol><li>互斥条件</li><li>请求与保持条件</li><li>不剥夺条件</li><li>环路等待条件</li></ol><p><strong>银行家算法</strong>的思路：</p><ol><li>在某一时刻，各进程已获得所需的部分资源。有一进程提出新的资源请求，系统将剩余资源试探性地分配给该进程。</li><li>如果此时剩余资源能够满足余下的某些进程的需求，则将剩余资源分配给能充分满足的、资源需求缺口最大的进程，运行结束后释放的资源再并入系统的剩余资源集合。</li><li>反复执行第 2 步，直到所有的进程都能够获得所需而运行结束。说明第1步的进程请求是可行的，系统处于安全状态，相应的进程执行序列称为系统的安全序列。如果所有的进程都试探过而不能将资源分配给进程，即不存在安全序列，则系统是不安全的。</li></ol><h2 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h2><ul><li>进程是程序在某个数据集合上的一次执行过程，线程是进程内部的一个执行序列</li><li>进程是资源分配的最小单位，线程是 CPU 调度的最小单位</li><li>一个进程可以包含若干个线程</li><li>多个线程共享进程的资源，使用相同的地址空间</li><li>进程间切换代价大，线程间切换代价小</li><li>进程拥有资源多，线程不拥有自己的资源或只有必要的资源</li></ul><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p><strong>MMU</strong> 内存管理单元，也称作分页内存管理单元，把虚拟地址转换成物理地址。<strong>TLB</strong> 是一块高速缓存，缓存虚拟地址和其映射的物理地址，减少CPU访问物理内存的次数，用于改进虚拟地址到物理地址转换速度。</p><h2 id="内存管理概述"><a href="#内存管理概述" class="headerlink" title="内存管理概述"></a>内存管理概述</h2><p>计算机的存储系统主要包括内存储器和外存储器</p><ul><li>内存储器（Memory）即俗称的内存或主存</li><li>外存储器也叫辅助存储器</li></ul><h3 id="计算机存储系统的结构"><a href="#计算机存储系统的结构" class="headerlink" title="计算机存储系统的结构"></a>计算机存储系统的结构</h3><p><img src="Structure-of-storage-system.jpg" alt="计算机系统的结构与使用关系"></p><h3 id="地址的表示与地址转换"><a href="#地址的表示与地址转换" class="headerlink" title="地址的表示与地址转换"></a>地址的表示与地址转换</h3><p>只有把程序和数据的逻辑地址转换为物理地址，程序才能正确运行，该过程称为地址转换或地址重定位。地址转换有静态重定位和动态重定位两种方式。</p><ul><li>静态重定位：这种方式是在用户作业装入内存时由装入程序(装配程序)实现从逻辑地址到物理地址的转换，地址转换在作业执行前一次完成</li><li>动态重定位：程序执行过程中，CPU在访问程序和数据之前才实现地址转换。动态重定位必须借助于硬件地址转换机构来实现，硬件系统中设置了一个<strong>定位寄存器</strong>，当操作系统为某程序分配了一块内存区域后，装入程序把程序装入到所分配的区域中，然后把该内存区域的起始地址置入定位寄存器中。在程序执行过程中需要进行地址转换时，只需将逻辑地址与定位寄存器中的值相加就可得到物理地址。这种地址转换方式是在指令过程中进行的，所以称动态重定位。</li></ul><h3 id="内存管理的功能"><a href="#内存管理的功能" class="headerlink" title="内存管理的功能"></a>内存管理的功能</h3><ol><li>内存的分配和回收</li><li>提高内存的利用率</li><li>通过虚拟存储技术“扩充”内存容量</li><li>内存信息保护</li></ol><h3 id="覆盖与交换技术"><a href="#覆盖与交换技术" class="headerlink" title="覆盖与交换技术"></a>覆盖与交换技术</h3><ol><li><p>覆盖技术：按照程序自身的逻辑结构，让不同时执行的程序段先后共享同一块内存区域</p><p>例如：某程序由A、B、C、D、E、F等六个程序段组成，它们之间的调用关系如图3.3左图所示。其中，程序段A只调用B和C，程序段B只调用F，而程序段C只调用D和E。由于B和C之间没有相互调用，所以它们可以共享同一覆盖区。覆盖区的大小以能装入所有共享的程序段为准。本例中，与B、C对应的覆盖区的大小为50K。类似地，D、E、F也可以共享一大小为40K的覆盖区，如下图所示。<img src="Coverage-technology.png" alt="覆盖技术"></p></li><li><p>交换技术：由操作系统根据需要，将某些暂时不运行的进程或程序段从内存移到外存的交换区中；当内存空间富余时再给被移出的进程或程序段重新分配内存，让其进入内存</p></li></ol><h2 id="分区内存管理"><a href="#分区内存管理" class="headerlink" title="分区内存管理"></a>分区内存管理</h2><ol><li>单一连续内存管理</li><li>固定分区内存管理</li><li>可变分区内存管理<ul><li>最先适应分配算法</li><li>循环首次适应分配算法</li><li>最优适应分配算法</li><li>最差适应分配算法</li><li>快速适应算法</li></ul></li></ol><h2 id="页式存储管理"><a href="#页式存储管理" class="headerlink" title="页式存储管理"></a>页式存储管理</h2><p>页：将用户进程的逻辑地址空间划分为大小相等的区，每一个区称为一页或一个页面，并对各页从 0 开始编号，如第 0 页、第 1 页等。</p><p>物理块：将物理内存也划分成与页大小相等的区，每一个区称为一个物理块(block)，或称为块、页框，也同样对它们加以编号，如 0 号块、1 号块等。</p><p>内存分配的<strong>基本单位</strong>是页，进程的最后一页经常装不满一块，所以会在最后一块内形成不可利用的碎片，称之为“<strong>页内碎片</strong>”。</p><p>32 位操作系统其逻辑地址是 32 位，采用页式内存管理，如果每页大小 4096 B，那么页内偏移要占用其逻辑地址的低 12 位，从 0 位开始到 11 位结束。逻辑地址剩余的高 20 位用来表示页号，从 12 位开始到 31 位结束，这样最多允许有 220（1M）个页面。页面的编号从 0 开始，分别为 0，1，2，3 …，220−1，如图所示。</p><p><img src="Page-storage.jpg" alt="页式存储的逻辑地址"></p><h3 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h3><p>为了提高程序的运行速度，可以将最近访问过的页的页表项信息存放在高速缓存中，高速缓存也称为“联想存储器”，其中的页表称为“快表”。</p><h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p>为了能够快速查找页表页在内存中的物理块号，为这些页表页再设计一个地址索引表，即页目录表。二级页表的逻辑地址被划分为三部分： 页目录、页表页、页内偏移</p><p><img src="Secondary-page-table.jpg" alt="二级页表结构"></p><p><strong>缺页中断</strong>指的是在进程运行过程中，发现所访问的页不在内存中时，CPU的内存管理单元发出的中断。与一般中断：CPU 检测中断时间不同，CPU 可多次处理。</p><p><strong>缺页中断处理流程</strong>是：先查看内存是否有空闲块，若有则按该页在外存中的地址将该页找出并装入内存，在页表中填上它占用的块号且修改标志位。若内存已没有空闲块，则必须先淘汰已在内存中的某一页，再将所需的页装入，对页表和内存分配表作相应的修改。淘汰某页时，要查看该页的修改位来判断该页是否修改过，若该页在执行过程中没有被修改过，那么不必重新写回到存储器中，而已修改过的页调出时必须再将该页写回到外存中。</p><h2 id="段式存储管理"><a href="#段式存储管理" class="headerlink" title="段式存储管理"></a>段式存储管理</h2><p>分段式存储管理是以段为单位进行内存分配，逻辑地址空间是一个二维空间，分为段号和段内偏移两部分。</p><p><img src="Segment-storage.png" alt="段式存储的逻辑地址"></p><p><strong>分段和分页的比较</strong></p><ul><li>段是信息的逻辑单位，由源程序的逻辑结构所决定，用户可见，段长可根据用户需要来规定，段起始地址可以从任何地址开始。在分段方式中，源程序(段号，段内偏移)经连结装配后仍保持二维结构。</li><li>页是信息的物理单位，与源程序的逻辑结构无关，用户不可见，页长由系统确定，页面只能以页大小的整倍数地址开始。在分页方式中，源程序(页号，页内偏移)经连结装配后变成了一维结构。</li><li>在分段式存储管理的基础上实现分页式存储管理，这就是<strong>段页式存储管理</strong>，是目前应用最多的一种存储管理方式。</li></ul><p><img src="Segment-page-storage.png" alt="段页式存储的逻辑地址"></p><p>逻辑地址分 3 个部分：段号、段内页号和页内位移，其形式为：对于用户来说，虚拟地址应该由段号 s 和段内位移 d’ 组成，用户看不到如何分页。而是由操作系统自动把 d’解释成两部分：段内页号 p 和页内位移 d，也就是说，d’ = p × 块长+ d。 </p><h2 id="虚拟存储技术"><a href="#虚拟存储技术" class="headerlink" title="虚拟存储技术"></a>虚拟存储技术</h2><p>将作业不执行的部分暂时存放在外存，待到进程需要时，再将其从外存调入内存。将外存作为内存的补充，从逻辑上扩充内存。</p><p>虚拟存储技术的<strong>实现基础</strong>是内存的分页或分段管理，采用的是进程的分页或分段在内存与外存之间对换。</p><h2 id="请求分页虚拟存储管理"><a href="#请求分页虚拟存储管理" class="headerlink" title="请求分页虚拟存储管理"></a>请求分页虚拟存储管理</h2><h3 id="硬件支持"><a href="#硬件支持" class="headerlink" title="硬件支持"></a>硬件支持</h3><ol><li>请求分页的页表机制</li><li>缺页中断机构</li><li>地址转换机构 </li></ol><h3 id="页面分配策略与页面调度算法"><a href="#页面分配策略与页面调度算法" class="headerlink" title="页面分配策略与页面调度算法"></a>页面分配策略与页面调度算法</h3><p><strong>1.页面分配策略</strong></p><p>通常分为固定分配和可变分配两种不同的方式</p><ol><li>固定分配方式：<ul><li>进程平均分配法</li><li>进程按比例分配法</li><li>进程优先权分配法</li></ul></li><li>可变分配方式</li></ol><p><strong>2.页面调入策略</strong></p><ol><li>请求页（demand paging）调入</li><li>预先页（prepaging）调入 </li></ol><p><strong>3.页面置换策略</strong></p><ol><li>全局置换</li><li>局部置换</li></ol><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p>先进先出、最佳页面、最近最久未使用、时钟置换算法</p><ol><li><p>先进先出（FIFO）页面置换算法</p><p>总是选择最先进入内存的页面或驻留时间最长的页面先淘汰<img src="FIFO.png" alt="FIFO 页面置换算法"></p></li><li><p>最佳（OPT）页面置换算法</p><p>在选择页面置换时应该考虑该页面将来使用的情况，将来最长时间不用的页面被淘汰。在进程采用固定页面分配的情况下，最佳页面置换算法具有最低的缺页率<img src="OPT.png" alt="OPT 页面置换算法"></p></li><li><p>LRU 页面置换算法</p><p>系统须维护一个页面淘汰队列，该队列中存放当前在内存中的页号，每当访问一页时就调整一次，使队尾总指向最近访问的页，而队列头部就是最近最少用的页，发生缺页中断时总淘汰队列头所指示的页；而执行一次页面访问后，需要从队列中把该页调整到队列尾<img src="LRU.png" alt="LRU 页面置换算法"></p></li><li><p>时钟（clock）置换算法</p></li></ol><h1 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h1><h2 id="设备管理概述"><a href="#设备管理概述" class="headerlink" title="设备管理概述"></a>设备管理概述</h2><p>设备管理目标：</p><ul><li>提高使用效率</li><li>提供便捷的界面</li></ul><p>设备管理功能：</p><ul><li>设备的分配与回收</li><li>缓冲区管理</li><li>设备控制和中断处理</li><li>实现虚拟设备</li></ul><h2 id="设备控制方法"><a href="#设备控制方法" class="headerlink" title="设备控制方法"></a>设备控制方法</h2><ol><li><p>程序循环查询方式</p></li><li><p>中断驱动方式</p></li><li><p>直接内存访问方式（DMA）</p><ul><li>数据传输的基本单位是数据块</li><li>所传送的数据是从设备直接送入内存，或者直接读出内存的</li><li>在传输时CPU参与更少，仅在传送一个或多个数据块的开始和结束时，才需CPU干预，整块数据的传送是在控制器的控制下完成的</li></ul></li><li><p>通道方式</p><p>I/O 通道方式是 DMA 方式的发展，它可进一步减少 CPU 的干预，即把对一个数据块的读(或写)为单位的干预，减少为对一组数据块的读(或写)及有关的控制和管理为单位的干预</p></li></ol><h2 id="缓冲技术"><a href="#缓冲技术" class="headerlink" title="缓冲技术"></a>缓冲技术</h2><p>缓冲技术主要有以下作用：</p><ul><li>改善中央处理器与外围设备之间速度不匹配的矛盾，提高 CPU 和 I/O 设备的并行性</li><li>减少 I/O 对 CPU 的中断次数和放宽对 CPU 中断响应时间的要求</li><li>协调逻辑记录大小与物理记录大小不一致的问题</li></ul><h2 id="输入输出软件"><a href="#输入输出软件" class="headerlink" title="输入输出软件"></a>输入输出软件</h2><p><strong>设备独立性</strong>，也称为设备无关性，是指在用户程序中不直接使用物理设备名（或设备的物理地址），而只能使用逻辑设备名。</p><ul><li>使得设备分配更加灵活，提高了设备的利用率</li><li>可以实现 I/O 重定向</li></ul><h2 id="设备分配与回收"><a href="#设备分配与回收" class="headerlink" title="设备分配与回收"></a>设备分配与回收</h2><h3 id="设备信息描述"><a href="#设备信息描述" class="headerlink" title="设备信息描述"></a>设备信息描述</h3><ol><li>系统设备表 SDT</li><li>设备控制表 DCT</li><li>控制器控制表 COCT</li><li>通道控制表 CHCT</li></ol><h3 id="设备分配策略"><a href="#设备分配策略" class="headerlink" title="设备分配策略"></a>设备分配策略</h3><ol><li>独占方式</li><li>共享方式</li><li>虚拟方式</li></ol><h3 id="SPOOLing-技术-假脱机"><a href="#SPOOLing-技术-假脱机" class="headerlink" title="SPOOLing 技术(假脱机)"></a>SPOOLing 技术(假脱机)</h3><p>当系统中引入了多道程序技术后，可以利用其中的一道程序，来模拟脱机输入输出时的外围控制机功能，把低速 I/O 设备上的数据传送到高速磁盘上；或者把数据从磁盘传送到低速输出设备上。这样，便可在主机的直接控制下，实现脱机输入输出功能。</p><ul><li>提高了 I/O 的速度，缓和了高速的处理器与低速输入输出设备之间的矛盾</li><li>将独占设备改造为共享设备，提高了设备的利用率</li><li>实现了虚拟设备功能，将物理的单个设备变换为多个对应的逻辑设备</li></ul><h3 id="设备分配算法"><a href="#设备分配算法" class="headerlink" title="设备分配算法"></a>设备分配算法</h3><ul><li>先来先服务算法</li><li>优先级高者优先算法</li></ul><h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>文件分类方法有很多，下面是常用的几种文件分类方法： </p><ul><li>按照文件的逻辑结构的不同，可以把文件分成流式文件和纪录式文件</li><li>按照用途将文件分为系统文件、库文件和用户文件</li><li>按照性质可以把文件分为普通文件、目录文件和特殊文件按照性质可以把文件分为普通文件、目录文件和特殊文件</li></ul><h2 id="文件的组织"><a href="#文件的组织" class="headerlink" title="文件的组织"></a>文件的组织</h2><h3 id="逻辑结构组织"><a href="#逻辑结构组织" class="headerlink" title="逻辑结构组织"></a>逻辑结构组织</h3><p><strong>1.流式文件</strong></p><p>流式文件指文件内的数据不组成记录，只是依次的一串信息集合，如字节流或字符流。流式文件本身可以没有结构。</p><p><strong>2.纪录式文件</strong></p><p>记录式文件是一种有结构的文件，它是指文件中的数据由若干条定长或不定长的记录构成，每条记录又由若干数据项构成。记录是记录式文件进行存取的基本单位。</p><p>按照组织方式的不同，记录式文件可进一步分为：</p><ul><li>顺序文件</li><li>索引文件</li><li>索引顺序文件</li></ul><h3 id="物理结构组织"><a href="#物理结构组织" class="headerlink" title="物理结构组织"></a>物理结构组织</h3><ol><li><p>连续文件</p></li><li><p>链接文件</p></li><li><p>索引文件<img src="Tertiary-index-eg.png" alt="3 级索引"></p></li><li><p>直接文件</p></li></ol><h3 id="文件的存取方法"><a href="#文件的存取方法" class="headerlink" title="文件的存取方法"></a>文件的存取方法</h3><ol><li>顺序存取</li><li>直接存取</li><li>按键存取</li></ol><h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><h3 id="文件目录的基本概念"><a href="#文件目录的基本概念" class="headerlink" title="文件目录的基本概念"></a>文件目录的基本概念</h3><p>文件控制块——用于描述和控制文件的数据结构，称之为文件控制块（File Control Block，FCB）</p><ul><li>为了加快文件的查找速度，通常把 FCB 集中起来进行管理，文件控制块的有序集合称为<strong>文件目录</strong></li><li>文件目录也是以文件的形式保存在外存上的，这就形成了<strong>目录文件</strong></li></ul><h3 id="目录文件的组织"><a href="#目录文件的组织" class="headerlink" title="目录文件的组织"></a>目录文件的组织</h3><p>常用的组织方法主要有三种：</p><ul><li>FCB 线性表</li><li>索引节点</li><li>哈希表组织</li></ul><h3 id="目录的结构"><a href="#目录的结构" class="headerlink" title="目录的结构"></a>目录的结构</h3><p>目录结构都是采用层次结构，主要分为：</p><ul><li>单级目录</li><li>二级目录</li><li>多级层次目录结构（最常用）</li><li>图状目录结构</li></ul>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDL复习</title>
      <link href="2020/05/05/HDL%E5%A4%8D%E4%B9%A0/"/>
      <url>2020/05/05/HDL%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="2019-2020-第一学期中国矿业大学-HDL-语言应用与设计-A卷"><a href="#2019-2020-第一学期中国矿业大学-HDL-语言应用与设计-A卷" class="headerlink" title="2019-2020 第一学期中国矿业大学 HDL 语言应用与设计 A卷"></a>2019-2020 第一学期中国矿业大学 HDL 语言应用与设计 A卷</h1><p>一、选择题</p><ol><li>右移操作</li><li>EDA 设计官方语言（不就是 VHDL 和 Verilog 嘛）</li><li>端口两种关联方式</li><li>面积、功耗优化方法</li><li>CPLD、FPGA 基本原理（乘积项和查找表）</li></ol><p>二、简答题</p><ol><li>always 和 initial 主要区别？能否嵌套？</li><li>给一段程序，写出他们的数据类型</li><li>VHDL 和 Verilog 程序区别</li></ol><p>三、程序分析注解</p><ul><li>给了一个函数，好像是奇偶校验</li></ul><p>四、程序设计题</p><ol><li>硬件消抖电路</li><li>写个函数求一个 4 位二进制数含 1 的个数，书上原题</li><li>给了个仿真图，计数从 0 - 9 再从 9  - 0 实现它</li><li>仿真 100 个时间单位，高电平 60 ，低电平 40</li><li>4 位 D 触发器，元件例化语句</li></ol><h1 id="直接上干货，三套试卷"><a href="#直接上干货，三套试卷" class="headerlink" title="直接上干货，三套试卷"></a>直接上干货，三套试卷</h1><p><img src="2020A.jpg" alt="2020A"></p><p><img src="2020B.jpg" alt="2020B"></p><p><img src="2020C.jpg" alt="2020C"></p>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HDL </tag>
            
            <tag> FPGA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uCOS-II知识点</title>
      <link href="2020/05/04/uCOS-II%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>2020/05/04/uCOS-II%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-嵌入式实时操作系统的基本概念"><a href="#第一章-嵌入式实时操作系统的基本概念" class="headerlink" title="第一章 嵌入式实时操作系统的基本概念"></a>第一章 嵌入式实时操作系统的基本概念</h1><p>第一章都是些基本概念知识，比如：什么是嵌入式操作系统，嵌入式操作系统是支持嵌入式系统工作的操作系统，一般用于比较复杂的嵌入式系统软件开发中；什么又是嵌入式实时操作系统，大多嵌入式系统应用在实时环境中，因此嵌入式操作系统跟实时（Real-Time）操作系统密切联系在一起；典型嵌入式操作系统有哪些，主要有VxWorks、Windows CE、Palm OS、QNX、Linux 和 μC/OS 等。这些东西了解即可，不用死记硬背，换句话说——不考。</p><h1 id="第二章-uC-OS-II-中的任务（重点）"><a href="#第二章-uC-OS-II-中的任务（重点）" class="headerlink" title="第二章 uC/OS-II 中的任务（重点）"></a>第二章 uC/OS-II 中的任务（重点）</h1><h2 id="任务的基本概念"><a href="#任务的基本概念" class="headerlink" title="任务的基本概念"></a>任务的基本概念</h2><p>从应用程序设计的角度，uC/OS-II 的任务就是一个<em>线程</em></p><p>uC/OS-II 任务的组成：</p><ul><li>任务代码：任务的执行部分 </li><li>任务堆栈：保存任务工作环境 </li><li>任务控制块：保存任务的属性</li></ul><p>uC/OS-II 的任务有两种：</p><ul><li>用户任务：由应用程序设计者编写的任务</li><li>系统任务：系统提供的任务 </li></ul><p>预定义了两个系统任务：<em>空闲任务</em>和<em>统计任务</em>。系统在某个时间内无用户任务可运行而处于空闲状态，为使 CPU 在没有用户任务可执行时有事可做，uC/OS-II 提供了空闲任务。统计任务每秒计算一次 CPU 在单位时间内被使用的时间，并把计算结果以百分比的形式存放在变量 OSCPUsage 中，以便应用程序通过访问它来了解 CPU 的利用率。</p><p>任务的5种状态：睡眠状态、就绪状态、运行状态、等待状态、中断服务状态</p><p><img src="task_state_transition.png" alt="任务状态转换图"></p><p>uC/OS-II 最多可以对 <em>64</em> 个任务进行管理，其中系统任务（预留）8 个，用户任务 56 个</p><p>每个任务都必须具有一个唯一的优先级别，0～63 共 64 个优先级别，数字越小，优先级别越高</p><p>在文件 OS_CFG.H 中常数 OS_LOWEST_PRIO 表示最低优先级 </p><p>任务个数：OS_LOWEST_PRIO + 1，其中 OS_LOWEST_PRIO 自动赋给空闲任务，OS_LOWEST_PRIO－1 自动赋给统计任务（存在的话）</p><p><img src="%E4%BE%8B2-3.png" alt="例2-3"></p><p>任务的优先级别为 28 个即 0～27，则最低优先级别的常数 OS_LOWEST_PRIO 值为 27，应用程序中使用了系统提供的空闲任务和统计任务，则应用程序最多可以安排 28-2 = 26 个任务。</p><h2 id="任务堆栈"><a href="#任务堆栈" class="headerlink" title="任务堆栈"></a>任务堆栈</h2><p>任务的重要组成部分；每个任务都配有自己的堆栈；满足任务切换和响应中断时保护CPU寄存器中的内容及存储任务私有数据的需要；</p><p>在文件 OS_CPU.H 中的数据类型 OS_STK </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> OS_STK;        <span class="comment">//该类型长度为16位 </span></span><br></pre></td></tr></table></figure><p>在应用程序中定义 OS_STK 类型的一个数组 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> TASK_STK_SIZE 512     <span class="comment">//定义堆栈长度 </span></span></span><br><span class="line">OS_STK TaskStk[TASK_STK_SIZE];       <span class="comment">//定义数组</span></span><br></pre></td></tr></table></figure><p><img src="OSTaskCreate.png" alt="OSTaskCreate()原型"></p><p><img src="%E4%BE%8B2-4.png" alt="例 2-4"></p><p>堆栈的增长方向是随系统所使用的处理器不同而不同,例 2-4 是假设使用了支持堆栈向下增长方式的处理器，如果使用堆栈增长方向向上的形式则如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OSTaskCreat(MyTask, &amp;MyTaskAgu, &amp;MyTaskStk[<span class="number">0</span>], <span class="number">20</span>);</span><br></pre></td></tr></table></figure><h2 id="任务控制块及其链表"><a href="#任务控制块及其链表" class="headerlink" title="任务控制块及其链表"></a>任务控制块及其链表</h2><p>任务控制块（OS_TCB）：用来记录任务的堆栈指针、任务的当前状态、任务的优先级别等一系列与任务管理有关的属性的表 </p><p>用两条链表来管理任务控制块：</p><ul><li>空任务控制块链表：应用程序调用函数 OSInit() 对 uC/OS-II 系统进行初始化时建立的单向链表 </li><li>任务控制块链表：应用程序调用 OSTaskCreate() 创建任务时建立的双向链表</li></ul><p>OSTCBInit() 的主要任务如下：</p><ul><li>为被创建任务从空任务控制块链表获取一个任务控制块；</li><li>用任务的属性对任务控制块各个成员进行赋值；</li><li>把这个任务控制块链入到任务控制块链表；</li></ul><p>**OSTCBPrioTbl[ ]**：以任务优先级为下标，保存任务控制块指针的数组。</p><p>为什么要对TCB进行初始化？ </p><ul><li>获得任务控制块 </li><li>保存任务属性</li></ul><h2 id="任务就绪表及任务调度"><a href="#任务就绪表及任务调度" class="headerlink" title="任务就绪表及任务调度"></a>任务就绪表及任务调度</h2><p>uC/OS-II进行调度的思想 </p><ul><li>每时每刻总是让优先级最高的就绪任务处于运行状态 </li><li>在系统或用户任务调用系统函数及执行中断服务程序 结束时，调用调度器来确定应该运行的任务并运行它</li></ul><p><em>任务就绪表</em>：OSRdyTbl[ ]数组，无符号8位数，一个元素可表达8个任务的就绪状态（1/0）</p><p>变量 <em>OSRdyGrp</em> 位数对应 OSRdyTbl[ ] 的下标，即组号；状态表示该组有无任务就绪</p><p>把优先级看成一个 6 位二进制数，表示范围为 0 ~ 63 共 64 个任务</p><ul><li>用高 3 位表示 OSRyGrp 的具体数据位（组号），即任务就绪表数组元素的下标</li><li>低 3 位表示数组元素的具体数据位（位置号）</li></ul><p><img src="%E4%BE%8B2-5.png" alt="例 2-5"></p><p><em>简单点的方法</em>：不需要把 49 化成二进制再分别取高低三位，直接用 49 / 8 = 6…1 可知应该在 OSRdyTbl[6] 的 D1 位上置 1，同时要把变量 OSRdyGrp 的 D6 位置 1。又如书 P74 例 3-5 给的优先级别 prio = 30 ,用同样方法 30 / 8 = 3…6 可知应该在 OSRdyTbl[3] 的 D6 位上置 1，同时要把变量 OSRdyGrp 的 D3 位置 1。 </p><p>OSMapTbl[ ] 是为加快运算速度定义的一个数组，它的各元素值为： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OSMapTbl[<span class="number">0</span>] = <span class="number">00000001B</span>;</span><br><span class="line">OSMapTbl[<span class="number">1</span>] = <span class="number">00000010B</span>; </span><br><span class="line">OSMapTbl[<span class="number">2</span>] = <span class="number">00000100B</span>; </span><br><span class="line">OSMapTbl[<span class="number">3</span>] = <span class="number">00001000B</span>; </span><br><span class="line">OSMapTbl[<span class="number">4</span>] = <span class="number">00010000B</span>; </span><br><span class="line">OSMapTbl[<span class="number">5</span>] = <span class="number">00100000B</span>; </span><br><span class="line">OSMapTbl[<span class="number">6</span>] = <span class="number">01000000B</span>; </span><br><span class="line">OSMapTbl[<span class="number">7</span>] = <span class="number">10000000B</span>;</span><br></pre></td></tr></table></figure><p><strong>登记</strong>：在程序中，用下面的代码把优先级别为prio的任务置为就绪状态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OSRdyGrp |= OSMapTbl[prio&gt;&gt;<span class="number">3</span>];   </span><br><span class="line">OSRdyTbl[prio&gt;&gt;<span class="number">3</span>] |= OSMapTbl[prio&amp;<span class="number">0x07</span>]; </span><br></pre></td></tr></table></figure><blockquote><p>举例 prio = 30 = 011 110<br>OSRdyGrp 的 D3 位置 1<br>OSRdyGrp = OSRdyGrp | OSMapTbl[3] = OSRdyGrp | 00001000<br>OSRdyTbl[3] 的 D6 位置 1<br>OSRdyTbl[3] = OSRdyTbl[3] | OSMapTbl[6] = OSRdyTbl[3] | 01000000</p></blockquote><p><strong>注销</strong>：使一个优先级别为prio的任务脱离就绪状态 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((OSRdyTbl[prio&gt;&gt;<span class="number">3</span>] &amp;= -OSMapTbl[prio&amp;<span class="number">0x07</span>])==<span class="number">0</span>) </span><br><span class="line">  OSRdyGrp &amp;= -OSMapTbl[prio&gt;&gt;<span class="number">3</span>]; </span><br></pre></td></tr></table></figure><blockquote><p>举例 prio = 30 = 011 110<br>if(OSRdyTbl[3] &amp;= 10111111 == 0) 将 OSRdyTbl[3] 的 D6 位置 0，如果 OSRdyTbl[3] == 0 即所有任务都处于非就绪状态<br>OSRdyGrp = OSRdyGrp &amp; 11110111   OSRdyGrp 的 D3 位置 0 ，其它位不变 </p></blockquote><p><strong>查找最高优先级</strong>： 从任务就绪表中获得优先级别最高的就绪任务 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Y = OSUnMapTbl[OSRdyGrp]; <span class="comment">//获得优先级别高3位 </span></span><br><span class="line">X = OSUnMapTbl[OSRdyTbl[y]];    <span class="comment">//获得优先级别低3位 </span></span><br><span class="line">Prio = (y&lt;&lt;<span class="number">3</span>) + x; <span class="comment">//获得就绪任务的优先级别 </span></span><br><span class="line">或 </span><br><span class="line">Y = OSUnMapTbl[OSRdyGrp]; </span><br><span class="line">Prio = (INT8U)((y&lt;&lt;<span class="number">3</span>) + OSUnMapTbl[OSRdyTbl[y]]); </span><br><span class="line"></span><br><span class="line">INT8U <span class="keyword">const</span> OSUnMapTbl[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, </span><br><span class="line">    <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, </span><br><span class="line">    <span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, </span><br><span class="line">    <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, </span><br><span class="line">    <span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, </span><br><span class="line">    <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, </span><br><span class="line">    <span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, </span><br><span class="line">    <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, </span><br><span class="line">    <span class="number">7</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, </span><br><span class="line">    <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, </span><br><span class="line">    <span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, </span><br><span class="line">    <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, </span><br><span class="line">    <span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, </span><br><span class="line">    <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, </span><br><span class="line">    <span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, </span><br><span class="line">    <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>辅助数组 OSUnMapTbl[ ] 的赋值过程（分析较长，可跳过）<br>变量 OSRdyGrp 格式如下：</p><table><thead><tr><th align="center">D7</th><th align="center">D6</th><th align="center">D5</th><th align="center">D4</th><th align="center">D3</th><th align="center">D2</th><th align="center">D1</th><th align="center">D0</th></tr></thead><tbody><tr><td align="center">1/0</td><td align="center">1/0</td><td align="center">1/0</td><td align="center">1/0</td><td align="center">1/0</td><td align="center">1/0</td><td align="center">1/0</td><td align="center">1/0</td></tr></tbody></table><p>分析 y = OSUnMapTbI[OSRdyGrp]; //优先级高三位</p><p>① D0=1时<br>表明OSRdyTbl[0]中有任务就绪，OSRdyTbl[0]中的任务优先级为0-7，则y应该为0，OSRdyGrp为奇数，故数组OSUnMapTbl中以奇数为下标的数组元素都应该为0；<br>② D1=1,D0=0时<br>表明OSRdyTbl[1]中有任务就绪，OSRdyTbl[1]中的任务优先级为8-15，则y应该为1，OSRdyGrp取值为2、6、10、14、18…，故数组 OSUnMapTbl中下标能被2整除且不能被4整除的数组元素值都应该为1；</p><p>③ D2=1,D1=0,D0=0时<br>表明OSRdyTbl[2]中有任务就绪，OSRdyTbl[2]中的任务优先级为16-23，则y应该为2，OSRdyGrp取值为4、12、20、28…，故数组 OSUnMapTbl中下标能被4整除且不能被8整除的数组元素值都应该为2；</p><p>④ D3=1,D2=0,D1=0,D0=0时<br>表明OSRdyTbl[3]中有任务就绪，OSRdyTbl[3]中的任务优先级为24-31，则y应该为3，OSRdyGrp取值为8、24、40、56…，故数组 OSUnMapTbl中下标能被8整除且不能被16整除的数组元素值都应该为3；</p><p>⑤ D4=1,D3=0,D2=0,D1=0,D0=0时<br>表明OSRdyTbl[4]中有任务就绪，OSRdyTbl[4]中的任务优先级为32-39，则y应该为4，OSRdyGrp取值为16、48、64、80…，故数组 OSUnMapTbl中下标能被16整除且不能被32整除的数组元素值都应该为4；</p><p>⑥ D5=1,D4=0,D3=0,D2=0,D1=0,D0=0时<br>表明OSRdyTbl[5]中有任务就绪，OSRdyTbl[5]中的任务优先级为40-47，则y应该为5，OSRdyGrp取值为32、96、160、224，故数组 OSUnMapTbl中下标能被32整除且不能被64整除的数组元素值都应该为5；</p><p>⑦ D6=1,D5=0,D4=0,D3=0,D2=0,D1=0,D0=0时<br>表明OSRdyTbl[6]中有任务就绪，OSRdyTbl[6]中的任务优先级为48-55，则y应该为6，OSRdyGrp取值为64、192，故数组 OSUnMapTbl中下标能被64整除且不能被128整除的数组元素值都应该为6；</p><p>⑧ D7=1,D6=0,D5=0,D4=0,D3=0,D2=0,D1=0,D0=0时<br>表明OSRdyTbl[7]中有任务就绪，OSRdyTbl[7]中的任务优先级为56-63，则y应该为7，OSRdyGrp取值为128，故数组OSUnMapTbl中下标为128的数组元素值应该为7；</p><p>调度器有两种：</p><ul><li>任务级调度器：OSSched() 函数 </li><li>中断级调度器：OSIntExit() 函数 </li></ul><p>任务调度主要工作有两项： </p><ul><li>在任务就绪表中查找具有最高优先级别的就绪任务 </li><li>实现任务切换 <ul><li>获得待运行任务的 TCB 指针 </li><li>进行断点数据的切换</li></ul></li></ul><p><img src="OSSched.png" alt="OSSched 源代码"></p><p>任务切换宏 OS_TASK_SW() 实际工作主要由 OSCtxSw 来完成，OSCtxSw() 依次完成的工作</p><ol><li>把被中止任务的断点指针保存到任务堆栈中</li><li>把 CPU 通用寄存器的内容保存到被中止任务的堆栈中 </li><li>把被中止任务的任务堆栈指针当前值保存到该任务的任务控制块的 OSTCBStkPtr 中 </li><li>获得待运行任务的任务控制块 </li><li>使 CPU 通过任务控制块获得待运行任务的任务堆栈指针 </li><li>把待运行任务堆栈中通用寄存器的内容恢复到 CPU 的通用寄存器中 </li><li>使 CPU 获得待运行任务的断点指针PC </li></ol><h2 id="任务的创建"><a href="#任务的创建" class="headerlink" title="任务的创建"></a>任务的创建</h2><p>有两个用来创建任务的函数： </p><ul><li>OSTaskCreate() </li><li>OSTaskCreateExt() </li></ul><p>调用函数OSStart()之前先创建一个任务，并赋予它最高的优先级别，从而使它成为起始任务；然后在这个任务中，再创建其它各任务。</p><p><img src="%E4%BE%8B2-7.png" alt="例 2-7"></p><p><img src="%E4%BE%8B2-71.jpg" alt="运行结果"></p><p>多任务程序分析方法：<em>时间轴法</em><br><img src="%E4%BE%8B2-72.png" alt="程序分析"></p><h2 id="任务的挂起和恢复"><a href="#任务的挂起和恢复" class="headerlink" title="任务的挂起和恢复"></a>任务的挂起和恢复</h2><p><img src="OSTaskSuspendResume.png" alt="任务的挂起和恢复"></p><p><em>挂起任务</em>函数 OSTaskSuspend() 和<em>恢复任务</em>函数 OSTaskResume() 的原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INT8U <span class="title">OSTaskSuspend</span> <span class="params">(INT8U prio)</span></span>;</span><br><span class="line"><span class="function">INT8U <span class="title">OSTaskResume</span> <span class="params">(INT8U prio)</span></span>;</span><br></pre></td></tr></table></figure><p>挂起任务自身时,函数参数为：OS_PRIO_SELF（<em>0xFF</em>） </p><h2 id="其他任务管理函数"><a href="#其他任务管理函数" class="headerlink" title="其他任务管理函数"></a>其他任务管理函数</h2><p>任务优先级别的修改 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INT8U <span class="title">OSTaskChangePrio</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">      INT8U oldprio, <span class="comment">//任务现在的优先级别 </span></span></span></span><br><span class="line"><span class="function"><span class="params">      INT8U newprio <span class="comment">//要修改的优先级别 </span></span></span></span><br><span class="line"><span class="function"><span class="params">      )</span></span>;</span><br></pre></td></tr></table></figure><p>任务的删除</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INT8U <span class="title">OSTaskDel</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">INT8U prio <span class="comment">//要删除任务的优先级别 </span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; </span><br></pre></td></tr></table></figure><ul><li>把被删除任务的任务控制块从任务控制块链表中删除，并归还给空任务控制块链表，然后在任务就绪表中把该任务的就绪状态置为0，于是该任务就不能再被调度了 </li><li>可以通过调用 OSTaskDel() 来删除任务自身或除了空闲任务之外的其它任务 </li><li>删除任务自己时，函数参数为：OS_PRIO_SELF</li><li>被动删除的任务，往往存在<em>动态分配资源丢失!!</em></li></ul><p>一般删除任务的方法</p><ul><li>提出删除任务请求的任务 A 只负责提出删除任务请求，而删除工作则由被删除任务 B 自己来完成</li><li>联络信号：OSTCBDelReq（ B 的任务控制块成员） </li><li>A 调用<strong>请求删除任务函数</strong>：OSTaskDelReq() </li><li>函数原型：INT8U OSTaskDelReq( INT8U prio ) //待删除任务的优先级别 </li><li>提出删除任务请求的调用参数：prio</li></ul><p>查询任务信息 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INT8U <span class="title">OSTaskQuery</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">INT8U prio, <span class="comment">//待查任务的优先级别 </span></span></span></span><br><span class="line"><span class="function"><span class="params">OS_TCB *pdata <span class="comment">//存储任务信息的结构 </span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="uC-OS-II的初始化和任务的启动"><a href="#uC-OS-II的初始化和任务的启动" class="headerlink" title="uC/OS-II的初始化和任务的启动"></a>uC/OS-II的初始化和任务的启动</h2><p>uC/OS-II的初始化（ OSInit() ） </p><ul><li>对所有的全局变量和数据结构进行初始化</li><li>创建空闲任务OSTaskIdle，并赋之以最低优先级和永远的就绪状态</li><li>如果常数 OS_TASK_STAT_EN = 1，则以优先级别为 OS_LOWEST_PRIO - 1 来创建统计任务 </li><li>OSInit() 对数据结构初始化 <ul><li>主要是创建包括空任务控制快链表在内的 5 个空数据缓冲区 <ul><li>空任务控制块链表</li><li>空队列控制块链表</li><li>空事件控制块链表</li><li>空标志组链表</li><li>空内存控制块链表</li></ul></li><li>创建数组 OSTCBPrioTbl[OS_LOWEST_PRIO+1]</li></ul></li></ul><h1 id="第三章-uC-OS-II的中断和时钟"><a href="#第三章-uC-OS-II的中断和时钟" class="headerlink" title="第三章 uC/OS-II的中断和时钟"></a>第三章 uC/OS-II的中断和时钟</h1><p><strong>中断响应过程</strong></p><ul><li>系统接收到中断请求后，这时如果CPU处于中断允许状态（即中断是开放的），系统就会中止正在运行的当前任务，而按照中断向量的指向转而去运行中断服务子程序；</li><li>当中断服务子程序的运行结束后，系统将会根据情况返回到被中止的任务继续运行或者转向运行另一个具有更高优先级别的就绪任务。</li></ul><p><strong>临界段</strong><br>在应用程序中经常有些代码段必须不受任何干扰地连续运行，这样的代码段叫做临界段</p><p><strong>时钟中断</strong></p><ul><li>uC/OS-II 用硬件定时器产生周期为毫秒级的周期性中断来实现时钟，最小时钟单位叫<em>时钟节拍</em></li><li>时钟节拍中断服务程序 OSTickISR（）</li><li>调用时钟节拍服务函数 OSTimeTick（）完成：<ul><li>给计数器 OSTime 加 1</li><li>遍历所有 TCB，将它们的 OSTCBDly 减 1</li><li>若 OSTCBDly 为 0，且任务未被挂起，将其置为就绪态并相应的修改就绪表</li></ul></li></ul><p><strong>延时函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">OSTimeDly(INT16U ticks);   <span class="comment">//参数 ticks 以时钟节拍数为单位的延时时间</span></span><br><span class="line"></span><br><span class="line">OSTimeDlyHMSM( </span><br><span class="line">INT8U hours,    <span class="comment">//时</span></span><br><span class="line">INT8U minutes,  <span class="comment">//分</span></span><br><span class="line">INT8U seconds,  <span class="comment">//秒</span></span><br><span class="line">INT8U milli,    <span class="comment">//毫秒</span></span><br><span class="line">)；</span><br><span class="line"></span><br><span class="line">INT8U OSTimeDlyResume（INT8U prio）;  <span class="comment">//取消任务延时</span></span><br></pre></td></tr></table></figure><h1 id="第四章-任务的同步与通信"><a href="#第四章-任务的同步与通信" class="headerlink" title="第四章 任务的同步与通信"></a>第四章 任务的同步与通信</h1><p><strong>任务同步</strong><br>为实现任务间的合作和无冲突运行，各任务间需建立制约关系。有两种制约关系：</p><ul><li>直接制约关系：源于任务间的合作</li><li>间接制约关系：源于对资源的共享/竞争</li></ul><p>任务间这种制约性的合作运行机制叫做任务间的<em>同步</em>，系统中的同步是依靠任务间互发消息来保证的！</p><p><strong>事件</strong><br>在 uC/OS-II 中，使用信号量、邮箱（消息邮箱）和消息队列这些被称为<strong>事件</strong>的中间环节来实现任务之间的通信。</p><ul><li><em>信号量</em> 是一类事件，使用它是为了建立一个标志来表示某共享资源被占用的情况</li><li>用来传递消息缓冲区指针的数据结构叫做<em>消息邮箱</em></li><li>可传递多个消息的数据结构叫做<em>消息队列</em></li></ul><p><strong>事件控制块</strong><br>uC/OS-II 使用 <em>事件控制块</em> ECB 的数据结构来描述诸如信号量、邮箱（消息邮箱）和消息队列这类事件</p><p><img src="ECB.png" alt="事件控制块 ECB"></p><p>采用类似于任务就绪表的 <em>任务等待表</em> 来完成对等待事件的任务的记录与排序</p><ul><li>等待时限记录在 TCB 成员 OSTCBDly 中；</li><li>当有任务的时限已到时，将其从任务等待表中删除，并设置任务就续表，使其进入就绪状态；</li></ul><p><em>空事件控制块链表</em>：uC/OS-II 初始化时，函数 OSInit() 创建 OS_MAX_EVENTS 个空事件控制块并借用成员 OSEventPtr 将它们链接成一个单向链表</p><ul><li>当新创建一个事件时，从该空事件控制块链表取下一个空 ECB 并对其初始化</li><li>当删除一个事件时，将事件的 ECB 归还给空事件控制块链表</li></ul><p><strong>信号量及其操作</strong><br>信号量两部分组成：</p><ul><li>信号量计数器</li><li>任务等待表</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建信号量 </span></span><br><span class="line"><span class="function">OS_EVENT * <span class="title">OSSemCreate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">       INT16U cnt <span class="comment">// 信号量计数器初值</span></span></span></span><br><span class="line"><span class="function"><span class="params">       )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求信号量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OSSemPend</span> <span class="params">(OS_EVENT *pevent,  <span class="comment">//信号量的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                INT16U timeout,   <span class="comment">//等待时限</span></span></span></span><br><span class="line"><span class="function"><span class="params">                INT8U *err  <span class="comment">//错误信息</span></span></span></span><br><span class="line"><span class="function"><span class="params">               )</span></span>;    </span><br><span class="line"><span class="comment">// 信号量请求函数 OSSemAccept() 允许任务在信号量无效时不进入等待状态而继续运行</span></span><br><span class="line"><span class="function">INT16U <span class="title">OSSemAccept</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">   OS_EVENT * pevent <span class="comment">//信号量的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">   )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送信号量</span></span><br><span class="line"><span class="function">INT8U <span class="title">OSSemPost</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">OS_EVENT * pevent <span class="comment">//信号量的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>优先级反转</strong></p><ul><li>定义：在可剥夺型内核中，当某任务以独占方式共享资源时，会出现低优先级任务先于高优先级任务而被运行的现 象，这叫做优先级反转</li><li>产生优先级反转的原因：一个低优先级的任务在获得了信号量使用共享资源时，被具有较高优先级的任务打断而不能释放信号量，从而使正在等待这个信号量的更高优先级的任务因得不到信号量而被迫处于等待状态。在这个等待期间，就让优先级别低于它而高于占据信号量的任务的任务先运行</li><li>对系统的影响：优先级反转极大的恶化了高优先级任务的运行环境，是实时系统所无法容忍的</li></ul><p><img src="priority_inversion.png"></p><ul><li>根本原因：使用信号量的任务能否运行受到 <em>任务的优先级别</em> 和 <em>是否占有信号量</em> 两个条件的约束</li><li><strong>互斥型信号量</strong>是一个二值信号量，解决任务在使用独占式资源出现的优先级反转问题</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建互斥信号量</span></span><br><span class="line"><span class="function">OS_EVENT *<span class="title">OSMutexCreate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                        INT8U prio, <span class="comment">// 优先级别</span></span></span></span><br><span class="line"><span class="function"><span class="params">                        INT8U * err <span class="comment">// 错误信息</span></span></span></span><br><span class="line"><span class="function"><span class="params">                        )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求互斥型信号量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OSMutexPend</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                OS_EVENT * pevent, <span class="comment">//互斥型信号量指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                INT16U timeout, <span class="comment">//等待时限</span></span></span></span><br><span class="line"><span class="function"><span class="params">                INT8U * err <span class="comment">//错误信息</span></span></span></span><br><span class="line"><span class="function"><span class="params">                )</span></span>;</span><br><span class="line"><span class="comment">// 也可调用 OSMutexAccept() 无等待的请求信号量</span></span><br><span class="line"><span class="function">INT8U <span class="title">OSMutexAccept</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                    OS_EVENT * pevent, <span class="comment">//互斥型信号量指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    INT8U * err <span class="comment">//错误信息</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    )</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送互斥型信号量</span></span><br><span class="line"><span class="function">INT8U <span class="title">OSMutexPost</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                    OS_EVENT * pevent <span class="comment">//互斥型信号量指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    )</span></span>;</span><br></pre></td></tr></table></figure><p><strong>消息邮箱及其操作</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建消息邮箱</span></span><br><span class="line"><span class="function">OS_EVENT * <span class="title">OSMboxCreate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">void</span> * msg <span class="comment">// 消息指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                        )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向邮箱发送消息</span></span><br><span class="line"><span class="function">INT8U <span class="title">OSMboxPost</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                OS_EVENT * pevent, <span class="comment">//消息邮箱指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">void</span> * msg <span class="comment">//消息指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求消息邮箱</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">OSMboxPend</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                OS_EVENT * pevent, <span class="comment">//请求消息邮箱指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                INT16U timeout, <span class="comment">//等待时限</span></span></span></span><br><span class="line"><span class="function"><span class="params">                INT8U * err <span class="comment">//错误信息</span></span></span></span><br><span class="line"><span class="function"><span class="params">                )</span></span>; </span><br><span class="line"><span class="comment">// 也可调用 OSMboxAccept() 无等待请求邮箱</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">OSMboxAccept</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                    OS_EVENT * pevent <span class="comment">//消息邮箱指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    )</span></span>; </span><br></pre></td></tr></table></figure><p><strong>消息队列及其操作</strong></p><ul><li>消息队列包含：事件控制块、消息队列、消息</li><li>消息队列的核心是<em>消息指针数组</em></li><li>向指针数组插入消息指针有两种方式：FIFO 和  LIFO</li><li>uC/OS-II 初始化时，创建由 OS_MAX_QS 个队列控制块组成的 <em>空队列控制块链表</em></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建消息队列</span></span><br><span class="line"><span class="function">OS_EVENT <span class="title">OSQCreate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">void</span> * * start, <span class="comment">//指针数组的地址</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    INT16U size <span class="comment">//数组长度</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求消息队列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">OSQPend</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                OS_EVENT * pevent, <span class="comment">//所请求的消息队列的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                INT16U timeout, <span class="comment">//等待时限</span></span></span></span><br><span class="line"><span class="function"><span class="params">                INT8U * err <span class="comment">//错误信息</span></span></span></span><br><span class="line"><span class="function"><span class="params">                )</span></span>;</span><br><span class="line"><span class="comment">// 调用函数 OSQAccept() 可以无等待的请求队列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">OSQAccept</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                OS_EVENT * pevent <span class="comment">//所请求的消息队列的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向消息队列发送消息</span></span><br><span class="line"><span class="comment">// 以 FIFO 方式组织消息队列</span></span><br><span class="line"><span class="function">INT8U <span class="title">OSQPost</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                OS_EVENT * pevent, <span class="comment">//消息队列的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">void</span> * msg <span class="comment">//消息指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                )</span></span>;</span><br><span class="line"><span class="comment">// 以LIFO方式组织消息队列</span></span><br><span class="line"><span class="function">INT8U <span class="title">OSQPostFront</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                    OS_EVENT * pevent, <span class="comment">//消息队列的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">void</span> * msg <span class="comment">//消息指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    )</span></span>;</span><br></pre></td></tr></table></figure><p><strong>例  4 -9 （ P180 ）</strong></p><p><img src="%E4%BE%8B4-9.png" alt="例 4 - 9"></p><p>任务优先级：S&gt;M&gt;Y，后进先出方式发送消息<br>0 秒开始 S 依次发送了s0、s100、s1，延时 1 秒，M 请求消息队列输出 s1，延时 1 秒，Y 请求消息，输出 s100，延时 1 秒，1 秒时，S又发送了 s100 和 s1，同样 M Y 依次请求消息队列，输出 s1 s100，2 秒时，S 没有发送，延时 1 秒，M请求消息队列，输出 s0，Y 没有请求到等待，N 秒时，三个任务都就绪，S发送 s500延时 1 秒，M 请求消息队列，输出 s500，延时1 秒，N+1 秒时，Y 请求消息队列输出 s500，M 等待，N+2 秒时，M 请求消息队列输出 s500，Y 等待。。。</p><h1 id="第五章-信号量集"><a href="#第五章-信号量集" class="headerlink" title="第五章 信号量集"></a>第五章 信号量集</h1><p><strong>信号量集由两部分组成：</strong></p><ul><li>标志组：存放了信号量集中的所有信号</li><li>等待任务链表：每个节点都对应一个正在等待信号量集的等待任务</li></ul><p>uC/OS-II 初始化时，系统创建 OS_MAX_FLAGS 个标志组，并将其连接成一个<em>空标志组链表</em></p><p><strong>信号量集的操作</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建信号量集</span></span><br><span class="line"><span class="function">OS_FLAG_GRP * <span class="title">OSFlagCreate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                            OS_FLAGS flags; <span class="comment">// 信号量的初始值</span></span></span></span><br><span class="line"><span class="function"><span class="params">                            INT8U * err     <span class="comment">// 错误信息</span></span></span></span><br><span class="line"><span class="function"><span class="params">                            )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求信号量集</span></span><br><span class="line"><span class="function">OS_FLAGS <span class="title">OSFlagPend</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                    OS_FLAG_GRP * pgrp, <span class="comment">// 所请求的信号量集的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    OS_FLAGS flags, <span class="comment">// 滤波器</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    INT8U wait_type, <span class="comment">// 逻辑运算类型</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    INT16U timeout, <span class="comment">// 等待时限</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    INT8U *err         <span class="comment">// 错误信息</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    )</span></span>;</span><br><span class="line"><span class="comment">// 无等待请求信号量集</span></span><br><span class="line"><span class="function">OS_FLAGS <span class="title">OSFlagAccept</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                    OS_FLAG_GRP * pgrp, <span class="comment">// 所请求的信号量集的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    OS_FLAGS flags, <span class="comment">// 滤波器</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    INT8U wait_type, <span class="comment">// 逻辑运算类型</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    INT8U *err         <span class="comment">// 错误信息</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向信号量集发信号</span></span><br><span class="line"><span class="function">OS_FLAGS <span class="title">OSFlagPost</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                    OS_FLAG_GRP * pgrp, <span class="comment">//信号量集的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    OS_FLAGS flags, <span class="comment">//选择要发送的信号</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    INT8U opt, <span class="comment">//信号有效的选项</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    INT8U *err <span class="comment">//错误信息</span></span></span></span><br><span class="line"><span class="function"><span class="params">                )</span></span>;</span><br></pre></td></tr></table></figure><p><strong>例 5 - 1 （ P195 ）</strong><a href="https://github.com/gzwangu/uCOS-II-semaphore-set">源代码</a></p><p><img src="%E4%BE%8B5-1.png"></p><p><img src="%E4%BE%8B5-11.jpg" alt="例 5 - 1"></p><p>任务优先级 MyTask &gt; YouTask &gt; HerTask</p><p>任务开始 MyTask 优先级最高请求不到信号量集处于等待状态，YouTask 开始运行，输出 S2，延时 8 秒，接着 HerTask 连续运行，输出 8 个 S3，第 8 秒时，YouTask 运行发送信号量集，这时两个任务都发送了信号，发送完被高优先级 MyTask 打断，MyTask 输出 S1 延时 2 秒，接着 YouTask 继续运行，延时两秒，HerTask 输出 S3 延时 1 秒，到第 9 秒后，HerTask 输出 S3 延时 1 秒，第10 秒，MyTask 输出 S1 延时 2 秒，YouTask 输出 S2，延时 8 秒，HerTask 输出 S3 延时 1 秒…</p><p>把 MyTask 修改为无等待请求信号量集 OSFlagAccept()<br><img src="%E4%BE%8B5-2.png" alt="例 5 - 2"></p><h1 id="第六章-内存的动态分配"><a href="#第六章-内存的动态分配" class="headerlink" title="第六章 内存的动态分配"></a>第六章 内存的动态分配</h1><p><strong>内存的两级管理</strong><br>把一个连续的内存空间分成若干个分区，每个分区又分成了若干大小相等的内存块来管理</p><p><strong>动态内存的管理</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建动态内存分区</span></span><br><span class="line"><span class="function">OS_MEM * <span class="title">OSMemCreate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">void</span> * addr, <span class="comment">//内存分区的起始地址</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    INT32U nblks, <span class="comment">//分区中内存块的数目</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    INT32U blksize, <span class="comment">//每个内存块的字节数</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    INT8U * err <span class="comment">//错误信息</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求获得一个内存块</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">OSMemGet</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                OS_MEM * pmem, <span class="comment">//内存分区的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                INT8U * err <span class="comment">//错误信息</span></span></span></span><br><span class="line"><span class="function"><span class="params">                )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放一个内存块</span></span><br><span class="line"><span class="function">INT8U <span class="title">OSMemPut</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                OS_MEM * pmem, <span class="comment">//内存块所属内存分区的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">void</span> * pblk <span class="comment">//待释放内存块的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                )</span></span>;</span><br></pre></td></tr></table></figure><p><img src="%E4%BE%8B6-1.png" alt="例 6 - 1"></p><h1 id="第七章-在51单片机上移植-uCOS-II"><a href="#第七章-在51单片机上移植-uCOS-II" class="headerlink" title="第七章 在51单片机上移植 uCOS-II"></a>第七章 在51单片机上移植 uCOS-II</h1><p><strong>可重入函数</strong><br>在多任务操作系统中，系统提供的函数应该能允许同时被多个任务所调用，而不会通过函数中变量的耦合引起任务之间的互相干扰。</p><p><strong>系统堆栈</strong><br>片内RAM中的公用堆栈，只存放运行的任务堆栈</p><p><strong>任务堆栈映象</strong><br>片外RAM中用来存放任务堆栈内容的区域</p><p><strong>系统堆栈与任务堆栈映象的关系</strong></p><ul><li>51 单片机要求堆栈必须设置在片内RAM中，51单片机的片内 RAM 极其有限，不可能把应用程序中所有任务的任务堆栈都设置在片内RAM中</li><li>解决办法：把应用程序中各个任务堆栈的内容存放在片外RAM中的任务堆栈映象中，而只在片内 RAM 中设置一个公用的系统堆栈</li></ul><h1 id="第八章-在ARM7上移植uCOS-II"><a href="#第八章-在ARM7上移植uCOS-II" class="headerlink" title="第八章 在ARM7上移植uCOS-II"></a>第八章 在ARM7上移植uCOS-II</h1><p><strong>工作模式的选择映像</strong></p><p>系统模式和用户模式</p><p><strong>处理器相关的移植文件</strong></p><ul><li>OS_CPU.H</li><li>OS_CPU_C.C</li><li>OS_CPU_A.S</li></ul><p>如果你看到这，恭喜这本书的主要内容已经掌握了，考试肯定不是问题，下面分享下干货！</p><h1 id="干货"><a href="#干货" class="headerlink" title="干货"></a>干货</h1><p><strong>这是老师给的知识点总结：</strong></p><p>第2章 uC/OS-II中的任务<br>1、任务的基本概念<br>2、任务堆栈<br>3、任务控制块<br>4、任务就续表及其操作<br>5、任务调度、任务切换<br>6、任务调度器函数OSSched()<br>7、任务创建<br>8、任务的挂起和恢复<br>9、请求删除任务函数<br>10、任务初始化</p><p>第3章 uC/OS-II的中断和时钟<br>1、中断响应过程<br>2、临界段的概念<br>3、时钟中断<br>4、延时函数</p><p>第4章 任务的同步与通信<br>1、任务同步<br>2、事件<br>3、事件控制块<br>4、事件的操作（创建、发送、请求）<br>5、优先级反转<br>6、相关例题（例8、例9）</p><p>第5章 信号量集<br>1、信号量集<br>2、信号量集的操作（创建、请求和发送）<br>3、相关例题（例1）</p><p>第6章 内存的动态分配<br>1、内存的管理<br>2、内存分区的组织<br>3、动态内存的管理（创建、请求、释放）（例1、例2）</p><p>第7章 在51单片机上移植uCOS-II<br>1、可重入函数<br>2、系统堆栈和任务堆栈</p><p>第8章 在ARM7上移植uCOS-II<br>1、工作模式的选择映像<br>2、与处理器相关的移植文件</p><p><strong>在此基础上本人详细的罗列了一些考点：</strong></p><p>任务组成<br>两种系统任务<br>64个任务<br>任务5中状态<br>OS_LOWEST_PRIO<br>堆栈增长方向，影响 OSTaskCreate 函数任务堆栈栈顶指针参数  P66<br>OSTCBPrioTbl 数组：以任务的优先级为下标，保存任务的任务控制块指针的数组<br>任务就绪表操作：登记、注销、最高优先级就绪任务查找  会写<br>为什么管理64个任务：OSRdyTbl[ ] 有8个数组元素，每个元素都是8位二进制数，可表示8个任务的就绪状态，所以系统最多可以管理8x8=64个任务<br>OSSched() 函数代码加黑部分要会写 P77<br>任务切换7个步 P79<br>挂起自身  OXFF<br>删除任务过程：提出删除任务请求的任务调用请求删除任务函数，改变联络信号值，当被删除任务查到信号值改变，会在适当的时候删除自身。<br>初始化5个链表：空任务控制块链表、空事件控制块链表、空队列控制块链表、空标志组链表、空内存控制块链表</p><p>中断响应过程<br>OSTimeTick 做的三件事  PPT上有，书上说了 2 件，其实也是 3 件<br>OSTimeTick 代码懂且能写出来<br>两个延时函数  OSTimeDly 和 OSTimeDlyHMSM</p><p>事件（信号量、消息邮箱、消息队列）的操作（创建、请求、发送）  能看懂代码<br>优先级反转：定义、过程、解决方法（使用互斥信号量）<br>例8  例9   会分析解释  时间轴法</p><p>信号量集的操作<br>例1  会分析解释</p><p>内存二级管理<br>例1、2  看懂会写吧</p><p>可重入函数定义<br>系统/任务堆栈</p><p>用户模式/系统模式<br>3个移植文件：OS_CPU.H、OS_CPU_C.C、OS_CPU_A.S</p><p><strong>最后个干货，中国矿业大学2019-2020 第一学期嵌入式操作系统 A 卷：</strong></p><p>一、简答题（50分）</p><ol><li>任务的分类</li><li>可以管理多少任务？从 OSRdyTbl[ ] 解释之</li><li>给一个 prio = 29，注销操作，哪一位置 0</li><li>中断响应过程</li><li>能否使用全局变量来实现任务间的通信? 如果可以，有什么缺点?</li></ol><p>二、程序填空（20分，会给注释）</p><ol><li>任务的创建源代码</li><li>OSSched() 函数</li><li>OSTimeTick() 函数</li><li>写信号量集的请求的例子</li></ol><p>三、综合（30分，都是书上的例子）</p><ol><li>任务挂起与恢复</li><li>消息队列</li></ol>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> uC/OS-II </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于树莓派的人脸识别门禁系统</title>
      <link href="2020/04/25/%E5%9F%BA%E4%BA%8E%E6%A0%91%E8%8E%93%E6%B4%BE%E7%9A%84%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E9%97%A8%E7%A6%81%E7%B3%BB%E7%BB%9F/"/>
      <url>2020/04/25/%E5%9F%BA%E4%BA%8E%E6%A0%91%E8%8E%93%E6%B4%BE%E7%9A%84%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E9%97%A8%E7%A6%81%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>本文介绍了家庭门禁管理系统的一种设计方案，基于旷视云平台的人脸识别技术实现了一款智能门禁系统，使用Face++人脸识别进行实时人脸分析，不仅使用便利，而且保证了识别数据的有效性和准确性，系统分为硬件和软件两个部分，硬件以树莓派4B为控制核心，外接摄像头、步进电机、蜂鸣器、触摸开关等模块；软件部分基于旷视云平台，构建了在不同操作环境下信息管理与控制系统，通过应用场景模拟对系统进行试验，结果表明：该系统运行可靠，外接模块以及系统电路运行良好，识别准确率高，电机响应平均时间为0.5s，消息远程收发功能、信息管理与控制系统的相关功能均可正常执行。</p><h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="课题背景"><a href="#课题背景" class="headerlink" title="课题背景"></a>课题背景</h2><p>随着计算机网络技术的发展成熟，在给我们带来便捷的同时，也带来了运用高新技术手段进性偷盗、抢劫等违法犯罪问题，家庭安全问题越来越受到人们的重视，现代人工智能的安防领域也有了极大的突破和进展，出现了各种身份识别方法。其中最热门的、被关注最多的就是人脸识别，而人脸识别算法也从过去单一的模式识别到如今的多算法提取，从二维平面图像到多维建模生物识别。人脸识别技术凭借其自身的实用性及可靠性得到了广泛的认可，对采用人脸识别方式作为门禁管理系统的小区而言，不仅可以将社区管理提高一个档次、同时节省许多管理成本，而且能够有效地保障社区安全。此外近年来，基于Linux的单片机计算机也已逐渐发展成熟，并以其低价、自由的特点被广泛使用。因此本文将人脸识别与嵌入式、树莓派等相融合，设计出一套高安全级别的门禁管理系统。</p><h2 id="设计任务与要求"><a href="#设计任务与要求" class="headerlink" title="设计任务与要求"></a>设计任务与要求</h2><p>（1）以家庭智能门禁系统为背景，通过调研、分析现有的门禁系统，建立系统模型；完成软硬件结构设计和数据库设计；</p><p>（2）系统要实现智能开关门、记录门禁信息、远程控制和人员管理等功能；</p><p>（3）系统要实现满足多种条件的统计分析功能，有些统计数据要采用图表的格式呈现；</p><p>（4）系统要具有安全性、准确性和高效率，能够改善传统安防领域的方便性、直观性；</p><h1 id="系统设计需求分析"><a href="#系统设计需求分析" class="headerlink" title="系统设计需求分析"></a>系统设计需求分析</h1><h2 id="开发环境及开发平台"><a href="#开发环境及开发平台" class="headerlink" title="开发环境及开发平台"></a>开发环境及开发平台</h2><p>Windows10操作系统、Visual Studio Code编译器（Python 3.8）、FinalShell SSH工具、windows远程桌面连接；</p><p>Raspbian操作系统、Thonny 编译器（Python 3.6）；</p><h2 id="系统的组成及工作原理"><a href="#系统的组成及工作原理" class="headerlink" title="系统的组成及工作原理"></a>系统的组成及工作原理</h2><p>系统主要有两大部分组成：硬件部分和软件部分。硬件主要包括树莓派主控设备、触摸开关、图像采集设备、警报设备和步进电机模块。软件主要有基于Flask框架的web可视化界面。</p><p>当有人触摸开关时，触发人脸识别主函数进行实时拍照并将此照片发送至Face++云服务中心进行分析，云服务得出上传图像的人脸参数，并把参数跟已经预存在人脸数据库中的面部信息进行比对，将比对结果传回到树莓派．确认识别成功后控制步进电机转动，若人脸不匹配则触发警报，同时记录下本次的识别数据。</p><p><img src="raspberrypi.png" alt="系统组成实物图"> </p><h2 id="设计的重点与难点"><a href="#设计的重点与难点" class="headerlink" title="设计的重点与难点"></a>设计的重点与难点</h2><p>本系统设计重点在于人脸检测分析及人脸比对、系统整体软硬件架构；</p><p>难点有硬件设备的安装与调试、前端网页的设计与代码编写，frp 可用于内网穿透的高性能的反向代理应用，使用frp实现内网穿透远程实时监控。Face++的人脸库数据操作有两种方式，一种直接在Face++云的控制中心上传，另一种是通过代码的方式进行操作．第一种方式虽然可以直接使用，但对于用户来说，整个操作过程还是较为繁琐．为方便对云平台人脸数据库进行管理，需要建立一个用户管理系统界面。</p><h1 id="系统的总体设计"><a href="#系统的总体设计" class="headerlink" title="系统的总体设计"></a>系统的总体设计</h1><h2 id="系统功能层次图"><a href="#系统功能层次图" class="headerlink" title="系统功能层次图"></a>系统功能层次图</h2><p><img src="systemoverall.png" alt="系统功能层次图"> </p><h2 id="系统功能描述"><a href="#系统功能描述" class="headerlink" title="系统功能描述"></a>系统功能描述</h2><p>基于树莓派的人脸识别门禁系统硬件主要包括树莓派主控设备、图像采集设备、触摸模块、步进电机模块和警报模块。本文的智能门禁系统设计具有半自动的特点，系统运行时树莓派会将采集到的面部图像发送至云端服务中心进行分析，云端服务中心得出上传图像的人脸参数，并把参数跟已经预存在人脸数据库中的面部信息进行比对，得到相似度结果，然后再将得到的数据从云端反馈回下位机主控设备。触摸传感器触发人脸识别主函数进行实时拍照并将此照片发送至云服务中心处理并将比对结果传回到树莓派。确认识别成功后控制步进电机转动，并将结果显示在树莓派终端，否则触发警报模块，同时记录下本次的识别数据。Web客户端可远程查看实时监控画面、人员管理（增加和删除人脸）、查看门禁记录和开关门操作等功能</p><h1 id="系统的模块设计"><a href="#系统的模块设计" class="headerlink" title="系统的模块设计"></a>系统的模块设计</h1><h2 id="界面（UI）设计"><a href="#界面（UI）设计" class="headerlink" title="界面（UI）设计"></a>界面（UI）设计</h2><h3 id="界面布局示意图"><a href="#界面布局示意图" class="headerlink" title="界面布局示意图"></a>界面布局示意图</h3><p><img src="login.png" alt="登录界面"> </p><p><img src="main.png" alt="主界面"> </p><p><img src="record.png" alt="门禁记录界面"> </p><p><img src="family.png" alt="家庭成员界面"> </p><h3 id="界面控件（或部件）设计"><a href="#界面控件（或部件）设计" class="headerlink" title="界面控件（或部件）设计"></a>界面控件（或部件）设计</h3><p>主要设计四个界面：登录界面、主界面、门禁记录界面和人员管理界面。</p><p>登录界面主要包括用户名及密码输入，登录按钮；</p><p>主界面有显示实时监控画面、退出登录按钮、开关门按钮、人员管理按钮和门禁记录按钮；</p><p>人员管理界面主要有家庭成员列表，增加或删除家庭人员等控件；</p><p>门禁记录界面显示刷门禁的时间日期、人脸相似度、人脸名和姓名；</p><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><h3 id="E-R图"><a href="#E-R图" class="headerlink" title="E-R图"></a>E-R图</h3><p><img src="E-R.png" alt="E-R 图"> </p><h3 id="数据库表结构"><a href="#数据库表结构" class="headerlink" title="数据库表结构"></a>数据库表结构</h3><p><img src="datebase.png" alt="数据库结构表"> </p><p>此系统的数据库设计比较简单，采用腾讯云的 MySQL 数据库，仅需要一个数据库表来记录门禁信息，门禁信息包括时间日期、人脸符记、相似度、人脸名和姓名，其中时间日期是主键。人脸信息的保存并不在此数据库中，Face++ 提供的 API 接口可直接增加和删除人脸，预存人脸也是在 Face++ 的云服务器上，极大的便利了人脸信息的存储，同时也更利于人脸搜索，减少系统响应时间。</p><h2 id="主控模块设计"><a href="#主控模块设计" class="headerlink" title="主控模块设计"></a>主控模块设计</h2><h3 id="程序流程图"><a href="#程序流程图" class="headerlink" title="程序流程图"></a>程序流程图</h3><p><img src="main-contorl.png" alt="主控程序流程图"> </p><h3 id="系统功能描述-1"><a href="#系统功能描述-1" class="headerlink" title="系统功能描述"></a>系统功能描述</h3><p>循环检测触摸开关有无产生高电平，若有则拍照并保存本地，接着调用人脸检测程序将原始的图片以二进制形式上传至Face++云服务，待上传完成之后，若检测到人脸，接着调用人脸搜索API云服务会返回人脸的相似度[7]，主控模块将对返回的结果进行比对判断。如果对比成功，则驱动步进电机开始旋转，否则触发警报模块。最终识别记录信息会上传到腾讯云端数据库，方便获取和查看。</p><h2 id="触发模块设计"><a href="#触发模块设计" class="headerlink" title="触发模块设计"></a>触发模块设计</h2><p>触发模块是一个基于触摸检测 IC (TTP223B) 的电容式点动型触摸开关模块。默认状态输出低电平，模式为低功耗模式；当用手指触摸相应位置时，模块会输出高电平，再次触摸又恢复低电平。模式切换为快速模式；当持续12秒没有触摸时,模式又切换为低功耗模式。</p><h3 id="程序流程图-1"><a href="#程序流程图-1" class="headerlink" title="程序流程图"></a>程序流程图</h3><p><img src="trigger.png" alt="触发模块程序流程图"> </p><h3 id="系统功能描述-2"><a href="#系统功能描述-2" class="headerlink" title="系统功能描述"></a>系统功能描述</h3><p>为了将电平信号传递给主控模块，在每次调用触发模块之前，需要将代码中连接触摸开关 OUT 引脚的 GPIO 设置为 INPUT 模式。程序启动后触摸模块循环检测，当检测到手指触摸时输出高电平给树莓派，如果没有检测到触摸则循环检测直到程序退出。</p><h2 id="拍照模块设计"><a href="#拍照模块设计" class="headerlink" title="拍照模块设计"></a>拍照模块设计</h2><p>本文采用树莓派专用 500W 像素摄像头(含 CSI 接口排线)作为拍照模块,该拍照模块由 OmniVision 公司生产(基于 0V5647 图像处理传感模块)为树莓派 4B 开发板生产的专用拍照模块，兼容性更加优良。</p><p>该拍照模块的核心元件是一个 500w 像素的 CMOS 传感器,支持最大分辨率为 2592X1944 的图片拍摄,同样支持每秒30帧的 1080p 视频拍摄(同时兼容每秒 60 帧的 720P 视频拍摄)。拍照模块与主控模块通过一条 15 芯的排线( CSI 接口)进行连接。具体连接过程如下：先将主控模块上 CSI 接口两端的卡扣拉起，然后将排线插入座中，最后垂直按下两端的卡扣。</p><p>该拍照模块内部提供三个应用程序,分别为：raspistill、raspivid、raspisillyuv，其中 raspivid 用来捕捉视频，raspistill 及 raspistillyuv 则用来捕捉图像。</p><p>应用程序使用了四个 OpenMAX（mmal）组件：camera (摄像)、preview(预览)、encoder (编码)、null_sink。 以上三个应用程序均使用摄像组件, raspivid 使用视频编码组件，raspistill 使用图像编码组件，由于 raspistillyuv 是直接将 YUV 或 RGB 从摄像组件输出到文件，所以不需要编码组件。使用 OpenMAX 的 mmal API 为所有程序进行编写且通过命令行的方式进行调用。本文的设计将通过调用 OpenCV 内部函数的方式进行拍照。</p><h3 id="程序流程图-2"><a href="#程序流程图-2" class="headerlink" title="程序流程图"></a>程序流程图</h3><p><img src="picamera.png" alt="拍照模块程序流程图"> </p><h3 id="系统功能描述-3"><a href="#系统功能描述-3" class="headerlink" title="系统功能描述"></a>系统功能描述</h3><p>初次进入系统将拍照模块功能设置为 enabled (打开)，以便程序调用。在本次的设计中，程序调用 OpenCV 进行拍照处理。当拍照模块的拍照服务启动时将采集的图片保存为 jpg 格式，然后等待下次调用。</p><h2 id="驱动模块设计"><a href="#驱动模块设计" class="headerlink" title="驱动模块设计"></a>驱动模块设计</h2><p>主控模块的 GPIO 口驱动能力相对较弱，驱动电平仅为 3.3V,所以高电平驱动比低电平驱动能力稍弱些。当主控模块直接将输入信号传递给步进电机时，步进电机无法正常工作，所以在本次设计中需要添加一个驱动模块。驱动模块具有放大功率的作用,可以满足在输入信号比较微弱、输出功率比较高的情况下工作。</p><p>步进电机对输入电流需求较高，主控模块的供电能力有限，同时考虑到硬件设计的兼容性，以往的设计常常采用专用接口及驱动电路的方式来解决。驱动电路部分可以采用功率比较高的复合管，例如常见的 ULN2003、L298N 等。驱动模块的工作状态是由主控模块提供的控制信号决定的。在本文驱动模块的电路设计时需要满足以下的要求：</p><p>(1)驱动电路提供的电流波形尽可能的接近矩形波，需要电流的快速上升及快速下降。</p><p>(2)驱动电路输出的功率及运行的效率要求较高，使系统提高运行经济效率。</p><p>经过简单的比对，本文的设计采用 ULN2003 类的驱动 IC (集成电路芯片),该芯片可为步进电机提供小于 0.5A 的电流。</p><p>考虑到门禁系统的实际使用情况，运动过程中不需要加速、减速过程，同.时对转速的要求也比较低，所以将步进电机设置为自启动运行方式。自启动运行方式是指通过控制脉冲速度,从而控制电机的启动和停止的运行方式，该种运行方式不会产生加速或者减速阶段。由于在门禁系统的开启、闭合时需要速度的突然变化，所以需要较大的转矩。同时在实际使用过程中电机有一定的负载，会产生较大的工作噪音,根据常见步进电机的工作特性，只有四相五线式步进电机的满足工作需求。另外考虑到静转矩、步距角、电流、安装难度等多种因素,本文的设计选取 28BYJ4 四相五线式步进电机对门禁系统进行控制。</p><h3 id="程序流程图-3"><a href="#程序流程图-3" class="headerlink" title="程序流程图"></a>程序流程图</h3><p><img src="drive.png" alt="驱动模块程序流程图"> </p><h3 id="系统功能描述-4"><a href="#系统功能描述-4" class="headerlink" title="系统功能描述"></a>系统功能描述</h3><p>驱动步进电机首先设置主控模块相应的引脚为 OUTPUT 模式。当程序中人脸识别检测通过时，主控模块通过驱动模块带动步进电机正转。正转一定的角度后停止，模拟等待人员通过。一段时间后电机反转回到初始位置。</p><h2 id="报警模块设计"><a href="#报警模块设计" class="headerlink" title="报警模块设计"></a>报警模块设计</h2><p>本文设计的是一套完整的门禁系统，报警模块必不可少。本文设计的报警模块由蜂鸣器构成，具体操作流程如下：在程序运行时，触发触摸开关后，每当待检测人员匹配不成功或未检测到人脸，蜂鸣器发出鸣叫。</p><h3 id="程序流程图-4"><a href="#程序流程图-4" class="headerlink" title="程序流程图"></a>程序流程图</h3><p><img src="alarm.png" alt="报警模块程序流程图"> </p><h3 id="系统功能描述-5"><a href="#系统功能描述-5" class="headerlink" title="系统功能描述"></a>系统功能描述</h3><p>蜂鸣器首先设置主控模块相应的引脚为 OUTPUT 模式。当程序中人脸识别检测未通过时，主控模块通过报警模块发出警报，检测通过则触发驱动模块。</p><h1 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h1><h2 id="系统简介"><a href="#系统简介" class="headerlink" title="系统简介"></a>系统简介</h2><p>基于树莓派的人脸识别门禁系统，采用云平台的方式进行人脸识别，可以很大程度上的提高设备的识别效率，使人脸识别技术的应用更加可行，在微机上利用云平台来搭建人脸识别系统，能够使该技术的应用范围变得更广。同时还具有 Web 客户端可方便操作，实时监控家庭画面，远程控制家庭门禁开关，自带警报功能，查看历史门禁记录以及对家庭成员进行管理，可新增、删除或更新人脸信息，使智能门禁系统成为现实。该系统有功耗低、视频流延迟小和响应快的特点，能够改善传统安防领域的安全性、方便性、直观性等。</p><h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><table><thead><tr><th>硬件环境</th><th>应用服务器</th><th>数据库服务器</th><th align="left">客户端</th></tr></thead><tbody><tr><td>硬件配置</td><td>CPU：ARM Cortex-A72 CPU 1.5GHz 四核 64-bit     Memory：4GB</td><td>CPU: Intel(R) Xeon(R) CPU 2394.440 MHZ         Memory：2GB</td><td align="left">CPU: Intel(R) Core(TM) i7-7500 <a href="mailto:&#67;&#x50;&#x55;&#64;&#50;&#x2e;&#x37;&#x30;&#x47;&#72;&#x7a;">&#67;&#x50;&#x55;&#64;&#50;&#x2e;&#x37;&#x30;&#x47;&#72;&#x7a;</a> 2.90 GHz                       Memory: 8GB</td></tr><tr><td>软件配置</td><td>OS: Raspbian  4.18              Flask 1.1.1                       Python 3.7</td><td>OS: Ubuntu  16.04.1          MySQL 5.7.26</td><td align="left">OS: Windows10 1909                                                          Google Chrome 81.0</td></tr><tr><td>网络环境</td><td>100M LAN</td><td>1M LAN</td><td align="left">100M LAN</td></tr></tbody></table><h2 id="测试结论"><a href="#测试结论" class="headerlink" title="测试结论"></a>测试结论</h2><p>系统正确实现了智能门禁的功能，实现了远程监控和操作功能，实现了Web界面。实现了门禁数据管理，人员管理，添加，修改，删除的功能，系统还实现了将权限控制细化到菜单按钮的功能。系统在实现用户管理下的权限管理功能时，存在重大的缺陷，权限控制不严密，权限设计有遗漏[13]。</p><p>现有系统实现了如下易用性：查询，添加，删除，修改操作相关提示信息的一致性，可理解性；输入限制的正确性；输入限制提示信息的正确性，可理解性，一致性。</p><p>现有系统的可靠性控制不够严密，很多控制是通过页面控制实现的，如果页面控制失效，可以向数据库插入数据，引发错误。现有系统的容错性不高，如果系统出现错误，返回错误类型为找不到页面错误，无法回复到出错前的状态。</p><h1 id="设计结果及结论"><a href="#设计结果及结论" class="headerlink" title="设计结果及结论"></a>设计结果及结论</h1><p>本文基于树莓派和旷视人脸识别云平台，实现了一个智能门禁系统．在整个场景模拟试验过程中，无异常报错，系统整体呈现出较强的稳定性，通过试验数据可知系统识别率和实时性都达到了设计的预期要求，系统的外接设备在运行过程中响应良好，识别正确率高，识别成功后的电机进行响应的平均时间为 0.5ｓ，消息远程收发功能、信息管理与控制系统的相关功能均可正常执行。</p><p>虽然系统整体表现良好，但还存在的一个较大问题就是系统的交互性体验还有待提高，在后期的改善过程中，可以引入深度学习的概念，通过对用户的门禁系统的使用数据进行分析，在已有的基础上进行功能扩展，提高用户的使用体验,与同类型产品相比较，本系统在不影响识别精度的前提下，降低了开发生产成本，表现出较强的稳定性，可扩展性强，本文详细描述了整个系统的构建和实现方式，能够为树莓派开发、云平台应用和智能安防等相关领域的同类型产品研发提供一种参考方案。</p><p><a href="https://github.com/gzwangu/Raspberry-Pi-Access-Control">项目源代码</a></p>]]></content>
      
      
      <categories>
          
          <category> 课程设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 树莓派 </tag>
            
            <tag> 门禁系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uC/OS-II实验</title>
      <link href="2020/04/25/uCOS-II%E5%AE%9E%E9%AA%8C/"/>
      <url>2020/04/25/uCOS-II%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="多任务调度实验"><a href="#多任务调度实验" class="headerlink" title="多任务调度实验"></a>多任务调度实验</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>编写延时分别为3s、1s和1s的三个任务，观察任务之间的交替运行次序，熟悉任务调度的过程。要求三个任务的输出分别为：M、Y和H，连续不换行显示。</p><h2 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;includes.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK1_PRO     1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK2_PRO     2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK3_PRO     3</span></span><br><span class="line">OS_STK Task1Stk[TASK_STK_SIZE];</span><br><span class="line">OS_STK Task2Stk[TASK_STK_SIZE];</span><br><span class="line">OS_STK Task3Stk[TASK_STK_SIZE];</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Task1</span><span class="params">(<span class="keyword">void</span> *p_arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Task2</span><span class="params">(<span class="keyword">void</span> *p_arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Task3</span><span class="params">(<span class="keyword">void</span> *p_arg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TaskCreate</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">OSTaskCreate(Task1, <span class="literal">NULL</span>, &amp;Task1Stk, TASK1_PRO);</span><br><span class="line">OSTaskCreate(Task2, <span class="literal">NULL</span>, &amp;Task2Stk, TASK2_PRO);</span><br><span class="line">OSTaskCreateExt(Task3, <span class="literal">NULL</span>, &amp;Task3Stk, TASK3_PRO, TASK3_PRO, &amp;Task3Stk[TASK_STK_SIZE - <span class="number">1</span>], TASK_STK_SIZE, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Task1</span><span class="params">(<span class="keyword">void</span> *p_arg)</span></span>&#123;</span><br><span class="line">p_arg = p_arg;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;M&quot;</span>);</span><br><span class="line">OSTimeDlyHMSM(<span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Task2</span><span class="params">(<span class="keyword">void</span> *p_arg)</span></span>&#123;</span><br><span class="line">p_arg = p_arg;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Y&quot;</span>);</span><br><span class="line">OSTimeDlyHMSM(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Task3</span><span class="params">(<span class="keyword">void</span> *p_arg)</span></span>&#123;</span><br><span class="line">p_arg = p_arg;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;H&quot;</span>);</span><br><span class="line">OSTimeDlyHMSM(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p><img src="Scheduling.png" alt="Scheduling"></p><p><img src="analysisScheduling.jpg" alt="analysisScheduling"> </p><h2 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h2><p>第一次对操作系统的代码进行编写调试，深入了解了任务堆栈、创建任务和任务调度，任务间的调度是由cpu在就绪任务中选择最高优先级的任务。调用函数OSStart()之前先创建一个任务，并赋予它最高的优先级别，从而使它成为起始任务。</p><h1 id="利用消息队列进行任务间通信实验"><a href="#利用消息队列进行任务间通信实验" class="headerlink" title="利用消息队列进行任务间通信实验"></a>利用消息队列进行任务间通信实验</h1><h2 id="实验目的-1"><a href="#实验目的-1" class="headerlink" title="实验目的"></a>实验目的</h2><p>仿照《嵌入式实时操作系统uCOS-II原理及应用》（第4版）例4-9，利用先进先出的方式组织消息，由任务一发送消息，任务二和任务三请求消息，三个任务的延时时间均为1s。</p><h2 id="实验代码-1"><a href="#实验代码-1" class="headerlink" title="实验代码"></a>实验代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;includes.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  N_MESSAGES      128<span class="comment">//定义消息队列长度</span></span></span><br><span class="line">OS_STK   TaskStk1[TASK_STK_SIZE];<span class="comment">//定义任务堆栈区</span></span><br><span class="line">OS_STK   TaskStk2[TASK_STK_SIZE];<span class="comment">//定义任务堆栈区</span></span><br><span class="line">OS_STK   TaskStk3[TASK_STK_SIZE];<span class="comment">//定义任务堆栈区</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *ss;</span><br><span class="line"><span class="keyword">char</span> *s100;</span><br><span class="line"><span class="keyword">char</span> *s0;</span><br><span class="line"><span class="keyword">char</span> *s1;</span><br><span class="line"><span class="keyword">char</span> *s500;</span><br><span class="line"><span class="keyword">void</span> *MsgGrp[N_MESSAGES];<span class="comment">//定义消息指针数组</span></span><br><span class="line">INT8U err;</span><br><span class="line"></span><br><span class="line">OS_EVENT *Str_Q;<span class="comment">//定义事件控制块</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">Task1</span><span class="params">(<span class="keyword">void</span> *data)</span></span>;<span class="comment">//声明任务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">Task2</span><span class="params">(<span class="keyword">void</span> *data)</span></span>;<span class="comment">//声明任务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">Task3</span><span class="params">(<span class="keyword">void</span> *data)</span></span>;<span class="comment">//声明任务</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">TaskCreate</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">Str_Q = OSQCreate(&amp;MsgGrp[<span class="number">0</span>], N_MESSAGES);<span class="comment">//创建消息队列</span></span><br><span class="line">OSTaskCreate(Task1,<span class="comment">//创建任务Task1</span></span><br><span class="line">(<span class="keyword">void</span>*)<span class="number">0</span>,<span class="comment">//给任务传递参数</span></span><br><span class="line">&amp;TaskStk1[TASK_STK_SIZE - <span class="number">1</span>],<span class="comment">//设置任务堆栈栈顶</span></span><br><span class="line"><span class="number">0</span>);<span class="comment">//使任务的优先级别为0</span></span><br><span class="line">OSTaskCreate(Task2,<span class="comment">//创建任务Task2</span></span><br><span class="line">(<span class="keyword">void</span>*)<span class="number">0</span>,<span class="comment">//给任务传递参数</span></span><br><span class="line">&amp;TaskStk2[TASK_STK_SIZE - <span class="number">1</span>],<span class="comment">//设置任务堆栈栈顶</span></span><br><span class="line"><span class="number">3</span>);<span class="comment">//使任务的优先级别为3</span></span><br><span class="line">OSTaskCreate(Task3,<span class="comment">//创建任务Task3</span></span><br><span class="line">(<span class="keyword">void</span>*)<span class="number">0</span>,<span class="comment">//给任务传递参数</span></span><br><span class="line">&amp;TaskStk3[TASK_STK_SIZE - <span class="number">1</span>],<span class="comment">//设置任务堆栈栈顶</span></span><br><span class="line"><span class="number">4</span>);<span class="comment">//使任务的优先级别为4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************任务Task1*******************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">Task1</span><span class="params">(<span class="keyword">void</span> *pdata)</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> OS_CRITICAL_METHOD == 3</span></span><br><span class="line">OS_CPU_SR  cpu_sr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">pdata = pdata;</span><br><span class="line">s0 = <span class="string">&quot;这个串能收到几次？&quot;</span>;</span><br><span class="line">OSQPostFront(Str_Q, s0);<span class="comment">//发送消息</span></span><br><span class="line"><span class="keyword">for</span> (;;)&#123;</span><br><span class="line"><span class="keyword">if</span> (OSTimeGet() &gt; <span class="number">0</span> &amp;&amp; OSTimeGet() &lt; <span class="number">200</span>)&#123;<span class="comment">//可以满足两次条件</span></span><br><span class="line">s100 = <span class="string">&quot;现在OSTime的值在0到200之间&quot;</span>;</span><br><span class="line">OSQPostFront(Str_Q, s100);<span class="comment">//发送消息</span></span><br><span class="line">s1 = <span class="string">&quot;这个串是哪个任务收到的？&quot;</span>;</span><br><span class="line">OSQPostFront(Str_Q, s1);<span class="comment">//发送消息</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (OSTimeGet() &gt; <span class="number">2000</span> &amp;&amp; OSTimeGet() &lt; <span class="number">2300</span>)&#123;</span><br><span class="line">s500 = <span class="string">&quot;现在OSTime的值在2000到2300之间&quot;</span>;</span><br><span class="line">OSQPostFront(Str_Q, s500);<span class="comment">//发送消息</span></span><br><span class="line">&#125;</span><br><span class="line">OSTimeDlyHMSM(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);<span class="comment">//等待1秒</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/************************任务Task2*******************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">Task2</span><span class="params">(<span class="keyword">void</span> *pdata)</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> OS_CRITICAL_METHOD == 3</span></span><br><span class="line">OS_CPU_SR  cpu_sr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">pdata = pdata;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;)&#123;</span><br><span class="line">ss = OSQPend(Str_Q, <span class="number">0</span>, &amp;err);  <span class="comment">//请求消息队列                                         </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, ss);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Task2 is running!\n&quot;</span>);</span><br><span class="line">OSTimeDlyHMSM(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);<span class="comment">//等待1秒</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/************************任务Task3******************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">Task3</span><span class="params">(<span class="keyword">void</span> *pdata)</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> OS_CRITICAL_METHOD == 3</span></span><br><span class="line">OS_CPU_SR  cpu_sr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">pdata = pdata;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;)&#123;</span><br><span class="line">ss = OSQPend(Str_Q, <span class="number">0</span>, &amp;err); <span class="comment">//请求消息队列                                          </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, ss);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Task3 is running!\n&quot;</span>);</span><br><span class="line">OSTimeDlyHMSM(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);<span class="comment">//等待1秒</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实验结果-1"><a href="#实验结果-1" class="headerlink" title="实验结果"></a>实验结果</h2><p><img src="Communication.png" alt="Communication"></p><p><img src="analysisCommunication.jpg" alt="analysisCommunication"> </p><h2 id="实验体会-1"><a href="#实验体会-1" class="headerlink" title="实验体会"></a>实验体会</h2><p>通过本次实验进一步掌握了消息队列相当于共用一个任务等待表的消息邮箱数组，向指针数组插入消息指针有两种方式：FIFO和 LIFO，本实验采用的是LIFO（后进先出），任务请求消息队列需要调用函数OSQPend()。</p>]]></content>
      
      
      <categories>
          
          <category> 课程实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> uC/OS-II </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于VHDL的数字秒表设计</title>
      <link href="2020/01/19/%E5%9F%BA%E4%BA%8EVHDL%E7%9A%84%E6%95%B0%E5%AD%97%E7%A7%92%E8%A1%A8%E8%AE%BE%E8%AE%A1/"/>
      <url>2020/01/19/%E5%9F%BA%E4%BA%8EVHDL%E7%9A%84%E6%95%B0%E5%AD%97%E7%A7%92%E8%A1%A8%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>当今社会正朝着电子市场发展，越来越多的电子产品应用于各个领域。数字秒表是日常生活中比较常见的电子产品，常用于体育比赛和时间计时，计时的精准性和稳定性是衡量数字秒表最重要的两个指标。现在市场上的数字秒表基本上都能满足计时准确的要求，但很少能满足计时稳定性的要求。本文设计了一种用于精确计时且计时稳定性高的数字秒表，该设计是在Quartus Ⅱ环境下，基于 VHDL语言来编写的，具有开关、计时和显示功能，其计时精度可达0.01s，计时范围较大，计时稳定性好。该设计具有很强的实用性，有着非常广泛的应用。</p><h1 id="实验选题及目标"><a href="#实验选题及目标" class="headerlink" title="实验选题及目标"></a>实验选题及目标</h1><h2 id="实验选题"><a href="#实验选题" class="headerlink" title="实验选题"></a>实验选题</h2><p>在科技高度发展的今天，集成电路和计算机应用得到了高速发展。尤其是计算机应用的发展，它在人们日常生活中已逐渐崭露头角，大多数电子产品多是有计算机电路组成，如：手机、mp3等。而且将来的不久他们的身影将会频繁的出现在我们身边，各种家用电器多会实现微电脑技术，电脑各部分在工作时多是一时间为基准的。</p><p>本文就是基于计算机电路的时钟脉冲信号、状态控制等原理设计出的数字秒表。秒表在很多领域充当一个重要角色，在各种比赛中对秒表的精确度要求很高，尤其是一些科学实验，他们对时间精确度达到了几纳秒级别。数字秒表具有操作方便、使用简单、计数精准等使用优点，在日常生活中的到了广泛认可和使用。</p><h2 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h2><p>设计一块数字秒表，能够精确反映计时时间，并完成复位、计时功能。秒表的计时范围为0秒~ 59分59.99秒，精度为0.01秒，并可显示计时时间的分、秒、毫秒等度量。</p><p>（1）具有秒表系统功能要求显示功能, 用8个数码管分别显示时、分、秒、毫秒，计时范围为00: 00： 00~ 59: 59：99。 </p><p>（2）数字秒表计时精度是0.01s。</p><p>（3）具有启/ 停开关, 复位开关，复位开关在任何情况下都能使用，使计实清零。</p><h1 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h1><p>根据系统设计要求, 系统的底层设计主要由控制模块、分频模块、计时模块、显示模块四部分组成。系统顶层设计图如图所示：</p><p>图中左边为三个输入信号CLK、CLR、SP分别为时钟信号、复位开关和启/ 停开关。主要模块有：分频模块（CB10），时间计数器(COUNT),复位控制(CONTROL)，数据选择模块(MULX),译码器(BCD7)。右边为五个输出信号LED、OUTBCD、SEG、CO、EN分别为七段式LED码值、输出时间值、数码管位选、分频信号和使能信号。</p><p>由模10计数器模块与模6计数器模块进行计数；实验室仪器可产生标准的50mHz的时钟信号，通过分频器模块产生所需的1kHz的时钟信号；复位模块可进行计数器复位操作；译码器是为了将四位二进制信号转换为LED所需的七位二进制编码；状态变换模块是为了用户按键后信号的变换及保持。</p><p><img src="RTL.png" alt="RTL图"></p><h1 id="实验开发环境与器材"><a href="#实验开发环境与器材" class="headerlink" title="实验开发环境与器材"></a>实验开发环境与器材</h1><p>Quartus Ⅱ 9.1和FPGA器件EP2C35F484C8</p><h1 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h1><h2 id="CB10-vhd"><a href="#CB10-vhd" class="headerlink" title="CB10.vhd"></a>CB10.vhd</h2><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LIBRARY</span> IEEE;</span><br><span class="line"><span class="keyword">USE</span> IEEE.STD_LOGIC_1164.<span class="keyword">ALL</span>;</span><br><span class="line"><span class="keyword">USE</span> IEEE.STD_LOGIC_UNSIGNED.<span class="keyword">ALL</span>;</span><br><span class="line"><span class="keyword">ENTITY</span> CB10 <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">PORT</span>(CLK : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC</span>; </span><br><span class="line"> CO : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC</span>);</span><br><span class="line"><span class="keyword">END</span> CB10;</span><br><span class="line"><span class="keyword">ARCHITECTURE</span> one <span class="keyword">OF</span> CB10 <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">SIGNAL</span> CNTER : <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">15</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">PROCESS</span>(CLK)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">IF</span>(RISING_EDGE(CLK)) <span class="keyword">THEN</span> </span><br><span class="line"><span class="keyword">IF</span> CNTER = <span class="string">&quot;1100001101001111&quot;</span> <span class="keyword">THEN</span>   <span class="comment">--49999</span></span><br><span class="line">CNTER&lt;=<span class="string">&quot;0000000000000000&quot;</span>;</span><br><span class="line">CO&lt;=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line">CNTER&lt;=CNTER+<span class="number">1</span>;</span><br><span class="line">CO&lt;=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">PROCESS</span>;</span><br><span class="line"><span class="keyword">END</span> one;</span><br></pre></td></tr></table></figure><h2 id="CONTROL-vhd"><a href="#CONTROL-vhd" class="headerlink" title="CONTROL.vhd"></a>CONTROL.vhd</h2><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LIBRARY</span> IEEE;</span><br><span class="line"><span class="keyword">USE</span> IEEE.STD_LOGIC_1164.<span class="keyword">ALL</span>;</span><br><span class="line"><span class="keyword">USE</span> IEEE.STD_LOGIC_UNSIGNED.<span class="keyword">ALL</span>;</span><br><span class="line"><span class="keyword">ENTITY</span> CONTROL <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">PORT</span>(CLR,CLK,SP : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC</span>;</span><br><span class="line"> EN : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC</span>);</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"><span class="keyword">ARCHITECTURE</span> one <span class="keyword">OF</span> CONTROL <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">TYPE</span> STATES <span class="keyword">IS</span> (S0,S1,S2,S3);</span><br><span class="line"><span class="keyword">SIGNAL</span> CURRENT_STATE,NEXT_STATE:STATES;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">COM:<span class="keyword">PROCESS</span>(SP,CURRENT_STATE)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">CASE</span> CURRENT_STATE <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">WHEN</span> S0=&gt; EN&lt;=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">IF</span> SP=<span class="string">&#x27;1&#x27;</span> <span class="keyword">THEN</span> </span><br><span class="line">NEXT_STATE&lt;=S1;</span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line">NEXT_STATE&lt;=S0;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"><span class="keyword">WHEN</span> S1=&gt; EN&lt;=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"><span class="keyword">IF</span> SP=<span class="string">&#x27;1&#x27;</span> <span class="keyword">THEN</span> </span><br><span class="line">NEXT_STATE&lt;=S1;</span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line">NEXT_STATE&lt;=S2;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"><span class="keyword">WHEN</span> S2=&gt; EN&lt;=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"><span class="keyword">IF</span> SP=<span class="string">&#x27;1&#x27;</span> <span class="keyword">THEN</span> </span><br><span class="line">NEXT_STATE&lt;=S3;</span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line">NEXT_STATE&lt;=S2;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"><span class="keyword">WHEN</span> S3=&gt; EN&lt;=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">IF</span> SP=<span class="string">&#x27;1&#x27;</span> <span class="keyword">THEN</span> </span><br><span class="line">NEXT_STATE&lt;=S3;</span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line">NEXT_STATE&lt;=S0;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">CASE</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">PROCESS</span>;</span><br><span class="line">REG:<span class="keyword">PROCESS</span>(CLK)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">IF</span> CLR=<span class="string">&#x27;1&#x27;</span> <span class="keyword">THEN</span></span><br><span class="line">CURRENT_STATE&lt;=S0;</span><br><span class="line"><span class="keyword">ELSIF</span> CLK<span class="symbol">&#x27;EVENT</span> <span class="keyword">AND</span> CLK=<span class="string">&#x27;1&#x27;</span> <span class="keyword">THEN</span></span><br><span class="line">CURRENT_STATE&lt;=NEXT_STATE;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">PROCESS</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><h2 id="CDU10-vhd"><a href="#CDU10-vhd" class="headerlink" title="CDU10.vhd"></a>CDU10.vhd</h2><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LIBRARY</span> IEEE;</span><br><span class="line"><span class="keyword">USE</span> IEEE.STD_LOGIC_1164.<span class="keyword">ALL</span>;</span><br><span class="line"><span class="keyword">USE</span> IEEE.STD_LOGIC_UNSIGNED.<span class="keyword">ALL</span>;</span><br><span class="line"><span class="keyword">ENTITY</span> CDU10 <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">PORT</span>(CLK,CLR,EN : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC</span>;</span><br><span class="line"> CN : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC</span>;</span><br><span class="line"> COUNT10 : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>));</span><br><span class="line"><span class="keyword">END</span> CDU10;</span><br><span class="line"><span class="keyword">ARCHITECTURE</span> one <span class="keyword">OF</span> CDU10 <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">SIGNAL</span> SCOUNT10 : <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">COUNT10&lt;=SCOUNT10;</span><br><span class="line"><span class="keyword">PROCESS</span>(CLK,CLR,EN)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">IF</span> CLR=<span class="string">&#x27;1&#x27;</span> <span class="keyword">THEN</span></span><br><span class="line">SCOUNT10&lt;=<span class="string">&quot;0000&quot;</span>;</span><br><span class="line">CN&lt;=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">ELSIF</span> RISING_EDGE(CLK) <span class="keyword">THEN</span></span><br><span class="line"><span class="keyword">IF</span> EN=<span class="string">&#x27;1&#x27;</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="keyword">IF</span> SCOUNT10=<span class="string">&quot;1001&quot;</span> <span class="keyword">THEN</span> </span><br><span class="line">CN&lt;=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">SCOUNT10&lt;=<span class="string">&quot;0000&quot;</span>;</span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line">CN&lt;=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">SCOUNT10&lt;=SCOUNT10+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">PROCESS</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><h2 id="CDU6-vhd"><a href="#CDU6-vhd" class="headerlink" title="CDU6.vhd"></a>CDU6.vhd</h2><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LIBRARY</span> IEEE;</span><br><span class="line"><span class="keyword">USE</span> IEEE.STD_LOGIC_1164.<span class="keyword">ALL</span>;</span><br><span class="line"><span class="keyword">USE</span> IEEE.STD_LOGIC_UNSIGNED.<span class="keyword">ALL</span>;</span><br><span class="line"><span class="keyword">ENTITY</span> CDU6 <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">PORT</span>(CLK : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC</span>;</span><br><span class="line"> CLR : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC</span>;</span><br><span class="line"> EN : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC</span>;</span><br><span class="line"> CN : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC</span>;</span><br><span class="line"> COUNT6 : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>));</span><br><span class="line"><span class="keyword">END</span> CDU6;</span><br><span class="line"><span class="keyword">ARCHITECTURE</span> one <span class="keyword">OF</span> CDU6 <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">SIGNAL</span> SCOUNT6 : <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">COUNT6&lt;=SCOUNT6;</span><br><span class="line"><span class="keyword">PROCESS</span>(CLK,CLR,EN)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">IF</span> CLR=<span class="string">&#x27;1&#x27;</span> <span class="keyword">THEN</span></span><br><span class="line">SCOUNT6&lt;=<span class="string">&quot;0000&quot;</span>;</span><br><span class="line">CN&lt;=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">ELSIF</span> RISING_EDGE(CLK) <span class="keyword">THEN</span></span><br><span class="line"><span class="keyword">IF</span> EN=<span class="string">&#x27;1&#x27;</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="keyword">IF</span> SCOUNT6=<span class="string">&quot;0101&quot;</span> <span class="keyword">THEN</span> </span><br><span class="line">CN&lt;=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">SCOUNT6&lt;=<span class="string">&quot;0000&quot;</span>;</span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line">CN&lt;=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">SCOUNT6&lt;=SCOUNT6+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">PROCESS</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><h2 id="COUNT-vhd"><a href="#COUNT-vhd" class="headerlink" title="COUNT.vhd"></a>COUNT.vhd</h2><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LIBRARY</span> IEEE;</span><br><span class="line"><span class="keyword">USE</span> IEEE.STD_LOGIC_1164.<span class="keyword">ALL</span>;</span><br><span class="line"><span class="keyword">ENTITY</span> COUNT <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">PORT</span>(CLK,CLR,EN : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC</span>;</span><br><span class="line"> MS_1MS : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> MS_10MS : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> MS_100MS : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> S_1S : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> S_10S : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> M_1MIN : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> M_10MIN : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> HOUR : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>));</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"><span class="keyword">ARCHITECTURE</span> one <span class="keyword">OF</span> COUNT <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">COMPONENT</span> CDU10</span><br><span class="line"><span class="keyword">PORT</span>(CLK,CLR,EN : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC</span>;</span><br><span class="line"> CN : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC</span>;</span><br><span class="line"> COUNT10 : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>));</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">COMPONENT</span> CDU10;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMPONENT</span> CDU6</span><br><span class="line"><span class="keyword">PORT</span>(CLK,CLR,EN : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC</span>;</span><br><span class="line"> CN : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC</span>;</span><br><span class="line"> COUNT6 : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>));</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">COMPONENT</span> CDU6;</span><br><span class="line"><span class="keyword">SIGNAL</span> A,B,C,D,E,F,G,H : <span class="built_in">STD_LOGIC</span>;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">U1:CDU10 <span class="keyword">PORT</span> <span class="keyword">MAP</span>(CLK=&gt;CLK,CLR=&gt;CLR,EN=&gt;EN,CN=&gt;A,COUNT10=&gt;MS_1MS);</span><br><span class="line">U2:CDU10 <span class="keyword">PORT</span> <span class="keyword">MAP</span>(CLK=&gt;A,CLR=&gt;CLR,EN=&gt;EN,CN=&gt;B,COUNT10=&gt;MS_10MS);</span><br><span class="line">U3:CDU10 <span class="keyword">PORT</span> <span class="keyword">MAP</span>(CLK=&gt;B,CLR=&gt;CLR,EN=&gt;EN,CN=&gt;C,COUNT10=&gt;MS_100MS);</span><br><span class="line">U4:CDU10 <span class="keyword">PORT</span> <span class="keyword">MAP</span>(CLK=&gt;C,CLR=&gt;CLR,EN=&gt;EN,CN=&gt;D,COUNT10=&gt;S_1S);</span><br><span class="line">U5:CDU6  <span class="keyword">PORT</span> <span class="keyword">MAP</span>(CLK=&gt;D,CLR=&gt;CLR,EN=&gt;EN,CN=&gt;E,COUNT6=&gt;S_10S);</span><br><span class="line">U6:CDU10 <span class="keyword">PORT</span> <span class="keyword">MAP</span>(CLK=&gt;E,CLR=&gt;CLR,EN=&gt;EN,CN=&gt;F,COUNT10=&gt;M_1MIN);</span><br><span class="line">U7:CDU6  <span class="keyword">PORT</span> <span class="keyword">MAP</span>(CLK=&gt;F,CLR=&gt;CLR,EN=&gt;EN,CN=&gt;G,COUNT6=&gt;M_10MIN);</span><br><span class="line">U8:CDU10 <span class="keyword">PORT</span> <span class="keyword">MAP</span>(CLK=&gt;G,CLR=&gt;CLR,EN=&gt;EN,CN=&gt;H,COUNT10=&gt;HOUR);</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><h2 id="MUXL-vhd"><a href="#MUXL-vhd" class="headerlink" title="MUXL.vhd"></a>MUXL.vhd</h2><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LIBRARY</span> IEEE;</span><br><span class="line"><span class="keyword">USE</span> IEEE.STD_LOGIC_1164.<span class="keyword">ALL</span>;</span><br><span class="line"><span class="keyword">USE</span> IEEE.STD_LOGIC_UNSIGNED.<span class="keyword">ALL</span>;</span><br><span class="line"><span class="keyword">ENTITY</span> MULX <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">PORT</span>(CLK,CLR,EN : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC</span>;</span><br><span class="line"> MS_1MS : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> MS_10MS : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> MS_100MS : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> S_1S : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> S_10S : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> M_1MIN : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> M_10MIN : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> HOUR : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> OUTBCD : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> SEG : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">7</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>));</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"><span class="keyword">ARCHITECTURE</span> one <span class="keyword">OF</span> MULX <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">SIGNAL</span> COUNT:<span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">PROCESS</span>(CLK)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">IF</span> CLR = <span class="string">&#x27;1&#x27;</span> <span class="keyword">THEN</span></span><br><span class="line">COUNT&lt;=<span class="string">&quot;1111&quot;</span>;</span><br><span class="line"><span class="keyword">ELSIF</span> RISING_EDGE(CLK) <span class="keyword">THEN</span></span><br><span class="line"><span class="keyword">IF</span> EN=<span class="string">&#x27;1&#x27;</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="keyword">IF</span> COUNT=<span class="string">&quot;0111&quot;</span> <span class="keyword">THEN</span></span><br><span class="line">COUNT&lt;=<span class="string">&quot;0000&quot;</span>;</span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line">COUNT&lt;=COUNT+<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">PROCESS</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">PROCESS</span>(CLK)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">IF</span> CLK<span class="symbol">&#x27;EVENT</span> <span class="keyword">AND</span> CLK=<span class="string">&#x27;1&#x27;</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="keyword">CASE</span> COUNT <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">&quot;0000&quot;</span> =&gt; OUTBCD&lt;=MS_1MS; SEG&lt;=<span class="string">&quot;11111110&quot;</span>;</span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">&quot;0001&quot;</span> =&gt; OUTBCD&lt;=MS_10MS; SEG&lt;=<span class="string">&quot;11111101&quot;</span>;</span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">&quot;0010&quot;</span> =&gt; OUTBCD&lt;=MS_100MS; SEG&lt;=<span class="string">&quot;11111011&quot;</span>;</span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">&quot;0011&quot;</span> =&gt; OUTBCD&lt;=S_1S; SEG&lt;=<span class="string">&quot;11110111&quot;</span>;</span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">&quot;0100&quot;</span> =&gt; OUTBCD&lt;=S_10S; SEG&lt;=<span class="string">&quot;11101111&quot;</span>;</span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">&quot;0101&quot;</span> =&gt; OUTBCD&lt;=M_1MIN; SEG&lt;=<span class="string">&quot;11011111&quot;</span>;</span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">&quot;0110&quot;</span> =&gt; OUTBCD&lt;=M_10MIN; SEG&lt;=<span class="string">&quot;10111111&quot;</span>;</span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">&quot;0111&quot;</span> =&gt; OUTBCD&lt;=HOUR; SEG&lt;=<span class="string">&quot;01111111&quot;</span>;</span><br><span class="line"><span class="keyword">WHEN</span> <span class="keyword">OTHERS</span> =&gt; OUTBCD&lt;=<span class="string">&quot;0000&quot;</span>; SEG&lt;=<span class="string">&quot;00000000&quot;</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">CASE</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">PROCESS</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><h2 id="BCD7-vhd"><a href="#BCD7-vhd" class="headerlink" title="BCD7.vhd"></a>BCD7.vhd</h2><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LIBRARY</span> IEEE;</span><br><span class="line"><span class="keyword">USE</span> IEEE.STD_LOGIC_1164.<span class="keyword">ALL</span>;</span><br><span class="line"><span class="keyword">USE</span> IEEE.STD_LOGIC_UNSIGNED.<span class="keyword">ALL</span>;</span><br><span class="line"><span class="keyword">ENTITY</span> BCD7 <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">PORT</span>(BCD: <span class="keyword">IN</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> LED: <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">6</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>));</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"><span class="keyword">ARCHITECTURE</span> one <span class="keyword">OF</span> BCD7 <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line">LED &lt;= <span class="string">&quot;1111110&quot;</span> <span class="keyword">WHEN</span> BCD =<span class="string">&quot;0000&quot;</span> <span class="keyword">ELSE</span></span><br><span class="line">   <span class="string">&quot;0110000&quot;</span> <span class="keyword">WHEN</span> BCD =<span class="string">&quot;0001&quot;</span> <span class="keyword">ELSE</span></span><br><span class="line">   <span class="string">&quot;1101101&quot;</span> <span class="keyword">WHEN</span> BCD =<span class="string">&quot;0010&quot;</span> <span class="keyword">ELSE</span></span><br><span class="line">   <span class="string">&quot;1111001&quot;</span> <span class="keyword">WHEN</span> BCD =<span class="string">&quot;0011&quot;</span> <span class="keyword">ELSE</span></span><br><span class="line">   <span class="string">&quot;0110011&quot;</span> <span class="keyword">WHEN</span> BCD =<span class="string">&quot;0100&quot;</span> <span class="keyword">ELSE</span></span><br><span class="line">   <span class="string">&quot;1011011&quot;</span> <span class="keyword">WHEN</span> BCD =<span class="string">&quot;0101&quot;</span> <span class="keyword">ELSE</span></span><br><span class="line">   <span class="string">&quot;1011111&quot;</span> <span class="keyword">WHEN</span> BCD =<span class="string">&quot;0110&quot;</span> <span class="keyword">ELSE</span></span><br><span class="line">   <span class="string">&quot;1110000&quot;</span> <span class="keyword">WHEN</span> BCD =<span class="string">&quot;0111&quot;</span> <span class="keyword">ELSE</span></span><br><span class="line">   <span class="string">&quot;1111111&quot;</span> <span class="keyword">WHEN</span> BCD =<span class="string">&quot;1000&quot;</span> <span class="keyword">ELSE</span></span><br><span class="line">   <span class="string">&quot;1111011&quot;</span> <span class="keyword">WHEN</span> BCD =<span class="string">&quot;1001&quot;</span> <span class="keyword">ELSE</span></span><br><span class="line">   <span class="string">&quot;0000000&quot;</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><h2 id="Stopwatch-vhd"><a href="#Stopwatch-vhd" class="headerlink" title="Stopwatch.vhd"></a>Stopwatch.vhd</h2><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LIBRARY</span> IEEE;</span><br><span class="line"><span class="keyword">USE</span> IEEE.STD_LOGIC_1164.<span class="keyword">ALL</span>;</span><br><span class="line"><span class="keyword">ENTITY</span> Stopwatch <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">PORT</span>(SP,CLR,CLK :<span class="keyword">IN</span> <span class="built_in">STD_LOGIC</span>;</span><br><span class="line"> CO,EN : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC</span>;</span><br><span class="line"> LED : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">6</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> OUTBCD : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> SEG : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">7</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>));</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"><span class="keyword">ARCHITECTURE</span> ONE <span class="keyword">OF</span> Stopwatch <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">COMPONENT</span> CONTROL </span><br><span class="line"><span class="keyword">PORT</span>(CLR,CLK,SP : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC</span>;</span><br><span class="line"> EN : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC</span>);</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">COMPONENT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMPONENT</span> CB10</span><br><span class="line"><span class="keyword">PORT</span>(CLK : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC</span>;</span><br><span class="line"> CO : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC</span>);</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">COMPONENT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMPONENT</span> COUNT </span><br><span class="line"><span class="keyword">PORT</span>(CLK,CLR,EN : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC</span>;</span><br><span class="line"> MS_1MS : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> MS_10MS : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> MS_100MS : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> S_1S : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> S_10S : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> M_1MIN : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> M_10MIN : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> HOUR : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>));</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">COMPONENT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMPONENT</span> BCD7</span><br><span class="line"><span class="keyword">PORT</span>(BCD: <span class="keyword">IN</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> LED: <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">6</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>));</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">COMPONENT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMPONENT</span> MULX</span><br><span class="line"><span class="keyword">PORT</span>(CLK,CLR,EN : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC</span>;</span><br><span class="line"> MS_1MS : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> MS_10MS : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> MS_100MS : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> S_1S : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> S_10S : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> M_1MIN : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> M_10MIN : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> HOUR : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> OUTBCD : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> SEG : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">7</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>));</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">COMPONENT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SIGNAL</span> C,E : <span class="built_in">STD_LOGIC</span>;</span><br><span class="line"><span class="keyword">SIGNAL</span> MS1,MS10,MS100 : <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"><span class="keyword">SIGNAL</span> S1,S10 : <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>); </span><br><span class="line"><span class="keyword">SIGNAL</span> MIN1,MIN10 : <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);  </span><br><span class="line"><span class="keyword">SIGNAL</span> HR : <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);    </span><br><span class="line"><span class="keyword">SIGNAL</span> BCD_S : <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);  </span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">U0 : CONTROL <span class="keyword">PORT</span> <span class="keyword">MAP</span>(CLR=&gt;CLR,CLK=&gt;CLK,SP=&gt;SP,EN=&gt;E);</span><br><span class="line">U1 : CB10 <span class="keyword">PORT</span> <span class="keyword">MAP</span>(CLK=&gt;CLK,CO=&gt;C);</span><br><span class="line">U2 : COUNT <span class="keyword">PORT</span> <span class="keyword">MAP</span>(CLK=&gt;C,CLR=&gt;CLR,EN=&gt;E,MS_1MS=&gt;MS1,MS_10MS=&gt;MS10,MS_100MS=&gt;MS100,S_1S=&gt;S1,S_10S=&gt;S10,M_1MIN=&gt;MIN1,M_10MIN=&gt;MIN10,HOUR=&gt;HR);</span><br><span class="line">U3 : MULX <span class="keyword">PORT</span> <span class="keyword">MAP</span>(CLK=&gt;CLK,CLR=&gt;CLR,EN=&gt;E,MS_1MS=&gt;MS1,MS_10MS=&gt;MS10,MS_100MS=&gt;MS100,S_1S=&gt;S1,S_10S=&gt;S10,M_1MIN=&gt;MIN1,M_10MIN=&gt;MIN10,HOUR=&gt;HR,OUTBCD=&gt;BCD_S,SEG=&gt;SEG);</span><br><span class="line">U4 : BCD7 <span class="keyword">PORT</span> <span class="keyword">MAP</span>(BCD=&gt;BCD_S,LED=&gt;LED);</span><br><span class="line">CO&lt;=C;</span><br><span class="line">EN&lt;=E;</span><br><span class="line">OUTBCD&lt;=BCD_S;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><h1 id="实验流程与步骤"><a href="#实验流程与步骤" class="headerlink" title="实验流程与步骤"></a>实验流程与步骤</h1><p>根据系统设计要求, 系统的构成主要由时基分频模块、控制模块、计时模块、显示模块四部分组成，采用自顶向下的方式设计这些模块，系统构成框图如图所示。</p><p> (1) 时基分频模块<br>该分频模块就是把系统工作频率分频后当做定时器的工作频率，例如系统时钟为50MHz，50000分频后定时器的工作时钟为1kHz。</p><p> (2) 控制模块<br>该功能模块是通过对模块的VHDL 程序编译来生成模块的功能元器件，其中<br>VHDL程序采用状态机描述的方式，状态都采用符号化状态。模块的元器件有三个输入端和一个输出端，其中输入端信号为时钟信号CLK、控制信号SP和复位信号CLR。输入信号SP用于控制计数模块的计时状态，在VHDL程序中设置计时模块有四种状态，分别为s0、s1、s2 和 s3，其中 状态s0是保持态，s1是启动态，s2是计数态，s3是停止态。 输出端为使能信号EN，它是高电平有效。整个程序可分为两个进程来分别描述状态转化机和寄存器操作。在VHDL程序中设置输入信号SP变化时计时模块所对应的状态。通过该设置使得系统可通过控制输入信号SP的值来决定计时模块所处的状态。</p><p>（3）计时模块<br>计时模块共需要2个六进制计数器和6个十进制计数器。其中六进制计数器和十进制计数器的描述方法几乎完全一样。考虑到级联的需要，两个计时器除了时钟输入CLK和异步清零CLR之外，另外设计了计数使能输入端EN，该使能端用于控制计时模块是否工作。</p><p>（4）显示模块<br>数据选择的作用是为了选择计时模块每个位置的数字，并将其对应的数字输出，并设置一个位置标志位来显示输出数字为计时数据的哪一位。显示模块用于显示数据选择器输出端BCD的数据，该显示模块采用的是七段译码器的编译码规则，将ASCII 数据转化为对应的七段译码器数据。计时显示电路的实现方案采用扫描显示，即每次只驱动一位数码管，各位数据轮流驱动对应的数码管进行显示。</p><p><img src="block.png" alt="系统构成框图"></p><h1 id="实验结果与分析"><a href="#实验结果与分析" class="headerlink" title="实验结果与分析"></a>实验结果与分析</h1><p>数字秒表系统各个模块及整体仿真图如下：</p><p>（1）时基分频模块仿真</p><p><img src="CB10.png" alt="时基分频模块仿真图"></p><p>CLK是时钟脉冲输入端，CO为分频后信号输出端。由FPGA器件内部50mHZ的时钟脉冲产生秒表需要的1kHZ时钟频率，需要对50mHZ进行50000分频。</p><p>（2）控制模块仿真</p><p>控制模块采用高效的状态机控制，模块有四种状态，分别为s0、s1、s2 和 s3，其中 状态s0是保持态，s1是启动态，s2是计数态，s3是停止态。异步清零，秒表在任何时候都能执行清零操作，SP来控制秒表的开始或关闭。</p><p><img src="CONTROL.png" alt="控制模块仿真图"></p><p>（3）计时模块仿真</p><p>①十进制计数器仿真</p><p><img src="CDU10.png" alt="十进制计数器仿真图"></p><p>图中可以看出十进制计数器的计数功能正常，从0计到9后回0，清零时立即从0开始计时。</p><p>②六进制计数器仿真</p><p><img src="CDU6.png" alt="六进制计数器仿真图"></p><p>图中可以看出六进制计数器的计数功能正常，从0计到5后回0，清零时立即从0开始计时。</p><p>③计时器仿真</p><p><img src="COUNT.png" alt="计时器仿真图"></p><p>计时器功能正常，能够准确计时ms、10ms、100ms、1s、10s、1min、10min、hour位。</p><p>（4）显示模块仿真</p><p>①数据选择器仿真</p><p>数据选择模块选择计时模块每个位置的数字，并将其对应的数字输出，并设置一个位置标志位来显示输出数字为计时数据的哪一位。</p><p><img src="MULX.png" alt="数据选择器仿真图"></p><p>②BCD七段译码器仿真</p><p><img src="BCD7.png" alt="BCD七段译码器仿真图"></p><p>（5）秒表系统仿真</p><p><img src="STOPWATCH.png" alt="秒表系统仿真图"></p><p>秒表系统仿真正常，从ms位到hour位依次刷新扫描，百进制和六十进制正常，异步清零复位正常，系统整体运行良好。由仿真结果可以看出系统具有计时和显示功能，且满足计时精度为10ms，计时范围为0 ～ 59 分 59.99 秒的设计要求，同时计时稳定性高。</p><h1 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h1><p>VHDL作为一种标准硬件描述语言，它除了含有许多具有硬件特征的语句外，其语言形式和描述风格与句法类似一般的计算机高级语言。VHDL有着与其它语言截然不同的地方，那就是它的互动性很强。因为语言的复杂，老师想要教会我们去用这门语言，光是看书或者PPT是不够的，那样在脑海中的印象并不深刻，所以老师让我们尽量带自己的电脑去上课，在课堂上可以跟着老师一起做。 </p><p>通过这次课程设计，我了解到了一些自身的不足：对于模块功能想象力不足，模块设计也总是错误百出，粗心大意是永远会出现的。一开始，感觉数字秒表的功能模块应该很清晰，模块之间的联系很密切，同时，觉得自己对于这种简易电子设备的内部结构应该很熟悉。可是，到了真正操作的时候才发现自己想得太简单了。虽然数字秒表就是些简单的计数器的综合，但是每个计数器的设计也是需要懂很多知识的。而且秒表有复位功能，要考虑到复位时同步清零，清零后还要保持在零的状态，清零是用户进行的操纵，需要有外部输入，又要想暂停、启动的控制，这样就需要状态机的模块进行使能端、清零端的状态转换。这些虽然只是细枝末节，但是真正的编程的成功因素很大一部分都是取决于这些细节。</p><h1 id="附录-VERILOG"><a href="#附录-VERILOG" class="headerlink" title="附录(VERILOG)"></a>附录(VERILOG)</h1><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line">CB10<span class="variable">.v</span></span><br><span class="line"><span class="keyword">module</span> CB10(clk,co);</span><br><span class="line"><span class="keyword">input</span> clk;</span><br><span class="line"><span class="keyword">output</span> co;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] cnter;</span><br><span class="line"><span class="keyword">reg</span> co;</span><br><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span> (cnter==<span class="number">4&#x27;b1001</span>) </span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">cnter = <span class="number">0</span>;</span><br><span class="line">co = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">cnter = cnter + <span class="number">1</span>;</span><br><span class="line">co = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line">CONTROL<span class="variable">.v</span></span><br><span class="line"><span class="keyword">module</span> CONTROL(clk,rst,sp,en);</span><br><span class="line"><span class="keyword">input</span> clk,rst,sp;</span><br><span class="line"><span class="keyword">output</span> en;</span><br><span class="line"><span class="keyword">reg</span> en;</span><br><span class="line"><span class="keyword">parameter</span> s0=<span class="number">0</span>,s1=<span class="number">1</span>,s2=<span class="number">2</span>,s3=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] c_st,n_st;</span><br><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> rst)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span>(rst)</span><br><span class="line">c_st = s0;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">c_st = n_st;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">always</span>@(c_st,sp)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">case</span>(c_st)</span><br><span class="line">s0:<span class="keyword">begin</span> en = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(sp==<span class="number">1</span>)</span><br><span class="line">n_st = s1;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">n_st = s0; <span class="keyword">end</span></span><br><span class="line">s1:<span class="keyword">begin</span> en = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(sp==<span class="number">1</span>)</span><br><span class="line">n_st = s1;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">n_st = s2; <span class="keyword">end</span></span><br><span class="line">s2:<span class="keyword">begin</span> en = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(sp==<span class="number">1</span>)</span><br><span class="line">n_st = s3;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">n_st = s2; <span class="keyword">end</span></span><br><span class="line">s0:<span class="keyword">begin</span> en = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(sp==<span class="number">1</span>)</span><br><span class="line">n_st = s3;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">n_st = s0; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line">CDU10<span class="variable">.v</span></span><br><span class="line"><span class="keyword">module</span> CDU10(clk,rst,en,cn,count10);</span><br><span class="line"><span class="keyword">input</span> clk,rst,en;</span><br><span class="line"><span class="keyword">output</span> cn;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] count10;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] count;</span><br><span class="line"><span class="keyword">reg</span> cn;</span><br><span class="line"><span class="keyword">assign</span> count10 = count;</span><br><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk,<span class="keyword">posedge</span> rst)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span>(rst) <span class="keyword">begin</span></span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line">cn = <span class="number">0</span>; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(en) <span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span>(count==<span class="number">4&#x27;b1001</span>) <span class="keyword">begin</span></span><br><span class="line">cn = <span class="number">1</span>;</span><br><span class="line">count = <span class="number">0</span>; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">cn = <span class="number">0</span>;</span><br><span class="line">count = count+<span class="number">1</span>; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line">CDU6<span class="variable">.v</span></span><br><span class="line"><span class="keyword">module</span> CDU6(clk,rst,en,cn,count6);</span><br><span class="line"><span class="keyword">input</span> clk,rst,en;</span><br><span class="line"><span class="keyword">output</span> cn;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] count6;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] count;</span><br><span class="line"><span class="keyword">reg</span> cn;</span><br><span class="line"><span class="keyword">assign</span> count6 = count;</span><br><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk,<span class="keyword">posedge</span> rst)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span>(rst) <span class="keyword">begin</span></span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line">cn = <span class="number">0</span>; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(en) <span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span>(count==<span class="number">4&#x27;b0101</span>) <span class="keyword">begin</span></span><br><span class="line">cn = <span class="number">1</span>;</span><br><span class="line">count = <span class="number">0</span>; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">cn = <span class="number">0</span>;</span><br><span class="line">count = count+<span class="number">1</span>; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line">TIMER<span class="variable">.v</span></span><br><span class="line"><span class="keyword">module</span> TIMER(clk,rst,en,ms1,ms10,ms100,s1,s10,m1,m10,hour);</span><br><span class="line"><span class="keyword">input</span> clk,rst,en;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] ms1,ms10,ms100,s1,s10,m1,m10,hour;</span><br><span class="line"><span class="keyword">wire</span> a,b,c,d,e,f,g,h;</span><br><span class="line">CDU10 u1(clk,rst,en,a,ms1);</span><br><span class="line">CDU10 u2(a,rst,en,b,ms10);</span><br><span class="line">CDU10 u3(b,rst,en,c,ms100);</span><br><span class="line">CDU10 u4(c,rst,en,d,s1);</span><br><span class="line">CDU6 u5(d,rst,en,e,s10);</span><br><span class="line">CDU10 u6(e,rst,en,f,m1);</span><br><span class="line">CDU6 u7(f,rst,en,g,m10);</span><br><span class="line">CDU10 u8(g,rst,en,h,hour);</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line">MUXL<span class="variable">.v</span></span><br><span class="line"><span class="keyword">module</span> MUXL(clk,rst,en,ms1,ms10,ms100,s1,s10,m1,m10,hour,bcd,seg);</span><br><span class="line"><span class="keyword">input</span> clk,rst,en;</span><br><span class="line"><span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] ms1,ms10,ms100,s1,s10,m1,m10,hour;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] bcd;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] seg;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] count,bcd;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] seg;</span><br><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk,<span class="keyword">posedge</span> rst)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span>(rst)</span><br><span class="line">count = <span class="number">4&#x27;b1111</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">if</span>(en) <span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span> (count==<span class="number">4&#x27;b0111</span>)</span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">count = count + <span class="number">1</span>; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">case</span>(count)</span><br><span class="line"><span class="number">4&#x27;b0000</span>:<span class="keyword">begin</span> bcd = ms1;seg = <span class="number">8&#x27;b11111110</span>; <span class="keyword">end</span></span><br><span class="line"><span class="number">4&#x27;b0001</span>:<span class="keyword">begin</span> bcd = ms10;seg = <span class="number">8&#x27;b11111101</span>; <span class="keyword">end</span></span><br><span class="line"><span class="number">4&#x27;b0010</span>:<span class="keyword">begin</span> bcd = ms100;seg = <span class="number">8&#x27;b11111011</span>; <span class="keyword">end</span></span><br><span class="line"><span class="number">4&#x27;b0011</span>:<span class="keyword">begin</span> bcd = s1;seg = <span class="number">8&#x27;b11110111</span>; <span class="keyword">end</span></span><br><span class="line"><span class="number">4&#x27;b0100</span>:<span class="keyword">begin</span> bcd = s10;seg = <span class="number">8&#x27;b11101111</span>; <span class="keyword">end</span></span><br><span class="line"><span class="number">4&#x27;b0101</span>:<span class="keyword">begin</span> bcd = m1;seg = <span class="number">8&#x27;b11011111</span>; <span class="keyword">end</span></span><br><span class="line"><span class="number">4&#x27;b0110</span>:<span class="keyword">begin</span> bcd = m10;seg = <span class="number">8&#x27;b10111111</span>; <span class="keyword">end</span></span><br><span class="line"><span class="number">4&#x27;b0111</span>:<span class="keyword">begin</span> bcd = hour;seg = <span class="number">8&#x27;b01111111</span>; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">default</span>:<span class="keyword">begin</span> bcd = <span class="number">4&#x27;b0000</span>;seg = <span class="number">8&#x27;b0000000</span>; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line">BCD7<span class="variable">.v</span></span><br><span class="line"><span class="keyword">module</span> BCD7(bcd,led);</span><br><span class="line"><span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] bcd;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">6</span>:<span class="number">0</span>] led;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">6</span>:<span class="number">0</span>] led;</span><br><span class="line"><span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line"><span class="keyword">case</span>(bcd)</span><br><span class="line"><span class="number">4&#x27;b0000</span>:led = <span class="number">7&#x27;b1111110</span>;</span><br><span class="line"><span class="number">4&#x27;b0001</span>:led = <span class="number">7&#x27;b0110000</span>;</span><br><span class="line"><span class="number">4&#x27;b0010</span>:led = <span class="number">7&#x27;b1101101</span>;</span><br><span class="line"><span class="number">4&#x27;b0011</span>:led = <span class="number">7&#x27;b1111001</span>;</span><br><span class="line"><span class="number">4&#x27;b0100</span>:led = <span class="number">7&#x27;b0110011</span>;</span><br><span class="line"><span class="number">4&#x27;b0101</span>:led = <span class="number">7&#x27;b1011011</span>;</span><br><span class="line"><span class="number">4&#x27;b0110</span>:led = <span class="number">7&#x27;b1011111</span>;</span><br><span class="line"><span class="number">4&#x27;b0111</span>:led = <span class="number">7&#x27;b1110000</span>;</span><br><span class="line"><span class="number">4&#x27;b1000</span>:led = <span class="number">7&#x27;b1111111</span>;</span><br><span class="line"><span class="number">4&#x27;b1001</span>:led = <span class="number">7&#x27;b1111011</span>;</span><br><span class="line"><span class="keyword">default</span>:led = <span class="number">7&#x27;b0000000</span>;</span><br><span class="line"><span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line">Stopwatch<span class="variable">.v</span></span><br><span class="line"><span class="keyword">module</span> SPWATCH(clk,rst,sp,co,led,seg);</span><br><span class="line"><span class="keyword">input</span> sp,rst,clk;</span><br><span class="line"><span class="keyword">output</span> co;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">6</span>:<span class="number">0</span>] led;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] seg;</span><br><span class="line"><span class="keyword">wire</span> c,e;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] ms1,ms2,ms3,s1,s2,m1,m2,hr,bcd4;</span><br><span class="line">CONTROL u1(clk,rst,sp,e);</span><br><span class="line">CB10 u2(clk,c);</span><br><span class="line">TIMER u3(c,rst,e,ms1,ms2,ms3,s1,s2,m1,m2,hr);</span><br><span class="line">MUXL u4(clk,rst,e,ms1,ms2,ms3,s1,s2,m1,m2,hr,bcd4,seg);</span><br><span class="line">BCD7 u5(bcd4,led);</span><br><span class="line"><span class="keyword">assign</span> co = c;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 课程实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HDL </tag>
            
            <tag> FPGA </tag>
            
            <tag> VHDL </tag>
            
            <tag> 数字秒表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于单片机的双机通信系统设计</title>
      <link href="2020/01/17/%E5%9F%BA%E4%BA%8E%E5%8D%95%E7%89%87%E6%9C%BA%E7%9A%84%E5%8F%8C%E6%9C%BA%E9%80%9A%E4%BF%A1%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
      <url>2020/01/17/%E5%9F%BA%E4%BA%8E%E5%8D%95%E7%89%87%E6%9C%BA%E7%9A%84%E5%8F%8C%E6%9C%BA%E9%80%9A%E4%BF%A1%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>本次电子设计先自主完成单片机上所有芯片的焊接，经调试确认焊接、硬件等正常工作后，再在单片机的基础上完成双机通信系统的设计。</p><p>双机通信是单片机的一个重要应用，MCS-51系列单片机上有一个通用异步接收／发送器UART，通过引脚RXD[P3．O]和TXD[P3．1]可与另一单片机进行全双工的串行异步通信，发送数据时由TXD端送出，接收时数据由RXD端输入。</p><p>本次课程设计就是要利用单片机来完成一个通信系统，实现两个单片机之间的有序通信。本文详细介绍了关于基于单片机89C52实现双机之间的全双工通信系统设计，软件部分采用C51语言编程实现接收部分和发送部分的功能及其它扩展功能。在Protues上进行仿真，程序软件设计完成后，将程序烧入单片机。在通信过程中，使用通信协议进行通信，通信的结果使用LCD1602液晶显示屏进行显示。</p><h1 id="焊接工艺总结"><a href="#焊接工艺总结" class="headerlink" title="焊接工艺总结"></a><a href="https://wenku.baidu.com/view/38aa1e4f6bd97f192279e9fd.html">焊接工艺总结</a></h1><h2 id="焊接准备"><a href="#焊接准备" class="headerlink" title="焊接准备"></a>焊接准备</h2><p>烙铁头表面覆盖光亮的焊锡，对于保证烙铁头很好地传导热量和焊接点的清洁至关重要。焊接前的准备工作主要是对被氧化的烙铁头进行预处理。如果加热前烙铁头表面沾锡均匀，可不用进行预处理。</p><p>在烙铁架的小盒内准备好清洁海绵并用水浸湿，准备好助焊用的松香。待电烙铁接通电源片刻后，在烙铁头的温度大约达到松香的熔解温度时，将烙铁头插入松香，让其表面涂覆一层松香，再等片刻，待烙铁头温度达到焊锡的熔解温度时，在烙铁头部表面均匀熔化并覆盖一层光亮的锡层。</p><p>如果烙铁头氧化严重，上述步骤无法使烙铁头均匀沾锡，则需要将烙铁头的氧化部位在含有焊锡和松香的铜丝编带上反复磨蹭，直到表面的黑色氧化物完全去除。</p><p>在焊接过程中，如发现烙铁头沾上焦化的助焊剂或其它黑色残留物时，应随时在清洁海绵上擦拭，除去烙铁头部的残留物。如有必要，可将烙铁头放在清洁海绵上数秒钟，降低其温度后再迅速插入松香，这样可以将烙铁头的氧化锡还原，以保持光亮的覆盖层。</p><h2 id="焊接步骤"><a href="#焊接步骤" class="headerlink" title="焊接步骤"></a>焊接步骤</h2><p>（1）准备施焊：首先把被焊件、锡丝和烙铁准备好处于随时可焊的状态。即右手拿烙铁烙铁头应保持干净并吃上锡，左手拿锡丝处于随时可施焊状态。<br>（2）加热焊件：把烙铁头放在接线端子和引线上进行加热。应注意加热整个焊件全体，例如图中导线和接线都要均匀受热。<br>（3）送入焊丝：被焊件经加热达到一定温度后立即将手中的锡丝触到被焊件上使之熔化适量的焊料。注意焊锡应加到被焊件上与烙铁头对称的一侧而不是直接加到烙铁头上。<br>（4）移开焊丝：当锡丝熔化一定量后焊料不能太多迅速移开锡丝。<br>（5）移开烙铁：当焊料的扩散范围达到要求，即焊锡浸润焊盘或焊件的施焊部位后移开电烙铁。撤离烙铁的方向和速度的快慢与焊接质量密切有关，操作时应特别留心仔细体会。  </p><h2 id="焊丝的供应"><a href="#焊丝的供应" class="headerlink" title="焊丝的供应"></a>焊丝的供应</h2><p>（1）供应时刻：原则上是被焊件升温到达焊料的熔化温度是当即送上焊锡丝。<br>（2）供应方位：应是在烙铁与被焊件之间并尽量接近焊盘。<br>（3）供应数量：应看被焊件与焊盘的巨细，焊锡盖住焊盘后焊锡高于焊盘直径的1/3既可。</p><h2 id="焊接注意事项"><a href="#焊接注意事项" class="headerlink" title="焊接注意事项"></a>焊接注意事项</h2><p>（1） 焊接时间不宜过久，但要完全熔著，以免造成冷焊。<br>（2） 焊点的表面要平滑、有光泽。<br>（3） 焊电完全冷却前，不可移动。<br>（4） 电烙铁不用时要放置于电烙铁架上，并随时保持电烙铁的清洁。<br>（5） 焊接完毕，要在烙铁头镀上薄层焊锡，避免氧化，并等冷却后再收存。</p><h1 id="编程思想"><a href="#编程思想" class="headerlink" title="编程思想"></a>编程思想</h1><h2 id="硬件电路设计"><a href="#硬件电路设计" class="headerlink" title="硬件电路设计"></a>硬件电路设计</h2><p>通信过程中双方既是发送方也是接收方，发送方的数据由串行口TXD端输出，经过传输线将信号传送到接收方RXD接收端，接收方也通过传输线将信号送达发送方串行口的接收端。接受方接收后，通过数据口P0及控制口P1的P1.5、P1.6、P1.7在LCD1602上显示接收的信息。相关选择控制按键如输入内容键K1(P3.2)、发送键K2(P3.3)、同意键K3（P3.4）、拒绝键K4（P3.5）、键盘P2等，整体电路设计如图1所示。  </p><h2 id="软件设计"><a href="#软件设计" class="headerlink" title="软件设计"></a>软件设计</h2><p>通过通信协议进行发送接收，甲机先发送‘?’给乙机，当乙机接收到‘?’后，会在LCD屏上显示选择同意或拒绝，如同意和甲机建立通信，则通过按键K3向甲机回答‘Y’，同时甲乙机LCD屏上显示‘Agree’。如拒绝和甲机通信，则通过按键K4向甲机回答‘N’，同时甲乙机LCD屏上显示‘Refuse’，甲机可再次请求建立连接。甲机收到乙机的答复后做出下一步操作。</p><p>当甲机和乙机建立通信后，一方可先按下K3键输入内容，每次发送内容最多可达32个字符，通过单片机上的键盘输入，输入完毕后，按下K4键点击发送，在屏幕下方会提示‘Send Finish’， 另一方收到的内容会在LCD上显示，此时可继续接收或发送信息，为了不影响下次接收的内容显示，可选择按键K3清空LCD屏幕，不清空则接着上次接收内容继续显示。甲乙两机可实现自由的全双工通信，即聊天模式。</p><p>其中键盘是行列式键盘，它是用P2口的4条I/O线作为行线，4条I/O线作为列线组成的键盘。在行线和列线的每一个交叉点上，设置一个按键，这样键盘中按键的个数是16个。通过每次键盘列扫描、按键判断、键值计算三个步骤检测是否有按键按下并返回按下的按键值。</p><p>除了基本的发送和接收功能，该通信系统建立后还可拒收对方信息，即把对方拉黑功能，按下K4键选择拒绝或恢复通信。发送图片音乐也是通信的一大特点，一方向另一方发送播放音乐《我和我的祖国》，播放音乐过程中不干扰正常的通信，可通过键盘中任意键结束音乐播放。</p><p><img src="simulation.png" alt="整体电路设计图"></p><h1 id="程序框图"><a href="#程序框图" class="headerlink" title="程序框图"></a>程序框图</h1><p><img src="process.png" alt="程序流程图">  </p><h1 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h1><h2 id="发送输入"><a href="#发送输入" class="headerlink" title="发送输入"></a>发送输入</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(send_count&lt;<span class="number">32</span>) &#123;  </span><br><span class="line">    key = getKey();   <span class="comment">//获取键值  </span></span><br><span class="line">    <span class="keyword">if</span> (key != <span class="number">-1</span>) &#123;     <span class="comment">//有键按下</span></span><br><span class="line">delayms(<span class="number">10</span>);    <span class="comment">//延时10ms，消除按键抖动</span></span><br><span class="line">        key = getKey();  <span class="comment">//再次获取键值</span></span><br><span class="line">        <span class="keyword">if</span> (key != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(send_count==<span class="number">16</span>)              <span class="comment">//超过16个字符显示在第二行</span></span><br><span class="line">                writecmd_1602(<span class="number">0x80</span>+<span class="number">0x40</span>);</span><br><span class="line">            <span class="keyword">if</span>(key&lt;<span class="number">10</span>) &#123;</span><br><span class="line">                input[send_count++] = <span class="string">&#x27;0&#x27;</span>+key;   <span class="comment">//数字0-9</span></span><br><span class="line">                <span class="keyword">if</span>(send_count==<span class="number">1</span>)</span><br><span class="line">                    writecmd_1602(<span class="number">0x01</span>);  <span class="comment">//清屏Please enter</span></span><br><span class="line">                writedata_1602(<span class="string">&#x27;0&#x27;</span>+key);   <span class="comment">//显示输入的内容</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                input[send_count++] = a_f[key<span class="number">-10</span>];  <span class="comment">//字母a-f</span></span><br><span class="line">                <span class="keyword">if</span>(send_count==<span class="number">1</span>)</span><br><span class="line">                    writecmd_1602(<span class="number">0x01</span>);  <span class="comment">//清屏Please enter</span></span><br><span class="line">                writedata_1602(a_f[key<span class="number">-10</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    P2 = <span class="number">0x0f</span>;        <span class="comment">//判断按键是否松开，防止一直输入</span></span><br><span class="line">    <span class="keyword">while</span>((P2 &amp; <span class="number">0x0f</span>) != <span class="number">0x0f</span>);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h2 id="接收内容"><a href="#接收内容" class="headerlink" title="接收内容"></a>接收内容</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(rec==<span class="string">&#x27;?&#x27;</span>) &#123;       <span class="comment">//接收方</span></span><br><span class="line">    writedata_1602(<span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">    writecmd_1602(<span class="number">0x80</span>+<span class="number">0x40</span>);</span><br><span class="line">    display_1602(<span class="string">&quot;YES:K3 NO:K4&quot;</span>);   <span class="comment">//显示提示信息</span></span><br><span class="line">    writecmd_1602(<span class="number">0x80</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(agree_k3==<span class="number">0</span>) &#123;</span><br><span class="line">            delayms(<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">if</span>(agree_k3==<span class="number">0</span>) &#123;</span><br><span class="line">                SBUF = <span class="string">&#x27;Y&#x27;</span>;   <span class="comment">//发送&#x27;Y&#x27;</span></span><br><span class="line">                rec_count = <span class="number">0</span>;   <span class="comment">//清零准备接收</span></span><br><span class="line">                per_send = <span class="number">1</span>;   <span class="comment">//同时也允许发送</span></span><br><span class="line">                display_1602(<span class="string">&quot;Agree&quot;</span>);  <span class="comment">//显示同意</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(refuse_k4==<span class="number">0</span>) &#123;</span><br><span class="line">            delayms(<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">if</span>(refuse_k4==<span class="number">0</span>) &#123;</span><br><span class="line">                SBUF = <span class="string">&#x27;N&#x27;</span>;   <span class="comment">//发送&#x27;N&#x27;</span></span><br><span class="line">                display_1602(<span class="string">&quot;Refuse&quot;</span>);   <span class="comment">//显示拒绝</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(TI==<span class="number">0</span>);</span><br><span class="line">    TI = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">    rece[rec_count++] = rec;   <span class="comment">//存入接收数组</span></span><br></pre></td></tr></table></figure><h1 id="体会与建议"><a href="#体会与建议" class="headerlink" title="体会与建议"></a>体会与建议</h1><p>1.对电子设计有了更直接的认识，对51单片机也有了更全面的认识，虽然曾经也焊过电路板，无论从原理还是实际操作上来讲那都没法和这次相比。对焊接技术有了更进一步的熟悉，对焊接程序也有了更清晰的认识，也更熟悉了焊接的方法技巧，看着我的焊点从最初的惨不忍睹到最后的爱不释手真的很有成就感。  </p><p>2.对问题的分析处理能力有了很大的进步，由于一开始的盲目行动，我犯了很多低级的错误，比如一开始居然把元件焊在了印制板的反面，先焊了集成块等等。随着设计的进行，我深刻体会到了事前分析规划的重要性，相信这是没有进行过这种实践的人所体会不到的。<br>3.通过这次紧张的电子设计课程，我收获颇多，每天面对着电脑，翻阅各种相关资料，体会颇深。短暂的单片机学习，有种意犹未尽之感，在这次课设中，加深了单片机相关知识的理解，之前的模棱两可已经不存在，这种感觉很好。  </p><p>4.在设计开始的前期，也遇到了麻烦，比如说，由于发送端和接收端的通信协议没有做好，导致数据不能正确的传输，在解决问题的过程中，对于通信协议的协议有了深刻的认知。以及我们的单片机RS-232C接口可能存在一些硬件问题，每次发送和接收都存在很强的信号干扰，最后我们放弃使用RS-232C接口，改用TXD和RXD相接的方法才使得通信成功。</p><p>5.RS-232是目前最常用的一种串行通讯接口。由于RS-232-C接口标准出现较早，难免有不足之处。接口的信号电平值较高，易损坏接口电路的芯片；传输速率较低，在异步传输时，波特率为20Kbps；接口使用一根信号线和另一根信号返回线而构成共地的传输形式，这种共地传输容易产生共模干扰，所以抗噪声干扰性弱；传输距离有限，最大传输距离标准值为50英尺。因此建议使用RS-485标准实现，RS-485接口具有良好的抗噪声干扰性，长的传输距离和多站能力等优点就使其成为首选的串行接口。  </p><p>6.很感谢徐老师的耐心教导，他的幽默让我们觉得亲切，他的认真负责让我们折服。在繁忙的一个学期即将结束之时，我的思想成熟了，这次的电子设计让我找到了方向，让我懂得了很多，有知识方面的，还有人格方面的。我相信，只要不放弃，只要努力，就一定可以！ </p><h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;REG51.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;intrins.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uchar unsigned char</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint unsigned int</span></span><br><span class="line"></span><br><span class="line">sbit been = P1^<span class="number">4</span>;  <span class="comment">//蜂鸣器</span></span><br><span class="line">sbit RS = P1^<span class="number">5</span>;   <span class="comment">//命令/数据</span></span><br><span class="line">sbit RW = P1^<span class="number">6</span>;   <span class="comment">//读/写</span></span><br><span class="line">sbit EN = P1^<span class="number">7</span>;   <span class="comment">//使能</span></span><br><span class="line">sbit agree_k3 = P3^<span class="number">4</span>;   <span class="comment">//同意接收</span></span><br><span class="line">sbit refuse_k4 = P3^<span class="number">5</span>;   <span class="comment">//拒绝接收</span></span><br><span class="line">bit per_send = <span class="number">0</span>;   <span class="comment">//发送允许</span></span><br><span class="line">bit music = <span class="number">0</span>;   <span class="comment">//音乐允许</span></span><br><span class="line">uchar rec;   <span class="comment">//接收的内容</span></span><br><span class="line">uchar send_count = <span class="number">0</span>;  <span class="comment">//发送数组变量</span></span><br><span class="line">uchar rec_count = <span class="number">0</span>;   <span class="comment">//接收数组变量</span></span><br><span class="line">uchar timer1H, timer1L, t;  <span class="comment">//音乐高低音</span></span><br><span class="line">uchar input[<span class="number">32</span>]= &#123;<span class="string">&#x27;\0&#x27;</span>&#125;;    <span class="comment">//发送数组</span></span><br><span class="line">uchar rece[<span class="number">32</span>]= &#123;<span class="string">&#x27;\0&#x27;</span>&#125;;     <span class="comment">//接收数组</span></span><br><span class="line">uchar code key_buf[] = &#123;<span class="number">0xee</span>,<span class="number">0xde</span>,<span class="number">0xbe</span>,<span class="number">0x7e</span>,<span class="number">0xed</span>,<span class="number">0xdd</span>,<span class="number">0xbd</span>,<span class="number">0x7d</span>,<span class="number">0xeb</span>,<span class="number">0xdb</span>,<span class="number">0xbb</span>,<span class="number">0x7b</span>,<span class="number">0xe7</span>,<span class="number">0xd7</span>,<span class="number">0xb7</span>,<span class="number">0x77</span>&#125;;<span class="comment">//按键0-f</span></span><br><span class="line">uchar a_f[]= &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>&#125;;  <span class="comment">//键值a-f</span></span><br><span class="line">uchar code FREQH[] = &#123;   <span class="comment">//我和我的祖国</span></span><br><span class="line">    <span class="number">0xF2</span>, <span class="number">0xF3</span>, <span class="number">0xF5</span>, <span class="number">0xF5</span>, <span class="number">0xF6</span>, <span class="number">0xF7</span>, <span class="number">0xF8</span>,</span><br><span class="line">    <span class="number">0xF9</span>, <span class="number">0xF9</span>, <span class="number">0xFA</span>, <span class="number">0xFA</span>, <span class="number">0xFB</span>, <span class="number">0xFB</span>, <span class="number">0xFC</span>, <span class="number">0xFC</span>,</span><br><span class="line">    <span class="number">0xFC</span>, <span class="number">0xFD</span>, <span class="number">0xFD</span>, <span class="number">0xFD</span>, <span class="number">0xFD</span>, <span class="number">0xFE</span>,</span><br><span class="line">    <span class="number">0xFE</span>, <span class="number">0xFE</span>, <span class="number">0xFE</span>, <span class="number">0xFE</span>, <span class="number">0xFE</span>, <span class="number">0xFE</span>, <span class="number">0xFF</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">uchar code FREQL[] = &#123;</span><br><span class="line">    <span class="number">0x42</span>, <span class="number">0xC1</span>, <span class="number">0x17</span>, <span class="number">0xB6</span>, <span class="number">0xD0</span>, <span class="number">0xD1</span>, <span class="number">0xB6</span>,</span><br><span class="line">    <span class="number">0x21</span>, <span class="number">0xE1</span>, <span class="number">0x8C</span>, <span class="number">0xD8</span>, <span class="number">0x68</span>, <span class="number">0xE9</span>, <span class="number">0x5B</span>, <span class="number">0x8F</span>,</span><br><span class="line">    <span class="number">0xEE</span>, <span class="number">0x44</span>, <span class="number">0x6B</span>, <span class="number">0xB4</span>, <span class="number">0xF4</span>, <span class="number">0x2D</span>,</span><br><span class="line">    <span class="number">0x47</span>, <span class="number">0x77</span>, <span class="number">0xA2</span>, <span class="number">0xB6</span>, <span class="number">0xDA</span>, <span class="number">0xFA</span>, <span class="number">0x16</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">uchar code song[] = &#123;</span><br><span class="line">    <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>,</span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">12</span>,</span><br><span class="line">    <span class="number">6</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">6</span>,</span><br><span class="line">    <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">12</span>,</span><br><span class="line">    <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>,</span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">12</span>,</span><br><span class="line">    <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>,</span><br><span class="line">    <span class="number">6</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>,</span><br><span class="line">    <span class="number">7</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">12</span>,</span><br><span class="line">    <span class="number">8</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">12</span>,</span><br><span class="line">    <span class="number">8</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">12</span>,</span><br><span class="line">    <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>,<span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>,<span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>,<span class="comment">//Me and my country</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delayms</span><span class="params">(uint z)</span> </span>&#123;  <span class="comment">//延时1ms</span></span><br><span class="line">    uint x,y;</span><br><span class="line">    <span class="keyword">for</span>(x=z; x&gt;<span class="number">0</span>; x--)</span><br><span class="line">        <span class="keyword">for</span>(y=<span class="number">110</span>; y&gt;<span class="number">0</span>; y--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay_mc</span><span class="params">(uchar t)</span> </span>&#123;  <span class="comment">//音乐延时</span></span><br><span class="line">    uchar t1;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> t2;</span><br><span class="line">    <span class="keyword">for</span>(t1 = <span class="number">0</span>; t1 &lt; t; t1++)</span><br><span class="line">        <span class="keyword">for</span>(t2 = <span class="number">0</span>; t2 &lt; <span class="number">4000</span>; t2++);</span><br><span class="line">    TR1 = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">musicer</span><span class="params">()</span> interrupt 3 </span>&#123;  <span class="comment">//定时方式1</span></span><br><span class="line">    TR1 = <span class="number">0</span>;</span><br><span class="line">    been = !been;</span><br><span class="line">    TH1 = timer1H;</span><br><span class="line">    TL1 = timer1L;</span><br><span class="line">    TR1 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span> </span>&#123;    <span class="comment">//播放音乐</span></span><br><span class="line">    TH1 = timer1H;</span><br><span class="line">    TL1 = timer1L;</span><br><span class="line">    TR1 = <span class="number">1</span>;</span><br><span class="line">    delay_mc(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">getKey</span><span class="params">()</span> </span>&#123;   <span class="comment">//获取按键</span></span><br><span class="line">    <span class="keyword">char</span> key_scan[] = &#123;<span class="number">0xef</span>, <span class="number">0xdf</span>, <span class="number">0xbf</span>, <span class="number">0x7f</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span> ; i++) &#123;</span><br><span class="line">        P2 = key_scan[i];</span><br><span class="line">        <span class="keyword">if</span> ((P2 &amp; <span class="number">0x0f</span>) != <span class="number">0x0f</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; <span class="number">16</span> ; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (key_buf[j]==P2) <span class="keyword">return</span> j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writecmd_1602</span><span class="params">(uchar cmd)</span> </span>&#123; <span class="comment">//写1602命令</span></span><br><span class="line">    RS = <span class="number">0</span>;</span><br><span class="line">    RW = <span class="number">0</span>;</span><br><span class="line">    P0 = cmd;</span><br><span class="line">    delayms(<span class="number">5</span>);</span><br><span class="line">    EN = <span class="number">1</span>;</span><br><span class="line">    delayms(<span class="number">5</span>);</span><br><span class="line">    EN = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writedata_1602</span><span class="params">(uchar dat)</span> </span>&#123; <span class="comment">//写1602数据</span></span><br><span class="line">    RS = <span class="number">1</span>;</span><br><span class="line">    RW = <span class="number">0</span>;</span><br><span class="line">    P0 = dat;</span><br><span class="line">    delayms(<span class="number">5</span>);</span><br><span class="line">    EN = <span class="number">1</span>;</span><br><span class="line">    delayms(<span class="number">5</span>);</span><br><span class="line">    EN = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_1602</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;   <span class="comment">//1602初始化</span></span><br><span class="line">    EN = <span class="number">0</span>;</span><br><span class="line">    writecmd_1602(<span class="number">0x38</span>);<span class="comment">//模式设置,两行显示，5x8</span></span><br><span class="line">    writecmd_1602(<span class="number">0x0c</span>);<span class="comment">//显示设置,显示开，不显示光标，光标不闪烁</span></span><br><span class="line">    writecmd_1602(<span class="number">0x06</span>);<span class="comment">//显示模式,写入新数据后光标右移,显示不移动</span></span><br><span class="line">    writecmd_1602(<span class="number">0x01</span>);<span class="comment">//清屏</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_1602</span><span class="params">(uchar *dp)</span> </span>&#123; <span class="comment">//1602数据显示</span></span><br><span class="line">    <span class="keyword">while</span>(*dp!= <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        writedata_1602(*dp++);</span><br><span class="line">        delayms(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_mes</span><span class="params">(uchar *mes)</span> </span>&#123;   <span class="comment">//发送信息</span></span><br><span class="line">    <span class="keyword">while</span>(*mes!= <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        SBUF = *mes;</span><br><span class="line">        <span class="keyword">while</span>(TI==<span class="number">0</span>);</span><br><span class="line">        TI = <span class="number">0</span>;</span><br><span class="line">        *mes=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        mes++;</span><br><span class="line">        delayms(<span class="number">50</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inputer</span><span class="params">()</span> interrupt 0 </span>&#123;   <span class="comment">//INT0 输入内容</span></span><br><span class="line">    init_1602();</span><br><span class="line">    delayms(<span class="number">15</span>);</span><br><span class="line">    writecmd_1602(<span class="number">0x80</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(per_send==<span class="number">0</span>) &#123;       <span class="comment">//第一次请求建立通信</span></span><br><span class="line">        writedata_1602(<span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">        SBUF = <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">        <span class="keyword">while</span>(TI==<span class="number">0</span>);</span><br><span class="line">        TI = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;        <span class="comment">//输入发送内容</span></span><br><span class="line">        <span class="keyword">char</span> key = <span class="number">-1</span>;</span><br><span class="line">        send_count = <span class="number">0</span>;</span><br><span class="line">        writecmd_1602(<span class="number">0x0f</span>);<span class="comment">//显示设置,显示开，显示光标，光标闪烁</span></span><br><span class="line">        display_1602(<span class="string">&quot;Please enter&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(send_count&lt;<span class="number">32</span>) &#123;</span><br><span class="line">            key = getKey();</span><br><span class="line">            <span class="keyword">if</span> (key != <span class="number">-1</span>) &#123;</span><br><span class="line">delayms(<span class="number">10</span>);</span><br><span class="line">                key = getKey();</span><br><span class="line">                <span class="keyword">if</span> (key != <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(send_count==<span class="number">16</span>)           <span class="comment">//超过16个字符显示在第二行</span></span><br><span class="line">                        writecmd_1602(<span class="number">0x80</span>+<span class="number">0x40</span>);</span><br><span class="line">                    <span class="keyword">if</span>(key&lt;<span class="number">10</span>) &#123;</span><br><span class="line">                        input[send_count++] = <span class="string">&#x27;0&#x27;</span>+key;</span><br><span class="line">                        <span class="keyword">if</span>(send_count==<span class="number">1</span>)</span><br><span class="line">                            writecmd_1602(<span class="number">0x01</span>); <span class="comment">//清屏Please enter</span></span><br><span class="line">                        writedata_1602(<span class="string">&#x27;0&#x27;</span>+key);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        input[send_count++] = a_f[key<span class="number">-10</span>];</span><br><span class="line">                        <span class="keyword">if</span>(send_count==<span class="number">1</span>)</span><br><span class="line">                            writecmd_1602(<span class="number">0x01</span>); <span class="comment">//清屏Please enter</span></span><br><span class="line">                        writedata_1602(a_f[key<span class="number">-10</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            P2 = <span class="number">0x0f</span>;        <span class="comment">//判断按键是否松开，防止一直输入</span></span><br><span class="line">            <span class="keyword">while</span>((P2 &amp; <span class="number">0x0f</span>) != <span class="number">0x0f</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sender</span><span class="params">()</span> interrupt 2 </span>&#123;   <span class="comment">//INT1发送</span></span><br><span class="line">    send_mes(input);</span><br><span class="line">    send_count = <span class="number">32</span>;  <span class="comment">//结束外部中断0</span></span><br><span class="line">    writecmd_1602(<span class="number">0x0c</span>);</span><br><span class="line">    writecmd_1602(<span class="number">0x80</span>+<span class="number">0x40</span>);</span><br><span class="line">    delayms(<span class="number">10</span>);</span><br><span class="line">    display_1602(<span class="string">&quot;Send Finish&quot;</span>);  <span class="comment">//显示发送完毕</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">receiver</span><span class="params">()</span> interrupt 4 </span>&#123;</span><br><span class="line">    RI = <span class="number">0</span>;</span><br><span class="line">    rec = SBUF;</span><br><span class="line">    init_1602();</span><br><span class="line">    writecmd_1602(<span class="number">0x80</span>);</span><br><span class="line">    <span class="keyword">if</span>(rec==<span class="string">&#x27;Y&#x27;</span>) &#123;</span><br><span class="line">        per_send = <span class="number">1</span>;</span><br><span class="line">        display_1602(<span class="string">&quot;Agree&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(rec==<span class="string">&#x27;N&#x27;</span>) &#123;</span><br><span class="line">        display_1602(<span class="string">&quot;Refuse&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(rec==<span class="string">&#x27;?&#x27;</span>) &#123;       <span class="comment">//接收方</span></span><br><span class="line">        writedata_1602(<span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">        writecmd_1602(<span class="number">0x80</span>+<span class="number">0x40</span>);</span><br><span class="line">        display_1602(<span class="string">&quot;YES:K3 NO:K4&quot;</span>);</span><br><span class="line">        writecmd_1602(<span class="number">0x80</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(agree_k3==<span class="number">0</span>) &#123;</span><br><span class="line">                delayms(<span class="number">10</span>);</span><br><span class="line">                <span class="keyword">if</span>(agree_k3==<span class="number">0</span>) &#123;</span><br><span class="line">                    SBUF = <span class="string">&#x27;Y&#x27;</span>;   <span class="comment">//发送&#x27;Y&#x27;</span></span><br><span class="line">                    rec_count = <span class="number">0</span>;   <span class="comment">//清零准备接收</span></span><br><span class="line">                    per_send = <span class="number">1</span>;   <span class="comment">//同时也允许发送</span></span><br><span class="line">                    display_1602(<span class="string">&quot;Agree&quot;</span>);  <span class="comment">//显示同意</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(refuse_k4==<span class="number">0</span>) &#123;</span><br><span class="line">                delayms(<span class="number">10</span>);</span><br><span class="line">                <span class="keyword">if</span>(refuse_k4==<span class="number">0</span>) &#123;</span><br><span class="line">                    SBUF = <span class="string">&#x27;N&#x27;</span>;   <span class="comment">//发送&#x27;N&#x27;</span></span><br><span class="line">                    display_1602(<span class="string">&quot;Refuse&quot;</span>);   <span class="comment">//显示拒绝</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(TI==<span class="number">0</span>);</span><br><span class="line">        TI = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(rec==<span class="string">&#x27;f&#x27;</span>) &#123;  <span class="comment">//音乐指令</span></span><br><span class="line">        music = <span class="number">1</span>;</span><br><span class="line">        display_1602(<span class="string">&quot;music&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        rece[rec_count++] = rec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    uchar k, i,key;</span><br><span class="line">    been=<span class="number">0</span>;      <span class="comment">//关蜂鸣器</span></span><br><span class="line">    PCON = <span class="number">0X80</span>;  <span class="comment">//波特率加倍</span></span><br><span class="line">    SCON = <span class="number">0X90</span>;  <span class="comment">//通信方式2允许接受</span></span><br><span class="line">    TMOD = <span class="number">0X10</span>; <span class="comment">//音乐定时方式1</span></span><br><span class="line">    IE = <span class="number">0X9d</span>;  <span class="comment">//外部中断0 1 通信中断 定时中断1允许</span></span><br><span class="line">    IT0 = <span class="number">1</span>;  <span class="comment">//INT0</span></span><br><span class="line">    IT1 = <span class="number">1</span>;   <span class="comment">//INT1</span></span><br><span class="line">    PX1 = <span class="number">1</span>;   <span class="comment">//INT1高级中断</span></span><br><span class="line"></span><br><span class="line">    init_1602();</span><br><span class="line">    delayms(<span class="number">15</span>);</span><br><span class="line">    writecmd_1602(<span class="number">0x80</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(rec_count==<span class="number">1</span>) &#123;  <span class="comment">//收到新信息清屏</span></span><br><span class="line">            writecmd_1602(<span class="number">0x01</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(agree_k3==<span class="number">0</span>) &#123;   <span class="comment">//清空上次通信内容</span></span><br><span class="line">            delayms(<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">if</span>(agree_k3==<span class="number">0</span>) &#123;</span><br><span class="line">                uchar *p = rece;</span><br><span class="line">                rec_count = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(*p!= <span class="string">&#x27;\0&#x27;</span>) &#123;  <span class="comment">//清空接收数组，准备下一次接收</span></span><br><span class="line">                    *p++=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(refuse_k4==<span class="number">0</span>) &#123;   <span class="comment">//屏蔽对方信息</span></span><br><span class="line">            delayms(<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">if</span>(refuse_k4==<span class="number">0</span>) &#123;</span><br><span class="line">                ES=!ES;   <span class="comment">//打开或屏蔽对方</span></span><br><span class="line">                <span class="keyword">while</span>(!refuse_k4);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(music) &#123;   <span class="comment">//播放音乐指令</span></span><br><span class="line">            been = <span class="number">1</span>;</span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line">            t = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(t) &#123;</span><br><span class="line">                k = song[i] + <span class="number">7</span> * song[i + <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">                timer1H = FREQH[k];</span><br><span class="line">                timer1L = FREQL[k];</span><br><span class="line">                t = song[i + <span class="number">2</span>];</span><br><span class="line">                i += <span class="number">3</span>;</span><br><span class="line">                sing();</span><br><span class="line">                writecmd_1602(<span class="number">0x80</span>);</span><br><span class="line">                display_1602(rece);</span><br><span class="line">                key = getKey();</span><br><span class="line">                <span class="keyword">if</span> (key != <span class="number">-1</span>) &#123;   <span class="comment">//任意键关闭音乐</span></span><br><span class="line">                    music = <span class="number">0</span>;</span><br><span class="line">                    been = <span class="number">0</span>;</span><br><span class="line">                    writecmd_1602(<span class="number">0x01</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        writecmd_1602(<span class="number">0x80</span>);</span><br><span class="line">        display_1602(rece);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 课程设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C51 </tag>
            
            <tag> 单片机 </tag>
            
            <tag> 双机通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/01/07/hello-world/"/>
      <url>2020/01/07/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Hello Everybody!  </p><p>我</p><p>CUMT 计算机学院 2017 级信科专业</p><p>菜鸡一枚，爱好玩耍</p><p>有问题请邮件联系：<a href="mailto:&#x67;&#x7a;&#119;&#x61;&#x6e;&#103;&#64;&#99;&#x75;&#109;&#116;&#x2e;&#101;&#100;&#117;&#x2e;&#99;&#x6e;">&#x67;&#x7a;&#119;&#x61;&#x6e;&#103;&#64;&#99;&#x75;&#109;&#116;&#x2e;&#101;&#100;&#117;&#x2e;&#99;&#x6e;</a></p><p>开始搞事情！</p><p><img src="go.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 关于我 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自我介绍 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
