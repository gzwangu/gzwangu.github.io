<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>面试小记</title>
      <link href="2022/05/03/%E9%9D%A2%E8%AF%95%E5%B0%8F%E8%AE%B0/"/>
      <url>2022/05/03/%E9%9D%A2%E8%AF%95%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="C-基础"><a href="#C-基础" class="headerlink" title="C++基础"></a>C++基础</h1><h2 id="class与struct区别"><a href="#class与struct区别" class="headerlink" title="class与struct区别"></a>class与struct区别</h2><p>C++中的 struct 和 class 基本是通用的，唯有几个细节不同：</p><ul><li>默认访问权限：struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的。</li><li>默认的继承访问权：class默认的是private，strcut默认的是public。</li><li>“class”这个关键字还用于定义模板参数，就像“typename”。但关建字“struct”不用于定义模板参数</li></ul><h2 id="虚函数实现原理"><a href="#虚函数实现原理" class="headerlink" title="虚函数实现原理"></a>虚函数实现原理</h2><p>虚函数是通过一张虚函数表来实现的，每一个含有虚函数（无论是其本身的，还是继承而来的）的类都至少有一个与之对应的虚函数表，表中存放了虚函数的地址。虚函数表的构造由编译器完成的（虚函数替换过程发生在编译时）。</p><p>当调用一个虚函数时，首先通过对象内存中的 vptr 找到虚函数表，找到对应 vtbl 内的指向被调用函数的指针，调用指针所指向的函数。在有继承关系时(子类相对于其直接父类)</p><ul><li>一般继承时，子类的虚函数表中先将父类虚函数放在前，再放自己的虚函数指针。</li><li>如果子类覆盖了父类的虚函数，虚函数指针将被放到了虚表中<strong>原来父类虚函数</strong>的位置。</li><li>在多继承的情况下，每个父类都有自己的虚函数表，父类中没有的虚函数而子类有，填入第一个虚函数表中，且用父类指针是不能调用。当类在多重继承中时，有几个基类（前提是要有虚函数）则子类实例对象就会保存几个虚函数表指针。</li></ul><h2 id="虚函数和普通函数重写"><a href="#虚函数和普通函数重写" class="headerlink" title="虚函数和普通函数重写"></a>虚函数和普通函数重写</h2><ul><li>基类与派生类中普通函数同名，调用哪个类的函数与指针的定义类型有关，与指针的指向无关。</li><li>基类与派生类中虚函数同名，与指针指向的类型有关，该指针必须定义为基类类型，否则必须显示转换。</li></ul><h2 id="c-11-新特性"><a href="#c-11-新特性" class="headerlink" title="c++11 新特性"></a>c++11 新特性</h2><ul><li>auto &amp; decltype</li><li>左值右值（一个表达式不是左值就是右值）</li><li>列表初始化</li><li>lambda表达式</li><li>模板的改进</li><li>智能指针</li><li>基于范围的for循环</li><li>继承构造函数</li><li>nullptr</li><li>final &amp; override</li><li>explicit</li></ul><h2 id="引用计数实现"><a href="#引用计数实现" class="headerlink" title="引用计数实现"></a>引用计数实现</h2><ul><li>构造函数中创建类的新对象时，初始化引用计数为1；</li><li>拷贝构造函数复制指针，并使相应的引用计数增加1；</li><li>赋值操作减少左操作数所值对象的引用计数，增加右操作数所指对象的引用计数；</li><li>析构函数使引用计数减少1，并且当引用计数为1时，释放指针说指向的对象；</li></ul><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><ul><li>shared_ptr：采用引用计数的智能指针。多个 shared_ptr 指针可以共同使用同一块堆内存，指向同一个对象。该对象及相关资源会在其所指对象不再使用之后，自动释放与对象相关的资源。</li><li>unique_ptr：实现独占式拥有的概念，只能有一个unique_ptr可以指向该对象，当这个unique_ptr被销毁时，指向的对象也随即被销毁。不能进行拷贝构造和拷贝赋值（实现原理），但是可以进行移动构造和移动赋值（交出控制权）。</li><li>weak_ptr：结合 <code>shared_ptr</code> 使用的特例智能指针。 <code>weak_ptr</code> 提供对 <code>shared_ptr</code> 实例拥有的对象的访问，但不参与引用计数。解决shared_ptr 相互引用时，两个指针的引用计数永远不会下降为0，从而导致死锁问题。</li><li>auto_ptr（抛弃）：对象所有权的转移，比如在函数传参过程中，对象所有权不会返还，从而存在潜在的内存崩溃问题；不能指向数组，也不能作为STL容器的成员。</li></ul><h2 id="shared-ptr线程安全"><a href="#shared-ptr线程安全" class="headerlink" title="shared_ptr线程安全"></a>shared_ptr线程安全</h2><ul><li>shared_ptr的引用计数本身是安全且无锁的。</li><li>多线程环境下，调用不同shared_ptr实例的成员函数是不需要额外的同步手段。</li><li>多个线程同时读同一个shared_ptr对象是线程安全的，但如果是多个线程对同一个shared_ptr对象进行读和写，则需要加锁。</li><li>shared_ptr 有两个数据成员，引用计数和原始指针。当指针发生拷贝的时候，标准库的实现是先拷贝智能指针，再拷贝引用计数对象（同时会使use_count加一），这两个操作并不是原子的。</li><li>shared_ptr 的线程安全级别和内建类型、标准库容器、std::string 一样。</li></ul><h2 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h2><p>指的是函数模板可以将自己的参数“完美”地转发给内部调用的其它函数。</p><p>在定义模板函数时，采用右值引用的语法格式定义参数类型，由此该函数既可以接收外界传入的左值，也可以接收右值；其次，还需要使用 C++11 标准库提供的 forword() 模板函数修饰被调用函数中需要维持左、右值属性的参数，实现函数模板中参数的完美转发。 </p><h2 id="new和malloc的区别"><a href="#new和malloc的区别" class="headerlink" title="new和malloc的区别"></a>new和malloc的区别</h2><ul><li><p>使用上的区别</p><p>malloc：申请空间需要显式填入申请内存的大小；</p><p>new：无需显式填入申请的内存大小，new会根据new的类型分配内存。</p></li><li><p>内存位置的区别</p><p>new：此操作符分配的内存空间是在自由存储区；</p><p>malloc：申请的内存是在堆空间。</p></li><li><p>返回类型的区别</p><p>new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。</p></li><li><p>分配失败情况的区别</p><p>malloc分配内存失败时返回NULL，通过判断返回值可以得知是否分配成功；</p><p>new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL，分配失败时如果不捕捉异常，那么程序就会异常退出。</p></li><li><p>定义对象系统调度过程的区别</p><p>使用new操作符来分配对象内存时会经历三个步骤：（1）调用operator new 函数（数组是operator new[]）分配一块足够的内存空间（通常底层默认使用malloc实现，除非重载new符号）以便存储特定类型的对象；（2）编译器运行相应的构造函数以构造对象，并为其传入初值；（3）对象构造完成后，返回一个指向该对象的指针。</p><p>使用delete操作符来释放对象内存时会经历两个步骤：（1）调用对象的析构函数。（2）编译器调用operator delete(或operator delete[])函数释放内存空间（通常底层默认使用free实现，除非程序员重载delete符号）。</p></li><li><p>扩张内存大小的区别</p><p>malloc：使用malloc分配内存后，发现内存不够用，那我们可以通过realloc函数来扩张内存大小。</p><p>new：new没有扩张内存的机制。</p></li></ul><h2 id="vector、list和-deque"><a href="#vector、list和-deque" class="headerlink" title="vector、list和 deque"></a>vector、list和 deque</h2><ul><li>vector底层是连续结构；list底层是非连续结构</li><li>vector支持随机访问；list不支持随机访问</li><li>vector迭代器是原生指针；list迭代器是封装结点的一个类</li><li>vector在插入和删除时可能会导致迭代器失效；list在删除的时候会导致当前迭代器指向的结点失效</li><li>vector不容易造成内存碎片，空间利用率高；list容易造成内存碎片，空间利用率低</li><li>vector在非尾插，删除的时间复杂度为O(n)，list在任何地方插入和删除的时间复杂度都为O(1)</li><li>vecotr需要高效存储，支持随机访问，不关心插入删除效率；list大量插入和删除操作，不关心随机访问</li></ul><ol><li>vector 底层数据结构为数组 ，支持快速随机访问</li><li>list 底层数据结构为双向链表，支持快速增删</li><li>deque（双端队列） 底层数据结构为一个中央控制器和多个缓冲区，可以向两端发展，尾部或首部增删元素都十分迅速。 在中间增删元素则比较费时，因为必须移动其它元素，也支持随机访问（每个堆保存好几个元素，然后堆和堆之间有指针指向，看起来像是list和vector的结合品）</li></ol><p><strong>使用场景：</strong></p><ul><li>如果你需要高效的随即存取，而不在乎插入和删除的效率，使用vector </li><li>如果你需要大量的插入和删除，而不关心随即存取，则应使用list </li><li>如果你需要随即存取，而且关心两端数据的插入和删除，则应使用deque</li></ul><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><ol><li><p>static_cast</p><p>用于数据类型的强制转换，强制将一种数据类型转换为另一种数据类型。</p><p>c++ 的任何的隐式转换都是使用 static_cast 来实现。</p></li><li><p>const_cast</p><p>常量指针或引用被转化成非常量的指针或引用，并且仍然指向原来的对象；const_cast一般用于修改指针。如const char *p形式。</p></li><li><p>reinterpret_cast</p><p>改变指针或引用的类型、将指针或引用转换为一个足够长度的整型、将整型转换为指针或引用类型。</p></li><li><p>dynamic_cast</p><p>主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换。</p><p>其他三种都是编译时完成的，dynamic_cast是运行时处理的，运行时要进行类型检查。</p><p>不能用于内置的基本数据类型的强制转换。</p><p>dynamic_cast转换如果成功的话返回的是指向类的指针或引用，转换失败的话则会返回NULL。</p><p>使用dynamic_cast进行转换的，基类中一定要有虚函数，否则编译不通过。</p></li></ol><h2 id="STL六大组件"><a href="#STL六大组件" class="headerlink" title="STL六大组件"></a>STL六大组件</h2><ul><li>容器</li><li>适配器</li><li>算法</li><li>迭代器</li><li>函数对象</li><li>分配器</li></ul><h2 id="迭代器的作用"><a href="#迭代器的作用" class="headerlink" title="迭代器的作用"></a>迭代器的作用</h2><p>Iterator类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果。</p><ul><li><p>通过迭代器访问容器，可以避免许多错误，同时还能隐藏容器的具体实现。</p></li><li><p>迭代器可以保证对所有容器的基本遍历方式，都是一样的，实现算法时若需要遍历，则使用迭代器，则可以不用关注容器的具体类型，实现数据结构和算法的分离。</p></li><li><p>迭代器本身有很多优点，可以弥补C++语言的不足，比如它的iterator_category，可以得到迭代器所指向的类别，这样可以根据不同的类别的特性，提供不同的算法。</p></li></ul><h2 id="右值引用和std-move"><a href="#右值引用和std-move" class="headerlink" title="右值引用和std::move"></a>右值引用和std::move</h2><ul><li><p>左值：有名称的、可以获取到地址的、位于等号左侧的表达式</p></li><li><p>右值：无名称的、不能取地址，位于等号右边的表达式</p></li><li><p>左值引用：能指向左值，不能指向右值（&amp;），const左值引用是可以指向右值的</p></li><li><p>右值引用：可以指向右值，不能指向左值（&amp;&amp;）</p></li></ul><p><strong>右值引用有办法指向左值吗？</strong></p><p>std::move 功能是把左值强制转化为右值，让右值引用可以指向左值。其实现等同于一个类型转换：static_cast&lt;T&amp;&amp;&gt;(lvalue)。(单纯的std::move(xxx)不会有性能提升)</p><p><strong>右值引用能指向右值，本质上也是把右值提升为一个左值，并定义一个右值引用通过std::move指向该左值</strong>。</p><p>右值引用本身既可以是左值也可以是右值，如果有名称则为左值，否则是右值。或者说：作为函数返回值的 &amp;&amp; 是右值，直接声明出来的 &amp;&amp; 是左值。</p><ol><li>从性能上讲，左右值引用没有区别，传参使用左右值引用都可以避免拷贝。</li><li>右值引用可以直接指向右值，也可以通过std::move指向左值；而左值引用只能指向左值(const左值引用也能指向右值)。</li><li>作为函数形参时，右值引用更灵活。虽然const左值引用也可以做到左右值都接受，但它无法修改，有一定局限性。</li></ol><p>如果我们没有提供移动构造函数，只提供了拷贝构造函数，std::move()会失效但是不会发生错误，因为编译器找不到移动构造函数就去寻找拷贝构造函数，也这是<strong>拷贝构造函数的参数是const T&amp;常量左值引用</strong>的原因！</p><p>c++11中的所有容器都实现了move语义，<strong>move只是转移了资源的控制权</strong>，本质上是将左值强制转化为右值使用，以用于移动拷贝或赋值，避免对含有资源的对象发生无谓的拷贝。</p><p>move对于拥有如内存、文件句柄等资源的成员的对象有效，如果是一些基本类型，如int和char[10]数组等，如果使用move，仍会发生拷贝（因为没有对应的移动构造函数），所以说<strong>move对含有资源的对象说更有意义</strong>。</p><ul><li>右值引用和std::move被广泛用于在STL和自定义类中实现移动语义，避免拷贝，从而提升程序性能。</li><li>实现完美转发 std::forward（与move相比，forward更强大，move只能转出来右值，forward都可以）</li></ul><h2 id="volatile的使用"><a href="#volatile的使用" class="headerlink" title="volatile的使用"></a>volatile的使用</h2><ol><li>中断服务程序中修改的供其它程序检测的变量需要加volatile；</li><li>多任务环境下各任务间共享的标志应该加volatile；</li><li>存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义；</li></ol><ul><li>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。volatile 告诉编译器不应对这样的对象进行优化。</li><li>volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取取值）</li><li>const 可以是 volatile （如只读的状态寄存器）</li><li>指针可以是 volatile</li></ul><h2 id="调用析构函数场景"><a href="#调用析构函数场景" class="headerlink" title="调用析构函数场景"></a>调用析构函数场景</h2><ul><li>生命周期：对象生命周期结束，会调用析构函数。</li><li>delete：调用delete，会删除指针类对象。</li><li>包含关系：对象Dog是对象Person的成员，Person的析构函数被调用时，对象Dog的析构函数也被调用。</li><li>继承关系：当Person是Student的父类，调用Student的析构函数，会调用Person的析构函数。</li></ul><h2 id="内存泄露和野指针"><a href="#内存泄露和野指针" class="headerlink" title="内存泄露和野指针"></a>内存泄露和野指针</h2><p>用动态存储分配函数动态开辟的空间，在使用完毕后未释放，结果导致一直占据该内存单元。直到程序结束。即所谓内存泄漏。</p><p>野指针的成因主要有两种：</p><ul><li>指针变量没有被初始化</li><li>指针p被free或者delete之后，没有置为NULL，让人误以为p是个合法的指针</li></ul><h2 id="空类的成员函数"><a href="#空类的成员函数" class="headerlink" title="空类的成员函数"></a>空类的成员函数</h2><ul><li>缺省构造函数</li><li>拷贝构造函数</li><li>析构函数</li><li>拷贝赋值运算符</li><li>取址运算符</li><li>取址运算符 const</li><li>移动构造函数（C++11）</li><li>移动赋值运算符（C++11）</li></ul><p>在C++中空类会占1个字节，这是为了让对象的实例能够相互区别。空类同样可以被实例化，并且每个实例在内存中都有独一无二的地址。</p><h2 id="sizeof-特殊类"><a href="#sizeof-特殊类" class="headerlink" title="sizeof 特殊类"></a>sizeof 特殊类</h2><ul><li>空类占用1个字节</li><li>一般函数不占用空间</li><li>一般数据类型按照本身数据大小</li><li>当类有虚函数时，需要4字节的虚表指针</li><li>当多继承时，有虚函数的会生成一个虚表指针，比如继承两个有虚函数的类，那么会有两个虚表指针。如果一个虚类，一个普通类，那么有一个虚指针。</li></ul><h2 id="执行main函数前的工作"><a href="#执行main函数前的工作" class="headerlink" title="执行main函数前的工作"></a>执行main函数前的工作</h2><ol><li>设置栈指针。</li><li>初始化static静态和global全局变量，即data段内容</li><li>将未初始化部分的赋初值：数值型short，int，long等为0，bool为FALSE，指针为NULL，等等，即.bss段的内容</li><li>运行全局构造器，C++中构造函数之类的</li><li>将main函数的参数，argc，argv等传递给main函数，然后才真正运行main函数</li></ol><h2 id="引用和指针"><a href="#引用和指针" class="headerlink" title="引用和指针"></a>引用和指针</h2><ul><li>指针是一个实体，而引用仅是个别名</li><li>指针变量分配内存区域，而引用不需要分配内存</li><li>引用只能在定义时被初始化一次，之后不可变；指针可变</li><li>引用没有 const，指针有 const；const修饰的指针不可变</li><li>引用不能为空，指针可以为空</li></ul><h2 id="extern、static-和-const"><a href="#extern、static-和-const" class="headerlink" title="extern、static 和 const"></a>extern、static 和 const</h2><p><strong>extern 关键字：</strong></p><ul><li>声明extern的全局变量和函数以表示定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义，可以使得它们能够跨文件被访问。</li><li>extern “C” 会指示编译器这部分代码按C语言（而不是C++）的方式进行编译和链接。</li></ul><p><strong>static关键字：</strong></p><ul><li>static 修饰局部变量时，在静态存储区分配内存；只能在首次函数调用中进行首次初始化，之后的函数调用不再进行初始化。</li><li>static 修饰全局变量和函数时，在该文件中都是可见的，而在文件外是不可见的，从而可以在多人协作时避免同名的变量和函数冲突。</li><li>static 类成员变量时，所有的对象都只维持一份拷贝，可以实现不同对象间的数据共享；不需要实例化对象即可访问；不能在类内部初始化，一般在类外部初始化，并且初始化时不加static。</li><li>static 类成员函数时，该函数不接受this指针，只能访问类的静态成员；不需要实例化对象即可访问。</li></ul><p><strong>extern 和 static 不能同时修饰一个变量</strong>。通常在模块的头文件中对本模块提供给其它模块使用的函数和全局变量以extern声明，一般定义static全局变量时，把它放在原文件中而不是头文件。</p><p><strong>const 关键字：</strong></p><ul><li>修饰变量，说明该变量不可以被改变</li><li>修饰指针，分为指向常量的指针和自身是常量的指针（常量指针）</li><li>修饰引用，指向常量的引用，用于形参类型，即避免了拷贝，又避免了函数对值的修改</li><li>修饰类成员函数，说明该成员函数内不能修改成员变量</li></ul><h2 id="RAII-机制"><a href="#RAII-机制" class="headerlink" title="RAII 机制"></a>RAII 机制</h2><p>资源获取即初始化，使用局部对象来管理资源的技术称为资源获取即初始化；这里的资源主要是指操作系统中有限的东西如内存、网络套接字等等，局部对象是指存储在栈的对象，它的生命周期是由操作系统来管理的，无需人工介入；充分的利用了C++语言局部对象自动销毁的特性来控制资源的生命周期。</p><p><strong>如何使用 RAII</strong></p><p>把资源用类进行封装起来，对资源操作都封装在类的内部，在析构函数中进行释放资源。当定义的局部变量的生命结束时，它的析构函数就会自动的被调用，如此，就不用程序员显示的去调用释放资源的操作了。</p><h2 id="异常的优缺点"><a href="#异常的优缺点" class="headerlink" title="异常的优缺点"></a>异常的优缺点</h2><p>C++异常的优点：</p><ul><li>清晰准确的展示出错误的信息，甚至可以包含堆栈调用的信息，可以更好的定位程序的bug</li><li>部分函数使用异常更好处理，比如构造函数没有返回值，不方便使用错误码方式处理</li></ul><p>C++异常的缺点：</p><ul><li>异常会导致程序的执行流非常的混乱，并且是运行时出错抛异常就会乱跳。这会导致我们跟踪调试时以及分析程序时，比较困难。</li><li>异常会有一些性能的开销。</li><li>C++没有垃圾回收机制，资源需要自己管理。异常非常容易导致内存泄漏、死锁等异常安全问题。</li><li>C++标准库的异常体系定义得不好，各种的异常体系非常的混乱。</li></ul><h2 id="resize-与-reserve"><a href="#resize-与-reserve" class="headerlink" title="resize 与 reserve"></a>resize 与 reserve</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reserve</span> <span class="params">(size_type n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span> <span class="params">(size_type n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span> <span class="params">(size_type n, value_type val)</span></span>;</span><br></pre></td></tr></table></figure><p>reserve的作用是更改vector的容量（capacity），使vector至少可以容纳n个元素。</p><ul><li>如果n大于vector当前的容量，reserve会对vector进行扩容。容器预留空间不创建对象，需要通过insert()或push_back()等操作创建对象。</li><li>其他情况下都不会重新分配vector的存储空间。</li><li>该函数不会影响vector的size而且不会改变任何元素</li></ul><p>resize函数重新分配大小，改变容器的size，并且创建对象。</p><ul><li>如果n小于vector当前的size，则删除多出来的元素。</li><li>如果n大于vector的size，小于等于capacity()，则会插入相应数量的元素 使得size()值达到n。</li><li>当n大于capacity()值的时候，会自动分配重新分配内存存储空间。</li></ul><h2 id="cpp文件到exe文件"><a href="#cpp文件到exe文件" class="headerlink" title="cpp文件到exe文件"></a>cpp文件到exe文件</h2><p>分为四个过程：预处理、编译、汇编和链接</p><p><img src="cpp2exe.png"></p><ul><li>预处理：在预处理阶段，编译器主要作加载头文件、宏替换、条件编译的作用。</li><li>编译：在编译过程中，编译器主要作语法检查和词法分析。可以通过使用 -S 选项来进行查看，该选项预处理之后的结果翻译成汇编代码。</li><li>汇编：在汇编过程中，编译器把汇编代码转化为机器代码。</li><li>链接：链接就是将目标文件、启动代码、库文件链接成可执行文件的过程。</li></ul><h2 id="不能重载的运算符"><a href="#不能重载的运算符" class="headerlink" title="不能重载的运算符"></a>不能重载的运算符</h2><ul><li>. （成员访问运算符）</li><li>. *（成员指针访问运算符）</li><li>::（域运算符）</li><li>?:（条件运算符）</li><li>sizeof（长度运算符）</li></ul><p>前两个运算符不能重载是为了保证访问成员的功能不能被改变，域运算符和sizeof 运算符的运算对象是类型而不是变量或一般表达式，不具备重载的特征。</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="B-树和B树的区别"><a href="#B-树和B树的区别" class="headerlink" title="B+树和B树的区别"></a>B+树和B树的区别</h2><ol><li>B+树内节点不存储数据，所有 data 存储在叶节点查询时间复杂度固定为 log n，查询性能稳定。而B-树查询时间复杂度不固定，与 key 在树中的位置有关，最好为O(1)。</li><li>B+树叶节点两两相连形成了一个有序链表，增加了区间访问性，提高范围查询性能等，而B-树每个节点 key 和 data 在一起，则无法区间查找。</li><li>B+树更适合外部存储。由于内节点无 data 域，每个节点能索引的范围更大更精确</li></ol><p><strong>B+树对比B树的好处</strong></p><ul><li>IO次数少：B+树的中间结点只存放索引，数据都存在叶结点中，因此中间结点可以存更多的数据，让索引树更加矮胖；</li><li>范围查询效率更高：B树需要中序遍历整个树，只B+树需要遍历叶结点中的链表；</li><li>查询效率更加稳定：每次查询都需要从根结点到叶结点，路径长度相同，所以每次查询的效率都差不多</li></ul><h2 id="哈希方法和哈希冲突"><a href="#哈希方法和哈希冲突" class="headerlink" title="哈希方法和哈希冲突"></a>哈希方法和哈希冲突</h2><p>散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存储存位置的数据结构。它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p><p><strong>散列方法</strong>：</p><ul><li>直接定址法</li><li>平方取中法</li><li>折叠法</li><li>伪随机数法</li><li>除留余数法</li><li>斐波那契散列法</li><li>字符串转化法（多项式法）</li></ul><p><strong>哈希冲突解决：</strong></p><ul><li>拉链法（数组+链表）</li><li>开放定址法（再散列法）：线性探测、二次探测、伪随机探测</li><li>再哈希法：构造多个不同的哈希函数</li><li>公共溢出区：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表</li></ul><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树是一种含有红黑结点并能自平衡的二叉查找树。它必须满足下面性质：</p><ul><li>每个节点要么是黑色，要么是红色。</li><li>根节点是黑色。</li><li>每个叶子节点（NIL）是黑色。</li><li>每个红色结点的两个子结点一定都是黑色。</li><li>任意一结点到每个叶子结点的路径都包含数量相同的黑结点。</li></ul><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="TIME-WAIT过多的问题"><a href="#TIME-WAIT过多的问题" class="headerlink" title="TIME_WAIT过多的问题"></a>TIME_WAIT过多的问题</h2><ul><li>调整系统内核参数，加速端口回收和开启重用（/etc/sysctl.conf）</li><li>调整短链接为长链接</li></ul><h2 id="TCP可靠的原因"><a href="#TCP可靠的原因" class="headerlink" title="TCP可靠的原因"></a>TCP可靠的原因</h2><ul><li>校验和</li><li>确认应答与序列号</li><li>超时重传</li><li>数据排序</li><li>流量控制</li><li>拥塞控制</li></ul><h2 id="UDP如何实现可靠传输"><a href="#UDP如何实现可靠传输" class="headerlink" title="UDP如何实现可靠传输"></a>UDP如何实现可靠传输</h2><ul><li>添加seq/ack机制，确保数据发送到对端</li><li>添加发送和接收缓冲区，主要是用户超时重传</li><li>添加超时重传机制</li></ul><p>发送端发送数据时，生成一个随机seq=x，然后每一片按照数据大小分配seq。数据到达接收端后接收端放入缓存，并发送一个ack=x的包，表示对方已经收到了数据。发送端收到了ack包后，删除缓冲区对应的数据。时间到后，定时任务检查是否需要重传数据。</p><h2 id="DNS用的是TCP还是UDP"><a href="#DNS用的是TCP还是UDP" class="headerlink" title="DNS用的是TCP还是UDP"></a>DNS用的是TCP还是UDP</h2><p>DNS在区域传输的时候使用TCP协议，其他时候使用UDP协议。 </p><p><strong>DNS区域传输的时候使用TCP协议：</strong></p><ul><li><p>辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。</p></li><li><p>TCP是一种可靠连接，保证了数据的准确性。</p></li></ul><p><strong>域名解析时使用UDP协议：</strong></p><p>客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过三次握手，这样DNS服务器负载更低，响应更快。理论上说，客户端也可以指定向DNS服务器查询时用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。</p><h2 id="GET-和-POST-比较"><a href="#GET-和-POST-比较" class="headerlink" title="GET 和 POST 比较"></a>GET 和 POST 比较</h2><ol><li>GET 用于获取资源，而 POST 用于传输实体主体</li><li>GET请求参数是通过URL传递的，POST请求放在request body中。</li><li>浏览器及服务器对GET请求的URL是有长度限制的，而POST没有。</li><li>GET只接受ASCII字符，而POST没有限制。</li><li>GET请求会被缓存，而POST请求不会，除非手动设置。</li><li>GET 方法是安全的，也是幂等的，而 POST 却不是。</li><li>GET产生一个TCP数据包；POST产生两个TCP数据包。（对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</li></ol><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h2><ol><li><p>原子性（Atomicity）</p><p>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。</p></li><li><p>一致性（Consistency）</p><p>数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。</p></li><li><p>隔离性（Isolation）</p><p>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</p></li><li><p>持久性（Durability）</p><p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</p></li></ol><h2 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h2><ul><li><p>大大加快了数据的检索速度； </p></li><li><p>可以显著减少查询中分组和排序的时间；</p></li><li><p>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性；</p></li><li><p>将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）</p></li><li><p>缺点：建立和维护索引耗费时间空间，更新索引很慢。</p></li></ul><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><ol><li>节省 CPU，避免系统内核级的线程频繁切换，造成的 CPU 资源浪费。而协程是用户态的线程，用户可以自行控制协程的创建于销毁，极大程度避免了系统级线程上下文切换造成的资源浪费。</li><li>节约内存，在 64 位的 Linux 中，一个线程需要分配 8MB 栈内存和 64MB 堆内存，系统内存的制约导致我们无法开启更多线程实现高并发。而在协程编程模式下，可以轻松有十几万协程，这是线程无法比拟的。</li><li>稳定性，前面提到线程之间通过内存来共享数据，这也导致了一个问题，任何一个线程出错时，进程中的所有线程都会跟着一起崩溃。</li><li>开发效率，使用协程在开发程序之中，可以很方便的将一些耗时的 IO 操作异步化，例如写文件、耗时 IO 请求等。</li></ol><h2 id="同步异步-amp-阻塞非阻塞"><a href="#同步异步-amp-阻塞非阻塞" class="headerlink" title="同步异步&amp;阻塞非阻塞"></a>同步异步&amp;阻塞非阻塞</h2><p>同步和异步关注的是消息通信机制 。</p><ul><li>同步是用户线程发起I/O请求后需要等待或者轮询内核I/O操作完成后才能继续执行     </li><li>异步是用户线程发起I/O请求后仍需要继续执行，当内核I/O操作完成后会通知用户线程，或者调用用户线程注册的回调函数 </li></ul><p>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态。</p><ul><li>阻塞是指调用结果返回之前，当前线程会被挂起，I/O操作需要彻底完成后才能返回用户</li><li>非阻塞是指I/O操作被调用后立即返回一个状态值，无需等I/O操作彻底完成</li></ul><h2 id="浅拷贝与深拷贝"><a href="#浅拷贝与深拷贝" class="headerlink" title="浅拷贝与深拷贝"></a>浅拷贝与深拷贝</h2><p>浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。</p><h2 id="赋值和浅拷贝"><a href="#赋值和浅拷贝" class="headerlink" title="赋值和浅拷贝"></a>赋值和浅拷贝</h2><p>当我们把一个对象赋值给一个新的变量时，赋的其实是该对象的在栈中的地址，而不是堆中的数据。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。</p><p>浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。即默认拷贝构造函数只是对对象进行浅拷贝复制(逐个成员依次拷贝)，即只复制对象空间而不复制资源。</p><h2 id="同步和互斥"><a href="#同步和互斥" class="headerlink" title="同步和互斥"></a>同步和互斥</h2><p>同步是一种更为复杂的互斥，而互斥是一种特殊的同步。</p><p>互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。</p><p>同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。</p><h2 id="线程同步方式"><a href="#线程同步方式" class="headerlink" title="线程同步方式"></a>线程同步方式</h2><ol><li><p>临界资源/关键段</p><p>当多个线程访问一个独占性共享资源时，可以使用临界区对象。</p><p>拥有临界区的线程可以访问被保护起来的资源或代码段，其他线程若想访问，则被挂起，直到拥有临界区的线程放弃临界区为止。(临界区只能同一进程中线程使用，不能跨进程使用)。</p><p>临界区一般使用锁的方式来实现，常见的<strong>互斥锁和读写锁</strong>。</p></li><li><p>互斥锁/互斥量</p><p>互斥量多用于多进程之间的线程互斥，用来确保一个线程独占一个资源的访问。而且能正确处理资源遗弃的问题（占有某种资源的进程意外终止后，其它等待该资源的进程能否感知）</p></li><li><p>事件/条件变量</p><p>事件机制，则允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。或者按照条件变量的说法，提供线程之间的一种通知机制。</p></li><li><p>信号量</p><p>一个计数器来限制可以使用某共享资源的线程数目时，可以使用“信号量”对象。</p><p>IPC方式中也有信号量，常常配合ipc共享内存来使用，作为进程之间以及同一进程不同线程间的同步手段。</p></li></ol><p><strong>总结一下：</strong></p><ul><li>临界区和互斥量都有“线程所有权”的概念，所以它们是不能用来实现线程间的同步的，只能用来实现互斥。</li><li>事件和信号量都可以实现线程和进程间的互斥和同步。</li><li>临界区的效率是最高的，因为它不是内核对象。但是临界区不能跨进程使用。</li></ul><h2 id="信号量与互斥锁"><a href="#信号量与互斥锁" class="headerlink" title="信号量与互斥锁"></a>信号量与互斥锁</h2><ul><li>互斥量用于线程的互斥，信号量用于线程的同步。这是互斥量和信号量的根本区别，也就是互斥和同步之间的区别。</li><li>互斥量值只能为0/1，信号量值可以为非负整数。互斥锁使用对同一个资源的互斥的方式达到线程同步的目的，信号量可以同步多个资源以达到多线程同步。</li><li>互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。</li></ul><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>最常用的设计模式之一，保证一个类仅有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。</p><p><strong>实现思路：</strong>私有化它的构造函数，以防止外界创建单例类的对象；使用类的私有静态指针变量指向类的唯一实例，并用一个公有的静态方法获取该实例。</p><p>单例模式有两种实现方法，分别是懒汉和饿汉模式。</p><ul><li>懒汉模式，即非常懒，不用的时候不去初始化，所以在第一次被使用时才进行初始化；</li><li>饿汉模式，即迫不及待，在程序运行时立即初始化。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒汉式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">Singleton</span>()&#123;&#125;;    </span><br><span class="line">        ~<span class="built_in">Singleton</span>()&#123;&#125;;          </span><br><span class="line">        <span class="built_in">Singleton</span>(<span class="keyword">const</span> Singleton&amp;);</span><br><span class="line">        Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">static</span> Singleton instance;</span><br><span class="line">            <span class="keyword">return</span> &amp;instance;</span><br><span class="line">        &#125;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//饿汉式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">Singleton</span>()&#123;&#125;;</span><br><span class="line">        ~<span class="built_in">Singleton</span>()&#123;&#125;;</span><br><span class="line">        <span class="built_in">Singleton</span>(<span class="keyword">const</span> Singleton&amp;);</span><br><span class="line">        Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;);</span><br><span class="line">        <span class="keyword">static</span> Singleton* instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;       </span><br><span class="line">&#125;; </span><br><span class="line">Singleton* Singleton::instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br></pre></td></tr></table></figure><h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><p>大小写对换 : 字符 ^= 32;<br>全转小写 : 字符 |= 32;<br>全转大写 : 字符 &amp;= -33;</p><p>已知先序和后序，不能唯一确定二叉树；<br>已知先序或后序，而又知中序，则能唯一确定二叉树；<br>先序、中序相同时，二叉树没有左子树；<br>后序、中序相同时，二叉树没有右子树；<br>后序、先序相同时，只有一个根节点；</p><h1 id="面试真题"><a href="#面试真题" class="headerlink" title="面试真题"></a>面试真题</h1><h2 id="阿里巴巴"><a href="#阿里巴巴" class="headerlink" title="阿里巴巴"></a>阿里巴巴</h2><h3 id="混合云一面"><a href="#混合云一面" class="headerlink" title="混合云一面"></a>混合云一面</h3><ol><li>C++多态的实现方式</li><li>纯属函数的定义</li><li>基类的析构函数需要定义为虚函数？</li><li>析构函数能抛出异常吗</li><li>A是B的父类，C是B成员对象，构造函数调用顺序</li><li>指针和引用的区别</li><li>const char* 和 char* const 区别</li><li>重写与重载的区别</li><li>static关键字有什么作用？修饰全局变量，修饰局部变量，修饰类成员变量</li><li>#define和函数参数处理的区别（#define宏没有类型，不做任何类型检查）</li><li>strcpy与memcpy 的区别</li><li>strcpy判断拷贝结束（strcpy 是依据/0 作为结束判断的）</li><li>vector 和 map 底层数据结构</li><li>vector 内存管理，容量满了</li><li>头文件#ifdef 作用（防止重复包含头文件的宏）</li><li>设计模式，单类模式，懒汉式和饥汉式，观察者模式，工厂模式</li><li>描述快排，时间复杂度，稳定吗</li><li>数据库，左连接和右链接区别</li><li>先序遍历，中序，后序</li><li>判断是否是完全二叉树</li><li>vector 和 map 迭代器失效场景</li><li>重写String类，构造函数，拷贝构造函数，析构函数，重载运算符</li><li>最小栈的实现</li><li>链表O(1) 删除一个结点，已知结点的地址</li></ol><h3 id="云一面"><a href="#云一面" class="headerlink" title="云一面"></a>云一面</h3><ol><li>C++版本新特性</li><li>nullptr 解决什么问题的<ul><li>nullptr什么可以转换成任何指针类型，可以用于抛出异常。</li><li>使用nullptr整型和指针类型的重载，不会产生二义性导致编译失败。</li><li>0和空指针分别表示不同的含义，使用nullptr可以更好的支持模板编程。</li><li>使用nullptr使代码更安全，让用户编写代码更清晰直观。</li></ul></li><li>智能指针有哪些</li><li>内存空间上unique_ptr 和普通指针有什么区别</li><li>智能指针的自定义删除器</li><li>多线程同时读或者修改一个变量的问题</li><li>多线程同步机制</li><li>多线程同时操作一个int类型，有没有其他办法（原子变量）</li><li>C++的容器，适合什么场景</li><li>如何判断链表有环</li><li>数字n的阶乘结尾有多少连续的0</li></ol><h2 id="深信服"><a href="#深信服" class="headerlink" title="深信服"></a>深信服</h2><ol><li>C++多态，面向对象讲一下</li><li>虚函数为什么能实现多态？实现原理</li><li>webserver线程设计</li><li>Proactor 模式和Reactor 模式区别</li><li>读写锁的特点，与其它锁的区别</li><li>线程设置数量</li><li>OSI七层模型简单讲一下</li><li>IP分类</li><li>TCP和UDP区别</li><li>TCP粘包问题</li></ol><h2 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h2><ol><li>TCP三次握手，两次握手？</li><li>同步异步？阻塞非阻塞？</li><li>select、poll和epoll</li><li>B+树和B树区别</li><li>指针和引用的区别</li><li>析构函数为虚函数</li><li>浅拷贝和深拷贝</li><li>一个类的对象的成员是另一个类的对象，深浅拷贝</li><li>赌博游戏：1、一次一元，一万次就停止；2、一万元本金不停的投</li><li>字符串反转 <a href="http://www.toutiao.com/">www.toutiao.com</a> –&gt;com.toutiao.www</li></ol><h2 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h2><ol><li>哈希表底层实现</li><li>get、post方法</li><li>http和https</li><li>短链接和长连接</li><li>左值右值</li><li>constexpr和const</li><li>unique_ptr原理</li><li>判断是否为子串</li><li>2^x + 2^8 +2^11 为完美平方数求x</li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试汇总 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> CS基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>31.下一个排列-LeetCode</title>
      <link href="2022/02/16/31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97-LeetCode/"/>
      <url>2022/02/16/31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97-LeetCode/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。</p><p>例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。<br>整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p><p>例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。<br>类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。<br>而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。<br>给你一个整数数组 nums ，找出 nums 的下一个排列。</p><p>必须 原地 修改，只允许使用额外常数空间。</p><p><strong>示例 1：</strong></p><p>输入：nums = [1,2,3]<br>输出：[1,3,2]</p><p><strong>示例 2：</strong></p><p>输入：nums = [3,2,1]<br>输出：[1,2,3]</p><p><strong>示例 3：</strong></p><p>输入：nums = [1,1,5]<br>输出：[1,5,1]</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/next-permutation">https://leetcode-cn.com/problems/next-permutation</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h1 id="思路及解法"><a href="#思路及解法" class="headerlink" title="思路及解法"></a>思路及解法</h1><p>题目扒拉扒拉说明有点反人类，简单的说就是由数组的元素组成的数，如nums = [1,2,3]，则可以理解为找出下一个比 123大的数，那就是132啦，如果没有下一个更大的数(如：321)，则找出最小的数（开端了属于是）。</p><p>C++标准库函数 <a href="https://en.cppreference.com/w/cpp/algorithm/next_permutation"><code>next_permutation</code></a> 直接一步到位(hhhh)。</p><ol><li>既然是找出下一个更大的排列（数），想到从左边找到一个<strong>较小数</strong>与右边一个<strong>较大数</strong>交换，那么整个排列就会变大。（较小数是相对于右邻数而言，较大数是相对于较小数而言）</li><li>同时要让这个<strong>较小数</strong>尽量靠右（<strong>小</strong>是主要的），而<strong>较大数</strong>尽可能小（但要大于较小数）。</li><li>当交换完成后，「较大数」右边的数需要翻转排列。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = nums.<span class="built_in">size</span>()<span class="number">-2</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; nums[i]&gt;=nums[i+<span class="number">1</span>])  <span class="comment">// 从右向左遍历(使[较小数]尽可能靠右，先到先得)</span></span><br><span class="line">            i--;  <span class="comment">// 找到小的num[i](第一个小于右邻数的index)</span></span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">0</span>)&#123;  <span class="comment">// 若i=-1没有找到说明是num最大排列</span></span><br><span class="line">            <span class="keyword">int</span> j = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; nums[i]&gt;=nums[j])  <span class="comment">// 从右向左遍历找到第一个大于num[i]的index</span></span><br><span class="line">                j--;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i],nums[j]);  <span class="comment">// 交换</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>()+i+<span class="number">1</span>,nums.<span class="built_in">end</span>());  <span class="comment">// 从i位置后翻转</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《C++ Primer》学习笔记</title>
      <link href="2022/02/15/%E3%80%8AC-Primer%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2022/02/15/%E3%80%8AC-Primer%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>C++ 在 C 语言的基础上添加了<strong>面向对象编程和泛型编程</strong></p><ul><li><p>C++继承了C 语言高效、简洁、快速和可移植性的传统。</p></li><li><p>C++面句对象的特性带来了全新的编程方法，这种方法是为应付复杂程度不断提商的现代编程任务而设计的。</p></li><li><p>C++的模板特性提供了一种全新的编程方法——泛型编程。</p></li></ul><p>iostream 库包含两个基础类型 <strong>istream</strong> 和 <strong>ostream</strong>，分别表示输入流和输出流。标准输入 cin  是 istream 类型的对象，标准输出 cout  是 ostream 类型的对象， ostream 对象还有 <strong>cerr</strong>（警告和错误信息）和 <strong>clog</strong>（一般信息）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout&lt;&lt;<span class="string">&quot;enter :&quot;</span>&lt;&lt;std::endl;</span><br></pre></td></tr></table></figure><p>写入 endl 的效果是结束当前行，并将与设备关联的缓冲区(buffer)中的内容刷到设备中。</p><h1 id="变量和基本类型"><a href="#变量和基本类型" class="headerlink" title="变量和基本类型"></a>变量和基本类型</h1><h2 id="内置类型和变量"><a href="#内置类型和变量" class="headerlink" title="内置类型和变量"></a>内置类型和变量</h2><p>算术类型的尺寸（所占比特数）在不同机器上有所差别，下表列出C++标准规定的最小尺寸。</p><p><img src="arithmetic_type.png"></p><p>类型选择经验建议：</p><ul><li>当明确知晓数值不可能为负时，选用无符号类型</li><li>使用 int 执行整数运算</li><li>在算术运算中不要使用 char 或 bool</li><li>执行浮点数运算选用 double</li></ul><p><strong>初始化不是赋值,初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。</strong></p><p>C++11新标准的一部分，用花括号来初始化变量得到了全面应用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> a = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">a</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>定义于函数体内的内置类型变量将<strong>不被初始化</strong>，其值未定义。类的对象如果没有显式地初始化，则其值由类确定。</p><p>如果想声明一个变量而非定义它，就在变量名前添加关键字 <strong>extern</strong>，而且不要显式地初始化变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i; <span class="comment">// 声明 i </span></span><br><span class="line"><span class="keyword">int</span> j;  <span class="comment">// 声明并定义 j</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>; <span class="comment">// 定义 i </span></span><br></pre></td></tr></table></figure><p><strong>变量能且只能被定义一次，但是可以被多次声明。</strong></p><p><strong>引用（reference）</strong>为对象起了另外一个名字，引用类型引用(refers to)另外一种类型。通过将声明符写成 &amp;d 的形式来定义引用类型，其中 d 是声明的变量名:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;refVal = val;</span><br><span class="line"><span class="keyword">int</span> &amp;refVal2;  <span class="comment">// 报错：引用必须初始化</span></span><br></pre></td></tr></table></figure><p>引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字，所以不能定义引用的引用。</p><p><strong>指针（pointer）</strong>是“指向（point to)”另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问。然而指针与引用相比又有很多不同点。</p><ul><li><p>其一，指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。</p></li><li><p>其二，指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ip1, *ip2;  <span class="comment">// ip1和ip2都是指向int型对象的指针</span></span><br></pre></td></tr></table></figure><p><strong>指针的类型要与它所指的对象严格匹配</strong>，但是有两个例外。</p><ul><li>允许一个指向常量的指针指向一个非常量</li></ul><p><strong>指针的值（即地址）</strong>应属于下列4种状态之一：</p><ul><li>指向一个对象</li><li>指向紧邻对象所占空间的下一个位置</li><li>空指针，意味着指针没有指向任何对象</li><li>无效指针，上述情况之外的其他值</li></ul><p>当用到一个预处理变量时，预处理器会自动地将它替换为实际值，因此用NULL初始化指针和用0初始化指针是一样的。在新标准下，现在的C++程序最好使用nullptr，同时尽量避免使用NULL。</p><p>void* 是一种特殊的指针类型，可用于存放任意对象的地址。一个void*指针存放着一个地址，这一点和其他指针类似。不同的是，我们对该地址中到底是个什么类型的对象并不了解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> obj=<span class="number">3.14</span>, *pd = &amp;obj; </span><br><span class="line"><span class="keyword">void</span> *pv = &amp;obj; <span class="comment">// void* 能存放任意类型对象的地址</span></span><br><span class="line">pv = pd; <span class="comment">// pv可以存放任意类型的指针</span></span><br></pre></td></tr></table></figure><p>利用void* 指针能做的事儿比较有限：拿它和别的指针比较、作为函数的输入或输出，或者赋给另外一个void* 指针。不能直接操作void* 指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。</p><p><strong>指向指针的指针</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> *pi = &amp;ival; <span class="comment">// pi指向一个int型的数</span></span><br><span class="line"><span class="keyword">int</span> **ppi = &amp;pi; <span class="comment">// ppi指向一个int型的指针</span></span><br></pre></td></tr></table></figure><p><strong>指向指针的引用</strong></p><p>引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *p;  <span class="comment">// p是一个int型指针</span></span><br><span class="line"><span class="keyword">int</span> *&amp;r = p;  <span class="comment">// r是一个对指针p的引用</span></span><br><span class="line">r = &amp;i;  <span class="comment">// 令p指向i</span></span><br><span class="line">*r = <span class="number">0</span>; <span class="comment">// i = 0</span></span><br></pre></td></tr></table></figure><p><strong>面对一条比较复杂的指针或引用的声明语句时，从右向左阅读有助于弄清楚它的真实含义。</strong></p><h2 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h2><p>有时我们希望定义这样一种变量，它的值不能被改变。因为const对象一旦创建后其值就不能再改变，所以<strong>const对象必须初始化。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> buff = <span class="number">512</span>;</span><br><span class="line">buff = <span class="number">1024</span>;  <span class="comment">// 错误，赋值引发错误</span></span><br></pre></td></tr></table></figure><p>如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字。<br>可以把引用绑定到 const 对象上，就像绑定到其他对象上一样，我们称之为<strong>对常量的引用</strong>，简称<strong>常量引用</strong>。与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = ci;  <span class="comment">//正确:引用及其对应的对象都是常量</span></span><br><span class="line">r1 = <span class="number">42</span>;  <span class="comment">//错误</span></span><br><span class="line"><span class="keyword">int</span> &amp;r2 = ci;  <span class="comment">//错误：试图让非常量引用指向一个常量对象</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = i; <span class="comment">//允许将const int&amp;绑定到一个普通int对象上</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = <span class="number">66</span>; <span class="comment">// 正确:r3是一个常量引用</span></span><br></pre></td></tr></table></figure><p>与引用一样，也可以令指针指向常量或非常量，<strong>指向常量的指针</strong>(pointer to const)不能用于改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">double</span> *ptr = &amp;pi;  <span class="comment">//错误：ptr是一个普通指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cptr = &amp;pi;  </span><br><span class="line">*cptr = <span class="number">4</span>;  <span class="comment">//错误：不能给*cotr赋值</span></span><br></pre></td></tr></table></figure><p>前面提到，指针的类型必须与其所指对象的类型一致，但是有两个例外。第一种例外情况是允许令一个指向常量的指针指向一个非常量对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;  <span class="comment">// dval是一个双精度浮点数，它的值可以改变</span></span><br><span class="line">cptr = &amp;dval;  <span class="comment">// 正确:但是不能通过cptr改变dval的值</span></span><br></pre></td></tr></table></figure><p><strong>和常量引用一样，指向常量的指针也没有规定其所指的对象必须是一个常量。</strong></p><p><strong>const 指针</strong><br>指针是对象而引用不是，因此就像其他对象类型一样，允许把指针本身定为常量。<strong>常量指针</strong>(const pointer)必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能再改变了。把 * 放在const关键字之前用以说明指针是一个常量，这样的书写形式隐含着一层意味，即不变的是指针本身的值而非指向的那个值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> errNumb = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> curErr = &amp;errNumb; <span class="comment">// curErr将一直指向errNumb</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *<span class="keyword">const</span> pip = &amp;pi; <span class="comment">// pip是一个指向常量对象的常量指针</span></span><br></pre></td></tr></table></figure><ul><li>顶层 const 表示指针本身是个常量</li><li>底层 const 表示指针所指对象是个常量</li></ul><p><strong>常量表达式</strong>是指值不会改变并且在编译过程就能得到计算结果的表达式。显然，字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。</p><p>C++11新标准规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> mf = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> mf = mf+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> mf = <span class="built_in">size</span>();  <span class="comment">//只有当size是个constexpr函数时才正确</span></span><br></pre></td></tr></table></figure><p><strong>在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关。</strong></p><h2 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h2><p><strong>类型别名</strong>是一个名字，它是某种类型的同义词。使用类型别名有很多好处，它让复杂的类型名字变得简单明了、易于理解和使用，还有助于程序员清楚地知道使用该类型的真实目的。<br>有两种方法可用于定义类型别名。传统的方法是使用关键字<strong>typedef</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> wages;  <span class="comment">// wages是double的同义词</span></span><br><span class="line"><span class="keyword">typedef</span> wages base,*p;  <span class="comment">//base是double的同义词,p是double*的同义词</span></span><br></pre></td></tr></table></figure><p>新标准规定了一种新的方法，使用<strong>别名声明</strong>来定义类型的别名：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> SI = sales_item;  <span class="comment">//SI工是sales_item的同义词</span></span><br></pre></td></tr></table></figure><p><strong>auto类型说明符</strong>能让编译器替我们去分析表达式所属的类型。和原来那些只对应一种特定类型的说明符（比如 double)不同，auto 让编译器通过初始值来推算变量的类型。显然，auto定义的变量必须有初始值。</p><p>希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。C++11 新标准引入了第二种<strong>类型说明符decltype</strong>，它的作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(<span class="built_in">f</span>()) sum = x;  <span class="comment">// sum的类型就是函数f的返回类型</span></span><br></pre></td></tr></table></figure><p>编译器并不实际调用函数f，而是使用当调用发生时f的返回值类型作为sum的类型。换句话说，编译器为sum 指定的类型是什么呢？就是假如f被调用的话将会返回的那个类型。</p><p>如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。有些表达式将向decltype返回一个引用类型。一般来说当这种情况发生时，意味着该表达式的结果对象能作为一条赋值语句的左值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>,*p = &amp;i, &amp;r = i;</span><br><span class="line"><span class="keyword">decltype</span> (r + <span class="number">0</span>) b;  <span class="comment">//正确:加法的结果是int，因此 b是一个(未初始化的) int</span></span><br><span class="line"><span class="keyword">decltype</span> (*p) c;  <span class="comment">//错误:c是int&amp;，必须初始化</span></span><br></pre></td></tr></table></figure><p>因为r是一个引用，因此 decltype(r)的结果是引用类型。如果想让结果类型是r所指的类型，可以把r作为表达式的一部分，如r+0，显然这个表达式的结果将是一个具体值而非一个引用。</p><p>另一方面，如果表达式的内容是解引用操作，则decltype 将得到引用类型。正如我们所熟悉的那样，解引用指针可以得到指针所指的对象，而且还能给这个对象赋值。因此，<strong>decltype (*p)的结果类型就是int&amp;，而非int。</strong></p><p>如果 decltype 使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上了一层或多层括号，编译器就会把它当成是一个表达式。变量是一种可以作为赋值语句左值的特殊表达式，所以这样的decltype就会得到引用类型。</p><p><strong>切记：decltype ((variable))（双层括号)的结果永远是引用，而decltype(variable)结果只有当 variable本身就是一个引用时才是引用。</strong></p><ul><li><p>#define 是一条预处理指令，用于定义一个预处理变量。</p></li><li><p>#endif 是条预处理指令，用于结束一个#ifdef 或 #ifndef 区域。</p></li><li><p>#ifdef 是一条预处理指令，用于判断给定的变量是否已经定义。</p></li><li><p>#ifndef 是一条预处理指令，用于判断给定的变量是否尚未定义。</p></li></ul><h1 id="字符串、向量和数组"><a href="#字符串、向量和数组" class="headerlink" title="字符串、向量和数组"></a>字符串、向量和数组</h1><h2 id="命名空间声明"><a href="#命名空间声明" class="headerlink" title="命名空间声明"></a>命名空间声明</h2><p>我们用到的库函数基本上都属于命名空间 std，使用 using 声明，就可以直接访问命名空间中的名字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>::name;</span><br><span class="line"><span class="comment">// 例如：</span></span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br></pre></td></tr></table></figure><p><strong>头文件不应包含using声明：</strong>这是因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件里有某个using声明,那么每个使用了该头文件的文件就都会有这个声明。对于某些程序来说，由于不经意间包含了一些名字，反而可能产生始料未及的名字冲突。</p><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p>使用 getlin 读取一整行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string line;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">getlin</span>(cin,line))</span><br><span class="line">cout&lt;&lt;line&lt;&lt;nedl;  <span class="comment">//line不包含换行符</span></span><br></pre></td></tr></table></figure><p>size 函数返回值类型是 string::size_type。</p><p>在cctype头文件定义了一组标准库函数，常用如下：</p><ul><li>isalnum(c) c 是字母或数字时为真</li><li>isalpha(c) c 是字母时为真</li><li>islower(c)  c 是小写字母为真</li><li>isupper(c) c 是大写字母为真</li><li>isdigit(c) c 是数字时为真</li><li>ispunct() c 是标点符号为真</li><li>tolower(c) 如果 c 是大写字母，输出小写，否则原样输出</li><li>toupper(c) 如果 c 是小写字母，输出大写，否则原样输出</li></ul><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><p>C++既有类模板（class template)，也有函数模板，其中vector是一个类模板。</p><p>empty 检查 vector 对象是否包含元素然后返回一个布尔值; </p><p>size 则返回 vector 对象中元素的个数，返回值的类型是由 vector 定义的 size_type类型。</p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>迭代器而言，其对象是容器中的元素或者string对象中的字符。使用迭代器可以访问某个元素，迭代器也能从一个元素移动到另外一个元素。</p><p>和指针不一样的是，获取迭代器不是使用取地址符，有迭代器的类型同时拥有返回迭代器的成员。比如，这些类型都拥有名为 begin 和 end 的成员：</p><ul><li> begin 成员负责返回指向第一个元素（或第一个字符）的迭代器</li><li>end 成员则负责返回指向容器“尾元素的下一位置”的迭代器</li></ul><p>就像不知道string和 vector的size_type成员到底是什么类型一样，一般来说我们也不知道(其实是无须知道)迭代器的精确类型。而实际上，那些拥有迭代器的标准库类型使用 iterator 和 vector<int>:: 来表示迭代器的类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">string::iterator it2;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;::vector&lt;<span class="keyword">int</span>&gt; it3;  <span class="comment">// it3只能读元素</span></span><br></pre></td></tr></table></figure><p><strong>谨记，但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素。</strong></p><p>string 和 vector 的迭代器提供了更多额外的运算符，一方面可使得迭代器的每次移动跨过多个元素，另外也支持迭代器进行关系运算。所有这些运算被称作迭代器运算，其细节如下：</p><table><thead><tr><th>迭代器运算</th><th>解释</th></tr></thead><tbody><tr><td>iter + n</td><td>迭代器指示的新位置与原来相比向前移动了n个元素</td></tr><tr><td>iter - n</td><td>迭代器指示的新位置与原来相比向前移动了n个元素</td></tr><tr><td>iter += n</td><td>将iter加n的结果赋给iter</td></tr><tr><td>iter -= n</td><td>将iter减n的结果赋给iter</td></tr><tr><td>iter1 - iter2</td><td>两个迭代器相减的结果是它们之间的距离，可正可负</td></tr><tr><td>&gt;、&gt;= 、&lt;、&lt;=</td><td>位置在前小</td></tr></tbody></table><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>C++11新标准引入了两个名为begin和end的函数。这两个函数与容器中的两个同名成员功能类似，不过数组毕竟不是类类型，因此这两个函数不是成员函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *beg = <span class="built_in">begin</span>(a);  <span class="comment">//指向a首元素的指针</span></span><br><span class="line"><span class="keyword">int</span> *last = <span class="built_in">end</span>(a);  <span class="comment">//指向a尾元素下一个位置的指针</span></span><br></pre></td></tr></table></figure><p>定义指向多维数组的指针时，千万别忘了这个多维数组实际上是数组的数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ar[<span class="number">3</span>][<span class="number">4</span>]; <span class="comment">// 大小为3的数组，每个元素是含有4个整数的数组</span></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*p)[<span class="number">4</span>] = ar;  <span class="comment">//p 指向含有4个整数的数组</span></span><br><span class="line">p = &amp;ar[<span class="number">2</span>];  <span class="comment">// p指向ar的尾元素</span></span><br></pre></td></tr></table></figure><h1 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h1><p>递增和递减运算符有两种形式：前置版本(++i)和后置版本(i++)</p><ul><li><strong>前置版本</strong>的递增运算符避免了不必要的工作，它把值加 1 后直接返回改变了的运算对象。</li><li>后置版本需要将原始值存储下来以便于返回这个未修改的内容。如果我们不需要修改前的值，那么后置版本的操作就是一种浪费。</li></ul><p>成员访问运算符：箭头运算符与点运算符，表达式 ptr-&gt;mem 等价于 (*ptr).mem;</p><p>sizeof 运算符返回一条表达式或一个类型名字所占的字节数。</p><ul><li>对char或者类型为char的表达式执行sizeof运算，结果得1。</li><li>对引用类型执行 sizeof 运算得到被引用对象所占空间的大小。</li><li>对指针执行 sizeof 运算得到指针本身所占空间的大小。</li><li>对解引用指针执行 sizeof 运算得到指针指向的对象所占空间的大小，指针不需有效。</li><li>对数组执行 sizeof 运算得到整个数组所占空间的大小，等价于对数组中所有的元素各执行一次 sizeof 运算并将所得结果求和。注意，sizeof 运算不会把数组转换成指针来处理。<strong>sizeof(arr)/sizeof(*arr) 数组元素数量。</strong></li><li>对 string 对象或 vector 对象执行 sizeof 运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。</li></ul><h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><p>try 语句块，异常处理部分使用 try 语句块处理异常。try 语句块以关键字 try 开始，并以一个或多个 catch 子句结束。try 语句块中代码抛出的异常通常会被某个catch 子句处理。因为 catch 子句“处理”异常，所以它们也被称作异常处理代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  program-statements</span><br><span class="line">&#125;<span class="built_in"><span class="keyword">catch</span></span>(exception-declaration)&#123;</span><br><span class="line">  handlers-statements</span><br><span class="line">&#125;<span class="built_in"><span class="keyword">catch</span></span>(exception-declaration)&#123;</span><br><span class="line">  handlers-statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h2><p>一个典型的函数定义包括以下部分：返回类型、函数名字、由0个或多个形参组成的列表以及函数体。其中，形参以逗号隔开，形参的列表位于一对圆括号之内。函数执行的操作在语句块中说明，该语句块称为函数体( function body)。</p><p>在C++语言中，<strong>名字有作用域，对象有生命周期</strong></p><p>形参和函数体内部定义的变量统称为<strong>局部变量</strong>。它们对函数而言是“局部”的，仅在函数的作用域内可见，同时局部变量还会<strong>隐藏</strong>在外层作用域中同名的其他所有声明中。</p><p>某些时候，有必要令局部变量的生命周期贯穿函数调用及之后的时间。可以将局部变量定义成 <strong>static 类型</strong>从而获得这样的对象。<strong>局部静态对象</strong>在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。</p><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p><strong>使用引用传参尽量避免拷贝</strong>，如果函数无须改变引用形参的值，最好将其声明为<strong>常量引用</strong>。</p><p>void fcn (const int i) {/* fcn能够读取i，但是不能向i写值*/ }</p><p>调用 fcn 函数时，既可以传入 const int 也可以传入 int。</p><p>因为不能拷贝数组，所以我们无法以值传递的方式使用数组参数。因为数组会被转换成指针，所以当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>* a)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a[<span class="number">10</span>])</span></span>;</span><br></pre></td></tr></table></figure><p>数组引用形参，引用形参绑定到对应的实参上，也就是绑定到数组上：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> (&amp;arr)[<span class="number">10</span>])</span></span>;  <span class="comment">//&amp;arr括号不能少</span></span><br></pre></td></tr></table></figure><p>传递多维数组，和所有数组一样，当将多维数组传递给函数时，真正传递的是指向数组首元素的指针，指针是一个指向数组的指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> (*matrix)[<span class="number">10</span>])</span></span>; <span class="comment">//*matrix括号不能少</span></span><br><span class="line"><span class="keyword">int</span> *matrix[<span class="number">10</span>];  <span class="comment">//10个指针构成的数组</span></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*matrix)[<span class="number">10</span>];  <span class="comment">//指向含有10个整数的数组的指针</span></span><br></pre></td></tr></table></figure><p>为了编写能处理不同数量实参的函数，C++11 新标准提供了两种主要的方法：</p><ul><li>如果所有的实参类型相同，可以传递一个名为initializer_list的标准库类型</li><li>如果实参的类型不同，可以编写一种特殊的函数，也就是所谓的可变参数模板</li><li>省略符形参，这种功能一般只用于与C函数交互的接口程序</li></ul><p>initializer_list 形参</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">initializer_list&lt;T&gt; lst;  <span class="comment">//默认初始化;T类型元素的空列表</span></span><br><span class="line">initializer_list&lt;T&gt; lst&#123;a,b,c...&#125;; <span class="comment">//lst的元素数量和初始值一样多;lst的元素是对应初始值的副本:列表中的元素是const</span></span><br><span class="line"><span class="built_in">lst2</span>(lst);  <span class="comment">//拷贝或赋值一个initializer_list对象不会拷贝列表中的元素;拷贝后，原始列表和副本共享元素</span></span><br><span class="line">lst2 = lst;  </span><br><span class="line">lst.<span class="built_in">size</span>();  <span class="comment">//列表中的元素数量</span></span><br><span class="line">lst.<span class="built_in">begin</span>();  <span class="comment">//返回指向lst中首元素的指针</span></span><br><span class="line">lst.<span class="built_in">end</span>();  <span class="comment">//返回指向lst中尾元素下一位置的指针</span></span><br></pre></td></tr></table></figure><p>和vector一样，initializer_list也是一种模板类型。定义initializer_list对象时，必须说明列表中所含元素的类型:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">initializer_list&lt;string&gt; ls; <span class="comment">// initializer_list的元素类型是string</span></span><br><span class="line">initializer_list&lt;<span class="keyword">int</span>&gt; li;  <span class="comment">// initializer_list的元素类型是int</span></span><br></pre></td></tr></table></figure><p>和vector不一样的是，initializer_list对象中的元素永远是常量值，我们无法改变initializer_list对象中元素的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">msg</span><span class="params">(initializer_list&lt;string&gt; ls)</span></span>&#123;&#125;  <span class="comment">//定义</span></span><br><span class="line"><span class="built_in">msg</span>(&#123;<span class="string">&quot;hhh&quot;</span>,<span class="string">&quot;assd&quot;</span>&#125;);  <span class="comment">//调用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(parm_list,...)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="return语句"><a href="#return语句" class="headerlink" title="return语句"></a>return语句</h2><p>没有返回值的return语句只能用在返回类型是void 的函数中。返回void的函数不要求必须有return语句，因为在这类函数的最后一句后面会<strong>隐式地执行return</strong>。</p><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>函数重载的规则：</p><ul><li>函数名称必须相同</li><li>参数列表必须不同（个数不同、类型不同、参数排列顺序不同等）</li><li>函数的返回类型可以相同也可以不相同</li><li>仅仅返回类型不同不足以成为函数的重载</li></ul><h2 id="特殊用途语言特性"><a href="#特殊用途语言特性" class="headerlink" title="特殊用途语言特性"></a>特殊用途语言特性</h2><p>默认实参：为一个或多个形参定义默认值，不过需要注意的是，一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。</p><p>内联机制用于优化规模较小、流程直接、频繁调用的函数。</p><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>函数指针指向的是函数而非对象。和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">fun</span><span class="params">(string s)</span></span>;</span><br><span class="line"><span class="built_in"><span class="keyword">bool</span></span> (*pf)(string s);</span><br><span class="line">pf = fun;  <span class="comment">//pf指向fun函数，</span></span><br><span class="line">pf = &amp;fun; <span class="comment">//等价的赋值语句，取地址符可选</span></span><br><span class="line"><span class="keyword">bool</span> b1 = <span class="built_in">pf</span>(<span class="string">&quot;hello&quot;</span>);  <span class="comment">//等价调用fun</span></span><br><span class="line"><span class="keyword">bool</span> b2 = (*pf)(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>使用class和struct定义类唯一的区别就是默认的访问权限。</p><p>友元关系不存在传递性，每个类负责控制自己的友元类或友元函数。</p><p>如果成员是 const、引用，或者属于某种未提供默认构造函数的类类型,我们必须通过构造函数初始值列表为这些成员提供初值。</p><p>静态数据成员不属于类的任何一个对象，所以它们并不是在创建类的对象时被定义的。这意味着它们不是由类的构造函数初始化的。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ Primer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu中实现docker搭建jenkins环境</title>
      <link href="2022/02/07/ubuntu%E4%B8%AD%E5%AE%9E%E7%8E%B0docker%E6%90%AD%E5%BB%BAjenkins%E7%8E%AF%E5%A2%83/"/>
      <url>2022/02/07/ubuntu%E4%B8%AD%E5%AE%9E%E7%8E%B0docker%E6%90%AD%E5%BB%BAjenkins%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<p>做项目集成使用 Jenkins 工具，环境搭建一些记录。</p><h1 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h1><ol><li>Ubuntu系统（Ubuntu 18.04 LTS）</li><li>Docker（v.20.10.12） </li><li>Jenkins（v.2.319.2）</li></ol><p>新创建的云服务器 Ubuntu 系统远程登录 ssh 默认是关闭的，需要在 <strong>/etc/ssh/sshd_config</strong> 文件中增加 <strong>PermitRootLogin yes</strong></p><p>Ubuntu 的软件源配置文件是 <strong>/etc/apt/sources.list</strong>。将系统自带的该文件做个备份，将该文件替换为下面内容，即可使用 NJU软件源镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span></span><br><span class="line">deb https://mirror.nju.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirror.nju.edu.cn/ubuntu/ bionic main restricted universe multiverse</span></span><br><span class="line">deb https://mirror.nju.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirror.nju.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span></span><br><span class="line">deb https://mirror.nju.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirror.nju.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span></span><br><span class="line">deb https://mirror.nju.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirror.nju.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 预发布软件源，不建议启用</span></span><br><span class="line"><span class="comment"># deb https://mirror.nju.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span></span><br><span class="line"><span class="comment"># deb-src https://mirror.nju.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span></span><br></pre></td></tr></table></figure><p>再输入命令更新源，最后输入命令更新一下软件即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure><h1 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h1><p>如果你过去安装过 docker，先删掉：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove docker docker-engine docker.io</span><br></pre></td></tr></table></figure><p>首先安装依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install apt-transport-https ca-certificates curl gnupg2 software-properties-common</span><br></pre></td></tr></table></figure><p>信任 Docker 的 GPG 公钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure><p>注意这一步多半会报错 timeout，解决方案：</p><p> 1）先把官方GPG key下载到本地，是一个gpg文件：<a href="https://download.docker.com/linux/ubuntu/gpg">https://download.docker.com/linux/ubuntu/gpg</a></p><p>2）下载到本地后，采用如下命令，安装官方GPG key：<strong>sudo apt-key add /path/gpg</strong>（gpg文件路径）</p><p>添加软件仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository \</span><br><span class="line">   <span class="string">&quot;deb [arch=amd64] https://mirror.nju.edu.cn/docker-ce/linux/ubuntu \</span></span><br><span class="line"><span class="string">   <span class="subst">$(lsb_release -cs)</span> stable&quot;</span></span><br></pre></td></tr></table></figure><p>更新 apt 软件包缓存，并安装 docker-ce：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure><p>镜像加速：</p><p>在配置文件 <code>/etc/docker/daemon.json</code> 中加入如下内容（如果文件不存在请新建该文件）：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://docker.nju.edu.cn/&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新启动docker：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><p>测试 Docker 是否安装正确：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm hello-world</span><br><span class="line"></span><br><span class="line"> Unable to find image <span class="string">&#x27;hello-world:latest&#x27;</span> locally</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">2db29710123e: Pull complete </span><br><span class="line">Digest: sha256:507ecde44b8eb741278274653120c2bf793b174c06ff4eaa672b713b3263477b</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the <span class="string">&quot;hello-world&quot;</span> image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image <span class="built_in">which</span> runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, <span class="built_in">which</span> sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"> $ docker run -it ubuntu bash</span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://hub.docker.com/</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/get-started/</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="安装Jenkins"><a href="#安装Jenkins" class="headerlink" title="安装Jenkins"></a>安装Jenkins</h1><p>Jenkins 官方文档建议使用的 Docker 镜像是 jenkinsci/blueocean image，该镜像包含当前的长期支持 (LTS) 的 Jenkins 版本 （可以投入使用） ，捆绑了所有Blue Ocean插件和功能。这意味着你不需要单独安装Blue Ocean插件。</p><p>这里我使用的是 jenkinsci/blueocean 镜像，docker pull命令拉取：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull jenkinsci/blueocean</span><br></pre></td></tr></table></figure><p>查看本地镜像仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br><span class="line"></span><br><span class="line">REPOSITORY            TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">jenkinsci/blueocean   latest    71d1686eed44   23 hours ago   582MB</span><br><span class="line">hello-world           latest    feb5d9fea6a5   4 months ago   13.3kB</span><br></pre></td></tr></table></figure><p>启动 Jenkins 容器应用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> docker run \</span><br><span class="line">   --name jenkins-blueocean \</span><br><span class="line">   -d \</span><br><span class="line">   -p 8080:8080 \</span><br><span class="line">   -p 50000:50000 \</span><br><span class="line">   -v jenkins-data:/var/jenkins_home \</span><br><span class="line">   jenkinsci/blueocean</span><br><span class="line">   </span><br><span class="line">1c095de1519c16a1bfcf9a4fd6077e2099c1547a4f8cd68565746306279f57ab</span><br></pre></td></tr></table></figure><h1 id="配置Jenkins"><a href="#配置Jenkins" class="headerlink" title="配置Jenkins"></a>配置Jenkins</h1><p>以上如果一切正常，现在就可以通过 http://&lt;ip-address&gt;:8080 访问 Jenkins 的 Web 界面了。</p><p><img src="gettingStarted.png"></p><p>先进入到容器，再去查看对应的文件 initialAdminPassword 内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it jenkins-blueocean /bin/bash</span><br><span class="line"></span><br><span class="line">bash-5.1$ cat /var/jenkins_home/secrets/initialAdminPassword</span><br><span class="line"></span><br><span class="line">b6f6d08fcc474178833001d1fc79be62</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>448.找到所有数组中消失的数字-LeetCode</title>
      <link href="2022/01/19/448-%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97-LeetCode/"/>
      <url>2022/01/19/448-%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97-LeetCode/</url>
      
        <content type="html"><![CDATA[<p>给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内但没有出现在 nums 中的数字，并以数组的形式返回结果。</p><p><strong>示例 1：</strong></p><p>输入：nums = [4,3,2,7,8,2,3,1]<br>输出：[5,6]</p><p><strong>示例 2：</strong></p><p>输入：nums = [1,1]<br>输出：[2]</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array">https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p><strong>将所有正数作为数组下标，置对应数组值为负值。那么，仍为正数的位置即为（未出现过）消失的数字</strong></p><p><strong>举个例子：</strong></p><ul><li><strong>原始数组：[4,3,2,7,8,2,3,1]</strong></li><li><strong>重置后为：[-4,-3,-2,-7,<code>8</code>,<code>2</code>,-3,-1]</strong></li></ul><p><strong>结论：[8,2] 分别对应的index为[5,6]（消失的数字）</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findDisappearedNumbers</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">            nums[<span class="built_in">abs</span>(nums[i])<span class="number">-1</span>] = -<span class="built_in">abs</span>(nums[<span class="built_in">abs</span>(nums[i])<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>) res.<span class="built_in">push_back</span>(i+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据上面的思路，自己写了个比较弱的解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findDisappearedNumbers</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="function">set&lt;<span class="keyword">int</span>&gt; <span class="title">st</span><span class="params">(nums.begin(),nums.end())</span></span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=nums.<span class="built_in">size</span>();++i)</span><br><span class="line">            <span class="keyword">if</span>(!st.<span class="built_in">count</span>(i)) res.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数求余算法</title>
      <link href="2022/01/05/%E5%A4%A7%E6%95%B0%E6%B1%82%E4%BD%99%E7%AE%97%E6%B3%95/"/>
      <url>2022/01/05/%E5%A4%A7%E6%95%B0%E6%B1%82%E4%BD%99%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p><strong>Description</strong></p><p>Implement pow(A, B) % C.In other words, given A, B and C, find (A^B)%C</p><p><strong>Input</strong></p><p>The first line of input consists number of the test cases. The following T lines consist of 3 numbers each separated by a space and in the following order:A B C’A’ being the base number, ‘B’ the exponent (power to the base number) and ‘C’ the modular.Constraints:1 ≤ T ≤ 70,1 ≤ A ≤ 10^5,1 ≤ B ≤ 10^5,1 ≤ C ≤ 10^5</p><p><strong>Output</strong></p><p>In each separate line print the modular exponent of the given numbers in the test case.</p><p><strong>Sample Input 1</strong> </p><p>3<br>3 2 4<br>10 9 6<br>450 768 517</p><p><strong>Sample Output 1</strong></p><p>1<br>4<br>34</p><h1 id="大数取余方法"><a href="#大数取余方法" class="headerlink" title="大数取余方法"></a>大数取余方法</h1><p>整数求余满足的性质：</p><ul><li><strong>(x∗y) mod p = [x(y mod p)]mod p=[(x mod p)(y mod p)]mod p</strong></li></ul><h2 id="循环求余"><a href="#循环求余" class="headerlink" title="循环求余"></a>循环求余</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t; <span class="comment">//测试用例数t</span></span><br><span class="line">    <span class="keyword">int</span> a,b,c; <span class="comment">//基数a，幂b，模数c</span></span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">1</span>; <span class="comment">// 循环求余</span></span><br><span class="line">        <span class="keyword">while</span>(b--)&#123;</span><br><span class="line">            res = (res*a)%c;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><p>求大数 a^b 的思路为：</p><ul><li><strong>当 b 是偶数时，有 a^b = a^(b/2) * a^(b/2)</strong></li><li><strong>当 b 是奇数时，有 a^b = a * a^(b-1)</strong></li></ul><p>再利用整数求余性质：</p><ul><li><strong>当 b 是偶数时，(a^b)%c  = ( a^(b/2) * a^(b/2))%c = [( a^(b/2)%c)*( a^(b/2)%c)]%c</strong></li><li><strong>当 b 是奇数时，(a^b)%c  =  (a * a^(b-1))%c = [a*(a^(b-1)%c)]%c</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快速幂-递归</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qiuyu</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">1</span>) <span class="keyword">return</span> a%c;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(b%<span class="number">2</span>==<span class="number">0</span>) <span class="built_in"><span class="keyword">return</span></span> (<span class="built_in">qiuyu</span>(a,b/<span class="number">2</span>,c)*<span class="built_in">qiuyu</span>(a,b/<span class="number">2</span>,c))%c;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in"><span class="keyword">return</span></span> (a*<span class="built_in">qiuyu</span>(a,b<span class="number">-1</span>,c))%c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归</span></span><br><span class="line"><span class="comment">//快速幂-非递归位运算思想</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qiuyu</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans=(ans*a)%c;</span><br><span class="line">        a=(a*a)%c;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://yunsnow.github.io/%E5%A4%A7%E6%95%B0%E6%B1%82%E4%BD%99%E7%AE%97%E6%B3%95/">大数求余算法</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数求余 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>100.相同的树-LeetCode</title>
      <link href="2021/12/23/100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91-LeetCode/"/>
      <url>2021/12/23/100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91-LeetCode/</url>
      
        <content type="html"><![CDATA[<h1 id="相同的树"><a href="#相同的树" class="headerlink" title="相同的树"></a>相同的树</h1><p>给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><p><strong>示例 1：</strong></p><p> <img src="ex1.jpg"></p><p>输入：p = [1,2,3], q = [1,2,3]<br>输出：true</p><p><strong>示例 2：</strong></p><p> <img src="ex2.jpg"></p><p>输入：p = [1,2], q = [1,null,2]<br>输出：false</p><p><strong>示例 3：</strong></p><p> <img src="ex3.jpg"></p><p>输入：p = [1,2,1], q = [1,1,2]<br>输出：false</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/same-tree">https://leetcode-cn.com/problems/same-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p><strong>递归终止条件：（1）如果两个二叉树都为空，则两个二叉树相同。（2）如果两个二叉树中只有一个为空，则两个二叉树一定不相同。（3）如果两个二叉树都不为空，那么首先判断它们的根节点的值是否相同，若不相同则两个二叉树一定不同，若相同，再分别判断两个二叉树的左子树是否相同以及右子树是否相同。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**递归</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">nullptr</span>&amp;&amp;q==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">nullptr</span>||q==<span class="literal">nullptr</span>||p-&gt;val!=q-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSameTree</span>(p-&gt;left,q-&gt;left)&amp;&amp;<span class="built_in">isSameTree</span>(p-&gt;right,q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**迭代</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; qe;</span><br><span class="line">        qe.<span class="built_in">push</span>(p);</span><br><span class="line">        qe.<span class="built_in">push</span>(q);</span><br><span class="line">        <span class="keyword">while</span>(!qe.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            p = qe.<span class="built_in">front</span>();</span><br><span class="line">            qe.<span class="built_in">pop</span>();</span><br><span class="line">            q = qe.<span class="built_in">front</span>();</span><br><span class="line">            qe.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(!p&amp;&amp;!q) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!p||!q||p-&gt;val!=q-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            qe.<span class="built_in">push</span>(p-&gt;left);</span><br><span class="line">            qe.<span class="built_in">push</span>(q-&gt;left);</span><br><span class="line">            qe.<span class="built_in">push</span>(p-&gt;right);</span><br><span class="line">            qe.<span class="built_in">push</span>(q-&gt;right);  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h1><p>给定一个二叉树，检查它是否是镜像对称的。</p><p>例如，二叉树 <code>[1,2,2,3,4,4,3]</code> 是对称的。</p><p>​    1<br>   / <br>  2   2<br> / \ / <br>3  4 4  3</p><p>但是下面这个 <code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p><p>​    1<br>   / <br>  2   2<br>   \   <br>   3    3</p><p><strong>进阶：</strong>你可以运用递归和迭代两种方法解决这个问题吗？</p><p><strong>与判断两个树是否相同类似，如果一个树的左子树与右子树镜像对称，那么这个树是对称的。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**递归</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">treeSymmetric</span><span class="params">(TreeNode *root1,TreeNode *root2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root1==<span class="literal">nullptr</span>&amp;&amp;root2==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1==<span class="literal">nullptr</span>||root2==<span class="literal">nullptr</span>||root1-&gt;val!=root2-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">treeSymmetric</span>(root1-&gt;left,root2-&gt;right)&amp;&amp;<span class="built_in">treeSymmetric</span>(root1-&gt;right,root2-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">treeSymmetric</span>(root,root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**迭代</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool treeSymmetric(TreeNode *root1,TreeNode *root2)&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root1);</span><br><span class="line">        q.push(root2);</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            root1 &#x3D; q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            root2 &#x3D; q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            if(!root1&amp;&amp;!root2) continue;</span><br><span class="line">            if(!root1||!root2||root1-&gt;val!&#x3D;root2-&gt;val) return false;</span><br><span class="line">            q.push(root1-&gt;left);</span><br><span class="line">            q.push(root2-&gt;right);</span><br><span class="line">            q.push(root1-&gt;right);</span><br><span class="line">            q.push(root2-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    bool isSymmetric(TreeNode* root) &#123;</span><br><span class="line">        return treeSymmetric(root,root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>75.颜色分类-LeetCode</title>
      <link href="2021/12/21/75-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB-LeetCode/"/>
      <url>2021/12/21/75-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB-LeetCode/</url>
      
        <content type="html"><![CDATA[<p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p><strong>示例 1：</strong></p><p>输入：nums = [2,0,2,1,1,0]<br>输出：[0,0,1,1,2,2]</p><p><strong>示例 2：</strong></p><p>输入：nums = [2,0,1]<br>输出：[0,1,2]</p><p><strong>示例 3：</strong></p><p>输入：nums = [0]<br>输出：[0]</p><p><strong>示例 4：</strong></p><p>输入：nums = [1]<br>输出：[1]</p><p><strong>进阶：</strong></p><ul><li>你可以不使用代码库中的排序函数来解决这道题吗？</li><li>你能想出一个仅使用常数空间的一趟扫描算法吗？</li></ul><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/sort-colors">https://leetcode-cn.com/problems/sort-colors</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p><strong>双指针，把 0 移到前面，2 移到后面，1 自然就在中间。采用 swap 交换，但会存在不同位置的 2 和 2 交换，需要指针回退再交换一次。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pt0=<span class="number">0</span>,pt2=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=pt2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==<span class="number">0</span>)</span><br><span class="line">                <span class="built_in">swap</span>(nums[i++],nums[pt0++]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i]==<span class="number">2</span>)</span><br><span class="line">                <span class="built_in">swap</span>(nums[i],nums[pt2--]);</span><br><span class="line">            <span class="keyword">else</span> i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>大佬的妙啊，我这破脑袋想不出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num0 = <span class="number">0</span>, num1 = <span class="number">0</span>, num2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                nums[num2++] = <span class="number">2</span>;</span><br><span class="line">                nums[num1++] = <span class="number">1</span>;</span><br><span class="line">                nums[num0++] = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                nums[num2++] = <span class="number">2</span>;</span><br><span class="line">                nums[num1++] = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                nums[num2++] = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>142.环形链表2-LeetCode</title>
      <link href="2021/12/20/142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A82-LeetCode/"/>
      <url>2021/12/20/142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A82-LeetCode/</url>
      
        <content type="html"><![CDATA[<p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>不允许修改 链表。</p><p><strong>示例 1：</strong></p><p><img src="circularlinkedlist.png"></p><p>输入：head = [3,2,0,-4], pos = 1<br>输出：返回索引为 1 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。</p><p><strong>示例</strong> 2：</p><p><img src="circularlinkedlist_test2.png"></p><p>输入：head = [1,2], pos = 0<br>输出：返回索引为 0 的链表节点<br>解释：链表中有一个环，其尾部连接到第一个节点。</p><p><strong>示例 3：</strong></p><p><img src="circularlinkedlist_test3.png"></p><p>输入：head = [1], pos = -1<br>输出：返回 null<br>解释：链表中没有环。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii">https://leetcode-cn.com/problems/linked-list-cycle-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p><strong>分为两步，先判断链表中有没有环，再找出环的入口。另外跟链表中环的位置也有关系，分为以下三种情况：</strong></p><ul><li><strong>没有环则返回NULL</strong></li><li><strong>纯环（循环链表），入口就是head</strong></li><li><strong>前面是单链表，后面是环</strong></li></ul><p><strong>如示例1，我们假设单链表长度（节点数）为 d，环的周长为 r，快指针比慢指针快一倍，假设快慢两指针在距离环的入口 x 处相遇，则有 d+n*r+x = 2*(d+x)，得 d=n*r-x。于是分别让两指针（等速）从 head 和距离环的入口 x 处开始遍历，则一定会在环入口处相遇。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *p1=head,*p2=head;</span><br><span class="line">        <span class="keyword">while</span>(p2&amp;&amp;p2-&gt;next)&#123;</span><br><span class="line">            p1=p1-&gt;next;</span><br><span class="line">            p2=p2-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(p1==p2) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p2==<span class="literal">NULL</span>||p2-&gt;next==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p2==head) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">else</span> p2 = head;</span><br><span class="line">        <span class="keyword">while</span>(p1!=p2)&#123;</span><br><span class="line">            p1=p1-&gt;next;</span><br><span class="line">            p2=p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>141.环形链表-LeetCode</title>
      <link href="2021/12/20/141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-LeetCode/"/>
      <url>2021/12/20/141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-LeetCode/</url>
      
        <content type="html"><![CDATA[<p>给你一个链表的头节点 head ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p><p><strong>示例 1：</strong></p><p><img src="circularlinkedlist.png"></p><p>输入：head = [3,2,0,-4], pos = 1<br>输出：true<br>解释：链表中有一个环，其尾部连接到第二个节点。</p><p><strong>示例 2：</strong></p><p><img src="circularlinkedlist_test2.png"></p><p>输入：head = [1,2], pos = 0<br>输出：true<br>解释：链表中有一个环，其尾部连接到第一个节点。</p><p><strong>示例 3：</strong></p><p><img src="circularlinkedlist_test3.png"></p><p>输入：head = [1], pos = -1<br>输出：false<br>解释：链表中没有环。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/linked-list-cycle">https://leetcode-cn.com/problems/linked-list-cycle</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p><strong>链表中存在环有两种情况：（1）纯环，即循环链表；（2）前部分是单链表，后面是环。无论哪种情况，采用双指针快慢指针，如果存在环则两个指针一定会相遇。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *p1=head,*p2=head;</span><br><span class="line">        <span class="keyword">while</span>(p2&amp;&amp;p2-&gt;next)&#123;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">            p2 = p2-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(p1==p2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.两数相加-LeetCode</title>
      <link href="2021/12/19/2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0-LeetCode/"/>
      <url>2021/12/19/2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0-LeetCode/</url>
      
        <content type="html"><![CDATA[<p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例 1：</strong></p><p><img src="addtwonumber1.jpg"></p><p>输入：l1 = [2,4,3], l2 = [5,6,4]<br>输出：[7,0,8]<br>解释：342 + 465 = 807.</p><p><strong>示例 2：</strong></p><p>输入：l1 = [0], l2 = [0]<br>输出：[0]</p><p><strong>示例 3：</strong></p><p>输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]<br>输出：[8,9,9,9,0,0,0,1]</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/add-two-numbers">https://leetcode-cn.com/problems/add-two-numbers</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p><strong>一开始想法把每个链表数字取出来翻转得到原整数，然后两个整数相加再存回新的链表，超时教我做人。</strong></p><p><strong>注意到两个链表存数是以逆序方式，也就是链表的头指向的数正是原来整数的个位，为何不直接把两个链表依次相加得到的数存进新的链表讷？做的时候发现每个节点只能存储 一位数字，就会有进位问题，需要增加个进位符，并不用判断两节点相加 sum 是否大于9，直接除以 10 取进位符，不进位则为 0，增加新的结点把得到的结果（sum%10）存进去，依次遍历下个结点。可能会出现一个链表遍历完了，那么就给它不存在的结点指向的值赋予0，还需要注意两链表都遍历完，但最高位进位的情况。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s1=<span class="number">0</span>,s2=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> f=<span class="number">0</span>;</span><br><span class="line">        ListNode *res = <span class="keyword">new</span> ListNode;</span><br><span class="line">        ListNode *cur = res;</span><br><span class="line">        <span class="keyword">while</span>(l1||l2||f)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1)&#123;</span><br><span class="line">                s1 = l1-&gt;val;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span> </span><br><span class="line">                s1=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(l2)&#123;</span><br><span class="line">                s2 = l2-&gt;val;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span> </span><br><span class="line">                s2=<span class="number">0</span>;</span><br><span class="line">            sum = s1+s2+f;</span><br><span class="line">            f = sum/<span class="number">10</span>;</span><br><span class="line">            cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum%<span class="number">10</span>);</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11.盛最多水的容器-LeetCode</title>
      <link href="2021/12/18/11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8-LeetCode/"/>
      <url>2021/12/18/11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8-LeetCode/</url>
      
        <content type="html"><![CDATA[<p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>说明：你不能倾斜容器。</p><p><strong>示例 1：</strong></p><p> <img src="question_11.jpg"></p><p>输入：[1,8,6,2,5,4,8,3,7]<br>输出：49<br>解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p><p><strong>示例 2：</strong></p><p>输入：height = [1,1]<br>输出：1</p><p><strong>示例 3：</strong></p><p>输入：height = [4,3,2,1,4]<br>输出：16</p><p><strong>示例 4：</strong></p><p>输入：height = [1,2,1]<br>输出：2</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/container-with-most-water">https://leetcode-cn.com/problems/container-with-most-water</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p><strong>双指针 i 和 j，一开始分别位于数组头尾两端容器底部最宽，但面积不一定最大，里面可能有宽度稍小但很高的容器，所以需要指针向内移动。为了在移动后减少宽度的情况下，希望容器面积有所增大，应保留指针所指的高较大的指针，另一个指针向内移动，得到新容器面积并与前面最大容器面积比较。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=height.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> marea=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            marea = <span class="built_in">max</span>(marea,<span class="built_in">min</span>(height[i],height[j])*(j-i));</span><br><span class="line">            <span class="keyword">if</span>(height[i]&gt;height[j])</span><br><span class="line">                j--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> marea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>反思：为什么这种方法是对的？真的包含所有容器面积了吗（暴力法两个 for）？没有漏掉最大面积吗？</p><p>求最大容器面积即使得底x高最大，一开始自然想到从数组两端得到最大的底，再 min(h[i],h[j])求得高，此时得到一个面积，但我们不确定是否为最大面积，需要移动指针（移动左还是右？还是两个都移动？），我们的做法是把指向的高较小的指针往里移，这也就意味着放弃了以这条边作为容器的边界，也就少计算了height.size()-2个容器（这合理吗）。我们不妨移动另一指向高的指针试试，发现由于指向低的指针存在，min(h[i],h[j])永远等于指向高较小的值，而此时宽度还没有一开始数组两端距离大，所以得到的容器面积一定小于最两端容器面积。故将指向的高较小的指针往里移，被我们丢弃的那个位置就相当于消失了，i, j 当作新数组的两端指针，返回第一步。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统简答题</title>
      <link href="2021/12/18/Linux%E7%B3%BB%E7%BB%9F%E7%AE%80%E7%AD%94%E9%A2%98/"/>
      <url>2021/12/18/Linux%E7%B3%BB%E7%BB%9F%E7%AE%80%E7%AD%94%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><p><strong>1-1 简述 Linux 系统的应用领域</strong></p><p>1．Linux 服务器<br>2．嵌入式 Linux 系统<br>3．软件开发平台<br>4．桌面应用</p><p><strong>1-2 简述Linux 系统的特点</strong></p><p>1．开放性<br>2．多用户<br>3．多任务<br>4．良好的用户界面<br>5．设备独立性<br>6．丰富的网络功能<br>7．可靠的系统安全<br>8．良好的可移植性</p><p><strong>1-3 简述Linux 系统的组成</strong></p><p>1．内核<br>2．Shell<br>3．文件系统<br>4．应用程序</p><p><strong>1-4 简述什么是Linux发行版本，主流的 Linux 发行版本有哪些</strong>(21)</p><p>一些组织和公司，将Linux系统的内核、应用软件和文档包装起来，并提供一些系统安装界面、系统配置设定管理工具，就构成了Linux发行版本。</p><p>（1）Red Hat<br>（2）SUSE<br>（3）Oracle<br>（4）CentOS<br>（5）Ubuntu<br>（6）Debian<br>（7）Mandriva<br>（8）Gentoo<br>（9）Slackware<br>（10）Fedora</p><p><strong>1-5 简述 RHEL7 系统的新特性</strong></p><p>1．支持和硬件平台多<br>2．优秀的安装界面<br>3．独特的RPM升级方式<br>4．丰富的软件包<br>5．安全性能好<br>6．方便的系统管理界面<br>7．详细而完整的在线文档</p><h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><p><strong>2-1 简述安装Linux系统的硬件要求。</strong></p><p>（1）CPU：主流计算机和服务器都能达到要求；<br>（2）内存：安装Linux系统至少需要1GB内存（建议使用2GB甚至更高内存）；<br>（3）硬盘空间：若要安装所有软件包至少需要10GB以上硬盘空间；<br>（4）显示器和显卡；<br>（5）DVD光驱。</p><p><strong>2-2 在你的计算机上设计一个合理的分区规划。</strong>(21最简分区)</p><p>• swap分区：实现虚拟内存，建议大小是物理内存的1～2倍；<br>• /boot分区：建议大小最少为200MB；<br>• /usr分区：用来存放Linux系统中的应用程序，其相关数据较多，建议大小最少为8GB；<br>• /var分区：用来存放Linux系统中经常变化的数据以及日志文件，建议大小最少为1GB；<br>• /分区：Linux系统的根目录，所有的目录都挂在这个目录下面，建议大小最少为1GB；<br>• /home分区：存放普通用户的数据，是普通用户的宿主目录，建议大小为剩下的空间</p><p><strong>2-3 简述分区命名方案。</strong></p><p>Linux系统使用字母和数字的组合来指代硬盘分区，该命名方案是基于文件的，文件名的格式为/dev/xxyN（比如/dev/sda1分区）。<br>/dev：Linux系统中所有设备文件所在的目录名。因为分区位于硬盘上，而硬盘是设备，所以这些文件代表了在/dev上所有可能的分区；<br>xx：分区名的前两个字母表示分区所在设备的类型，通常是hd（IDE硬盘）或sd（SCSI硬盘）；<br>y：这个字母表示分区所在的设备。例如，/dev/hda（第1个 IDE 硬盘或/dev/sdb（第2个SCSI硬盘）；<br>N：最后的数字N代表分区。前4个分区（主分区或扩展分区）用数字1～4表示，逻辑驱动器从5开始。例如，/dev/hda3是第1个IDE 硬盘上的第3个主分区或扩展分区；/dev/sdb6是第2个SCSI硬盘上的第2个逻辑驱动器。</p><p><strong>2-4 简述在安装Linux系统时设置计算机IP地址的方法。</strong></p><p>在网络和主机名界面点击配置按钮，选择 IPV4 设置并编辑，再点击添加 IP地址，输入完进行保存即可。</p><p><strong>2-5 FirewallD 防火墙的默认连接区域是什么?</strong></p><p>防火墙的默认连接区域为 public，public 在公共区域内使用，指定外部连 接可以进入内部网络或主机。</p><h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><p><strong>3-1 进入字符界面有哪些方式?</strong></p><p>可以通过字符界面、图形界面下的终端以及虚拟控制台等多种方式进入</p><p><strong>3-2 可以使用哪些命令关闭计算机系统?</strong></p><p>shutdown、halt、init0</p><p><strong>3-3 简述Linux系统中的目标概念。</strong></p><p>RHEL 7使用目标（target）替换运行级别。目标使用目标单元文件描述，目标单位文件扩展名是.target，目标单元文件的唯一目标是将其他systemd单元文件通过一连串的依赖关系组织在一起。</p><p><strong>3-4 在Linux系统中获取帮助有哪些方式?</strong></p><p>使用man手册页、使用–help选项获取帮助、使用info</p><p><strong>3-5 有哪些重定向方式?</strong></p><p>输入重定向（输入追加重定向）、输出重定向（输出追加重定向）、错误重定向（错误追加重定向）、同时实现输出和错误重定向。</p><p><strong>3-6 简述vi编辑器的工作模式。</strong>(21)</p><p>1.命令模式：进入vi编辑器之后，系统默认处于命令模式。命令模式控制屏幕光标的移动，字符、字或行的删除，某区域的移动、复制等。在命令模式下，按冒号键“:”可以进入末行模式，按字母键“a”或“i”就可以进入插入模式。<br>2.插入模式：只有在插入模式下，才可以进行文本编辑。在插入模式下按“Esc”键可回到命令模式。<br>3.末行模式： 将文件保存或退出vi编辑器，也可以设置编辑环境、替换字符或删除字符。 在末行模式下按“Esc”键可以回到命令模式。</p><h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1><p><strong>4-1 Linux系统中有哪些文件类型?</strong></p><p>（1）普通文件（-）</p><p>（2）目录文件（d）</p><p>（3）设备文件（字符设备文件（c）、块设备文件（b））</p><p>（4）管道文件（p）</p><p>（5）符号链接文件（l）</p><p><strong>4-2 简述软链接文件和硬链接文件的区别。</strong></p><p>硬链接记录的是目标的inode，软链接记录 的是目标的路径。软链接就像是快捷方式， 而硬链接就像是备份。软链接可以做跨分 区的链接，而硬链接由于inode的缘故，只 能在本分区中做链接。所以软链接的使用 频率要高得多。</p><p><strong>4-3 简述Linux系统中的目录结构。</strong>(21)</p><p>Linux系统的目录结构是分层的树形结构，都是挂载在根文件系统“/”下。<br>/home 包含Linux系统上各用户的主目录，子目录名称默认以该用户名命名<br>/root 是root用户的主目录<br>/bin 包含常用的命令文件，不能包含子目录<br>/sbin 包含系统管理员和root用户所使用的命令文件<br>/dev 包含大部分的设备文件，比如磁盘、光驱等<br>/lib 包含Linux系统的共享文件和内核模块文件<br>/lib/modules目录存放核心可加载模块<br>/lib64 包含64位版本Linux系统的共享文件和内核模块文件<br>/tmp 包含一些临时文件<br>/mnt 手动为某些设备（比如硬盘）挂载提供挂载目录<br>/boot 包含Linux系统的内核文件和引导装载程序（如GRUB）文件<br>/opt 包含某些第三方应用程序的安装文件<br>/media 由系统自动为某些设备（一般为光盘、U盘等设备）挂载提供挂载目录<br>/var 该目录存放不经常变化的数据，如系统日志、打印队列、DNS数据库文件等<br>/etc 包含Linux系统上大部分的配置文件，建议修改配置文件之前先备份<br>/usr 包含可以供所有用户使用的程序和数据<br>/srv 存储一些服务启动之后所需要取用的资料目录<br>/run 一个临时文件系统，一些程序或服务启动以后，会将他们的PID放置在该目录中<br>/sys 在Linux系统提供热插拔能力的同时，该目录包含所检测到的硬件设置，它们被转换成/dev目录中的设备文件<br>/proc 是一个虚拟的文件系统，它不存在磁盘上，而是由内核在内存中产生，<br>用于提供系统的相关信息。<br>下面说明在/proc目录下的一些最重要的文件。<br>/proc/cpuinfo：该文件保存计算机CPU信息。<br>/proc/filesystems：该文件保存Linux文件系统信息。<br>/proc/ioports：该文件保存计算机I/O端口号信息。<br>/proc/version：该文件保存Linux系统版本信息。<br>/proc/meminfo：该文件保存计算机内存信息。</p><p><strong>4-4 简述使用“ls -l”命令显示的详细信息。</strong></p><p>文件类型、用户所有者访问权限、组群所有者访问权限、其他用户访问权限、<br>文件链接数、文件的用户所有者、文件的组群所有者、文件长度（大小）、文件<br>更改时间或最后访问时间、文件名称</p><p><strong>4-5 使用什么命令可以删除具有子目录的目录?</strong></p><p>rm -rf </p><h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><p><strong>5-1 常用的文本内容显示命令有哪些?区别是什么?</strong></p><p>cat、more、less、head、tail<br>cat 显示文本文件内容、more 分页显示文本文件、less 回卷显示文本文件、head 显示指定文件前若干行、tail 查看文件末尾数</p><p><strong>5-2 常用的文本处理命令有哪些?区别是什么?</strong></p><p>sort uniq cut comm diff </p><p>sort 对文本内容升序排序（如添加-r 则为降序排序）</p><p>uniq 将重复行从输出 文件中删除 </p><p>cut 从文件每行中显示出选定的字节、字符或字段</p><p> comm 逐行比较两 个已排过序的文件 </p><p>diff 逐行比较两个文本文件、列出其不同之处（不用事先排序）</p><p><strong>5-3 使用什么命令能显示当前计算机的内核版本?</strong></p><p>uname -r 显示内核发行号 </p><p>uname -m 显示计算机硬件架构名称 </p><p>uname -a 显 示操作系统的全部信息</p><p><strong>5-4 使用什么命令能清除计算机屏幕信息?</strong></p><p>clear</p><p><strong>5-5 使用什么命令可以以倒序方式排序文件内容?</strong></p><p>sort -r</p><h1 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h1><p><strong>6-1 简述一个简单Shell程序的创建过程。</strong></p><p>1．创建文件</p><p>2．设置可执行权限</p><p><strong>6-2 简述执行Shell程序的方法。</strong></p><p>（1）输入整个文件的完整路径执行Shell程序</p><p>（2）使用bash命令执行程序</p><p><strong>6-3 简述常见的Shell环境变量。</strong></p><table><thead><tr><th align="center">Shell环境变量</th><th>描述</th></tr></thead><tbody><tr><td align="center">HOME</td><td>用于保存用户主目录的完全路径名</td></tr><tr><td align="center">PATH</td><td>用于保存用冒号分隔的目录路径名，Shell将按PATH变量中给出的顺序搜索这些目录，找到的第一个与命令名称一致的可执行文件将被执行</td></tr><tr><td align="center">TERM</td><td>终端的类型</td></tr><tr><td align="center">UID</td><td>当前用户的UID，由数字构成</td></tr><tr><td align="center">PWD</td><td>当前工作目录的绝对路径名，该变量的取值随cd命令的使用而变化</td></tr><tr><td align="center">PS1</td><td>主提示符，在root用户下，默认的主提示符是“#”，在普通用户下，默认的主提示符是“$”</td></tr><tr><td align="center">PS2</td><td>在Shell接收用户输入命令的过程中，如果用户在输入行的末尾输入“\”然后按回车键，或者当用户按回车键时Shell判断出用户输入的命令没有结束时，就显示这个辅助提示符，提示用户继续输入命令的其余部分，默认的辅助提示符是“&gt;”</td></tr></tbody></table><p><strong>6-4 简述常用的字符串比较符号。</strong></p><table><thead><tr><th align="center">字符串比较符号</th><th>描述</th></tr></thead><tbody><tr><td align="center">=</td><td>比较两个字符串是否相同，相同则为“是”</td></tr><tr><td align="center">！=</td><td>比较两个字符串是否不同，不同则为“是”</td></tr><tr><td align="center">-n</td><td>比较字符串的长度是否大于0，如果大于0则为“是”</td></tr><tr><td align="center">-z</td><td>比较字符串的长度是否等于0，如果等于0则为“是”</td></tr></tbody></table><p><strong>6-5 Linux系统中有哪些条件判断语句和循环控制流程语句?</strong></p><p>条件判断语句：if-then-fi 语句、if-then-else-fi 条件语句、case 条件语句<br>循环控制语句：for 语句、while 循环语句、until 循环语句</p><p><strong>6-6 简述if条件语句和 case条件语句的区别。</strong></p><p>if 条件语句用于两个选项中选定一项，而 case 条件选择为用户提供了根据字符串或变量的值从多个选项中选择一项的方法</p><h1 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h1><p><strong>7-1 在Linux系统中用户账户有哪些分类?</strong></p><p>root 用户（UID 为 0）、系统用户（UID 为 1-999）、普通用户（UID 默认从 1000开始，默认的 UID 最大值为 60000）</p><p><strong>7-2 管理用户账户的配置文件有哪些?并描述这些文件各字段的含义。</strong></p><p>（1）/etc/passwd </p><p><img src="passwd.png"></p><p>（2）/etc/shadow </p><p><img src="shadow.png"></p><p><strong>7-3 管理组群账户的配置文件有哪些?并描述这些文件各字段的含义。</strong> </p><p>（1）/etc/group</p><p><img src="group.png"></p><p>（2）/etc/gshadow</p><p><img src="gshadow.png"></p><p><strong>7-4 默认情况下新创建的第一个用户账户UID是多少?</strong></p><p>1000</p><p><strong>7-5 简述对用户账户设置密码和不设置密码的区别。</strong></p><p>用户不设置密码默认是被锁定的，无法使用，需要使用 passwd 命令设置密<br>码方可使用。</p><h1 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h1><p><strong>8-1 简述磁盘分区的含义。</strong></p><p>磁盘分区是指对硬盘物理介质的逻辑划分，将磁盘分成多个分区，分区就是磁盘的‘段落’。磁盘分区一共有三种：主分区、拓展分区、逻辑驱动器。</p><p><strong>8-2 简述格式化的含义。</strong></p><p>格式化是指对磁盘分区进行初始化的一种操作，在磁盘中建立磁道和扇区，这种操作通常会导致现有的分区中所有的数据被清除。</p><p><strong>8-3 fdisk命令有哪些子命令?其含义分别是什么?</strong>(21)</p><p><img src="fdisk.png"></p><p><strong>8-4 Linux系统中常用的文件系统有哪些?</strong></p><p>XFS、ext4、JFS、ext3、ext2、ISO9660、MSDOS、NFS</p><p><strong>8-5 使用新磁盘存储数据一般要经过哪些操作步骤?</strong></p><p>将磁盘进行分区，然后创建文件系统，最后将文件系统挂载到目录</p><p><strong>8-6 要实现开机自动挂载文件系统,可以通过哪些方法来实现?</strong></p><p>在 /etc/fstab文件中添加该磁盘分区的相关信息，可以通过提供设备名称、UUID和卷标实现，设置完成重启计算机系统以后，文件系统将会自动挂载</p><h1 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h1><p><strong>9-1 使用RPM 软件包管理的用途是什么?</strong>(21)</p><p>（1）可以安装、删除、升级、刷新和管理RPM软件包；<br>（2）通过RPM软件包管理能知道软件包包含哪些文件，也能知道系统中的某个文件属于哪个RPM软件包；<br>（3）可以查询系统中的RPM软件包是否安装并查询其安装的版本；<br>（4）开发者可以把自己的程序打包为RPM软件包并发布；<br>（5）软件包签名GPG和MD5的导入、验证和签名发布；<br>（6）依赖性的检查，查看是否有RPM软件包由于不兼容而扰乱系统</p><p><strong>9-2 简述升级RPM 软件包和刷新RPM 软件包的区别。</strong></p><p>升级软件包是删除和安装的组合，不管该软件包的早期版本是否已经被安装，升级选项都会安装该软件包。刷新软件包时，系统会比较指定的软件包的版本，当比已安装的版本更新，它就会升级到更新的版本，如果软件包先前没有安装，那么刷新并不会安装该软件包</p><p><strong>9-3 简述在本地磁盘上创建本地软件仓库的步骤。</strong></p><p>1、安装软件包 安装 deltarpm、python-deltarpm 和 createrepo 软件包<br>2、复制软件包 复制 Linux 系统安装光盘中的软件包<br>3、创建软件仓库配置文件<br>4、创建软件仓库 使用 createrepo 命令创建软件仓库</p><p><strong>9-4 tar命令可以调用哪些压缩程序?</strong></p><p>gzip（-z）、bzip2（-j）和 xz（-J）<br>备份 tar cvf xxx xxx<br>查看 tar tvf xxx<br>添加 tar rvf xxx yyy<br>解压 tar xvf xxx<br>更新 tar uvf</p><h1 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h1><p><strong>10-1 文件有哪些权限?其含义分别是什么?</strong>(21三个特殊权限)</p><p>每位用户都有对文件或目录的读取、写入和执行权限。第一套权限控制访问自己的文件权限，即所有者权限。第二套权限控制用户组访问其中一个用户的文件的权限。第三组权限限制其他用户访问一个用户的文件的权限。这三套权限赋予用户不同类型（即用户所有者、组群所有者、和其他用户）的读取、写入及执行权限。</p><p><strong>10-2 可以使用哪些方法设置文件的权限?</strong></p><p>（1）文字设定法设置权限<br>u 表示用户所有者，g 表示组群所有者，o 表示其他用户，a 表示所有用户（系统默认值）</p><p>+表示添加某个权限 -表示取消某个权限 =表示赋予给定权限并取消原先权限（如果有的话）</p><p>（2）数字设定法设置权限<br>使用 r，w，x 这三个字符为用户所有者，组群所有者和其他用户设置权限。r 对应数值为 4，w 对应为 2，x 对应为 1， -对应为 0，然后将其相加。</p><p><strong>10-3 特殊权限设置</strong></p><p>chmod u+s<br>S=-+SUID s=x+SUID<br>SGID chmod g+s<br>S=-+SGID s=x+SGID<br>Sticky chmod o+t<br>T=-+Sticky t=x+Sticky</p><p><strong>10-4 更改文件和目录所有者</strong></p><p>chown [选项][用户.组群][文件|目录] </p><p>chown [选项][用户:组群][文件|目录]</p><h1 id="第十一章"><a href="#第十一章" class="headerlink" title="第十一章"></a>第十一章</h1><p><strong>11-1 简述Linux系统的进程分类。</strong></p><p>① 交互式进程：一个由 Shell 启动并控制的进程，交互式进程既可在前台运行，也可在后台运行<br>② 批处理进程：与终端无关，安排在指定时刻完成的一系列进程<br>③ 守护进程：在引导系统时启动，以执行即时的操作系统任务。如 crond(定时任务)，rsyslogd,name</p><p><strong>11-2 简述 Linux系统的启动过程。</strong>(21)</p><p>①BIOS 自检②启动 GRUB2③加载内核④执行 systemd 进程⑤初始化系统环境⑥执行/bin/login 程序</p><p><strong>11-3 简述GRUB2所具有的新功能。</strong></p><p>①图形接口②使用模块机制③支持脚本语言④支持救援模式⑤国际化语言 ⑥有一个灵活的命令行接口⑦针对文件系统、文件、设备、驱动、终端、命令、 分区表、系统加载的模块化、层次化、基于对象的框架⑧支持多种文件系统格式 ⑨可以访问已经安装在设备上的数据 10 支持自动解压</p><p><strong>11-4 简述GRUB2密码支持的两种格式</strong>。</p><p>（1）明文密码：密码数据没有经过加密，安全性差 </p><p>（2）PBKDF2 加密密码：密码经过 PBKDF2 哈希算法进行加密，在文件中存储的是加密 后的密码数据，安全性较高</p><p><strong>11-5 /etc/crontab 文件</strong></p><p>root 用户通过修改/etc/crontab 文件可以实现任务计划，普通用户无法修 改该文件，但可以使用 crontab 命令配置 cron 任务。/etc/crontab 文件是 cron 的默认配置文件，它的每一行都代表一项任务</p><p>minute hour day month dayofweek user-name commands</p><p><strong>11-6 Systemd 进程的作用</strong><br>①扮演终结父进程的角色，因为 systemd 进程永远不会被终止，所以系统总是可以确信它的存在，并在必要的时候以它作为参照。</p><p>②在进入某个特定的服务启动集合，即/etc/systemd/system/default.target，它的作用是由运行目标target 定义的。</p><h1 id="第十二章"><a href="#第十二章" class="headerlink" title="第十二章"></a>第十二章</h1><p><strong>12-1 简述网卡配置文件的内容。</strong></p><p>在Linux统中，系统网络设备的配置文件保 存在/etc/sysconfig/network-scripts目录下， 其中文件ifcfg-eno16777736包含一块网卡 的配置信息，文件ifcfg-lo包含回路IP地址 信息。</p><p><strong>12-2 测试网络连通可以使用哪些命令?</strong></p><p>ping、netstat</p><p><strong>12-3 DNS服务使用什么端口号?</strong></p><p>53</p><p><strong>12-4 systemctl 的使用</strong>(21)</p><p>systemctl start named.service 后缀名最好不要省略 如果省略了默认拓展是.service </p><p>systemctl start named.service 启动 named 服务 </p><p>systemctl status named.service 查看 named 服务当前状态</p><p> systemctl stop named.service 停止 named 服务 </p><p>systemctl restart named.service 重启 named 服务 </p><p>systemctl enable named.service 设置 named 服务开机自动启动 </p><p>systemctl disable named.service 停止 named 服务开机自动启动 </p><p>systemctl is-enabled named.service 查询 named 服务是否开机自动启动 </p><p>systemctl list-units –type=service 查看所有已启动的服务</p><h1 id="第十三章"><a href="#第十三章" class="headerlink" title="第十三章"></a>第十三章</h1><p><strong>13-1 简述OpenSSH替代telnet的主要原因。</strong></p><p>telnet 是不安全的，它是使用纯文本口令并以明文发送，而 OpenSSH 将增进系统安全性，使用 OpenSSH 软件进行通信时，登录验证口令将会被加密。</p><p><strong>13-2 简述VNC 软件的组成部分。</strong></p><p>VNC软件要由两个部分组成：服务端的VNC server和客户端的VNCviewer。用户需先将VNCserver安装在被远程操控的计算机上后，才能在主控端执行VNC viewer进行远程操控。</p><p><strong>13-3 SSH 的登录和scp 传输文件命令</strong>(21)</p><p>SSH 登录：ssh [选项] [用户@]主机 [命令]</p><p>例如：ssh <a href="mailto:&#x72;&#111;&#111;&#x74;&#x40;&#x31;&#x39;&#50;&#46;&#49;&#54;&#56;&#46;&#x30;&#46;&#x31;&#48;&#48;">&#x72;&#111;&#111;&#x74;&#x40;&#x31;&#x39;&#50;&#46;&#49;&#54;&#56;&#46;&#x30;&#46;&#x31;&#48;&#48;</a> ls/boot 以 root 账号连接远程主机 192.168.0.100 并 执行 ls /boot 命令<br>scp 传输文件：scp [选项] [[用户@]主机 1：]文件 1 [[用户@]主机 2：]文件 2<br>例如：ssh /root/a <a href="mailto:&#x72;&#111;&#111;&#116;&#64;&#x31;&#57;&#x32;&#46;&#x31;&#54;&#x38;&#x2e;&#x30;&#x2e;&#x31;&#x30;&#x30;">&#x72;&#111;&#111;&#116;&#64;&#x31;&#57;&#x32;&#46;&#x31;&#54;&#x38;&#x2e;&#x30;&#x2e;&#x31;&#x30;&#x30;</a>:/root/b 用root账号把本地文件root/a传送到192.168.0.100远程主机下的/root 下，并改名b</p><h1 id="第十四章"><a href="#第十四章" class="headerlink" title="第十四章"></a>第十四章</h1><p><strong>14-1 简述NFS的含义。</strong></p><p>NFS（Network File System 网络文件系统）是一个文件系统，通过使用 NFS，用户和程序可以向访问本地文件一样访问远程系统上的文件</p><p><strong>14-2 简述/etc/exports文件内容的格式。</strong></p><p>/etc/exports 文件控制着 NFS 服务器要导出的共享目录以及访问控制。文件内容格式如下： 共享目录  客户端（导出选项）</p><p> /etc/exports 文件中添加的共享目录必须使用绝对路径，不能使用相对路径， 而且该目录必须先创建好，该目录将作为 NFS 服务器上的共享目录并题供给客户端使用。 </p><p>客户端是指可以访问 NFS 服务器共享目录的客户端计算机，客户端计算机可以是 一台计算机，也可以是一个网段，甚至一个域。</p><h1 id="补充练习"><a href="#补充练习" class="headerlink" title="补充练习"></a>补充练习</h1><p><strong>1.什么是LVM?</strong></p><p>LVM（Logical Volume Manager）逻辑卷管理 它是 Linux 环境下对磁盘分区进行管理的一种机制，屏蔽了底层磁盘布局，便于动态调整磁盘容量。</p><p><strong>2.什么是PV、VG、LV?</strong></p><p>PV（Physical Volume）物理卷：整个硬盘或使用 fdisk 等工具建立的普通分区</p><p>VG（Volume Group）卷组：一个或多个物理卷组合而成的整体 </p><p>LV（LogicalVolume）逻辑卷：从卷组中分割出的一块空间，用于建立文件系统</p><p><strong>3.PV、VG、LV之间的相互关系?</strong></p><p><img src="VG-PV-LV.png"></p><p><strong>4.逻辑卷是否可以在线扩容、缩小?</strong></p><p>可以在线扩容，不可以在线缩小</p><p><strong>5.文件系统是否可以在线扩容和缩小?</strong></p><p>可以在线扩容，不可以在线缩小</p><p><strong>6.缩小逻辑卷或文件系统应注意哪儿些?</strong></p><p>必需将逻辑卷卸载并确定数据使用量</p><p><strong>7.如何创建逻辑卷?</strong>(21)</p><p>①新建空分区②初始化分区（创建PV）③创建卷组④创建逻辑卷</p><p><strong>8.卷组的PE 默认大小是多少?</strong></p><p>4MB</p>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K-Means聚类算法</title>
      <link href="2021/12/04/K-Means%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/"/>
      <url>2021/12/04/K-Means%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h1><p>K-Means算法的思想很简单，对于给定的样本集，按照样本之间的距离大小，将样本集划分为K个簇。让簇内的点尽量紧密的连在一起，而让簇间的距离尽量的大。</p><p>聚类算法有很多种，K-Means 是聚类算法中的最常用的一种，算法最大的特点是简单，好理解，运算速度快，但是只能应用于连续型的数据，并且一定要在聚类前需要手工指定要分成几类。</p><p>K-Means 聚类算法的大致意思就是“物以类聚，人以群分”：</p><ul><li>对于m组数据点，首先输入 k 的值，即我们指定希望通过聚类得到 k 个分组；</li><li>从数据集中随机选取 k 个数据点作为初始中心（一般选取前k个）；</li><li>对集合中每一个数据点，计算与每一个中心的距离（可选曼哈顿距离），离哪个中心距离近，就归类哪个中心。</li><li>这时每一个中心手下都聚集了一群点，这时候召开选举大会，每一群选出新的中心（即通过算法选出新的中心）。</li><li>如果新中心和老中心之间的距离小于某一个设置的阈值（表示重新计算的中心的位置变化不大，趋于稳定，或者说收敛），可以认为我们进行的聚类已经达到期望的结果，算法终止。</li><li>如果新中心和老中心距离变化很大，需要迭代3~5步骤。</li></ul><h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="comment"># k-means 曼哈顿距离</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">kmeans</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, m, k</span>):</span></span><br><span class="line">        self.m = m  <span class="comment"># 坐标点个数</span></span><br><span class="line">        self.k = k  <span class="comment"># 分组个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输入坐标列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">input_coordinate</span>(<span class="params">self</span>):</span></span><br><span class="line">        coordinate_list = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.m)]  <span class="comment"># 坐标列表</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.m):</span><br><span class="line">            coordinate_list[i][<span class="number">0</span>], coordinate_list[i][<span class="number">1</span>] = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())  <span class="comment"># 输入坐标</span></span><br><span class="line">        <span class="keyword">return</span> coordinate_list</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算相异矩阵</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate_distance</span>(<span class="params">self, coordinate_list</span>):</span></span><br><span class="line">        distance_list = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.m)] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.m)]  <span class="comment"># 相异矩阵列表m*m</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>):</span><br><span class="line">                distance_list[i][j] = <span class="built_in">abs</span>(coordinate_list[i][<span class="number">0</span>] - coordinate_list[j][<span class="number">0</span>]) + <span class="built_in">abs</span>(coordinate_list[i][<span class="number">1</span>] - coordinate_list[j][<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> distance_list</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 输出相异矩阵</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">output_distance</span>(<span class="params">self, distance_list</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>): <span class="comment"># 输出一半矩阵</span></span><br><span class="line">                <span class="built_in">print</span>(distance_list[i][j], end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 初始分组</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">min_distance1</span>(<span class="params">self, distance_list</span>):</span></span><br><span class="line">        k = self.k <span class="comment"># 分组个数</span></span><br><span class="line">        klist = []  <span class="comment"># 起始中心点id</span></span><br><span class="line">        min_distance = []  <span class="comment"># 最小距离</span></span><br><span class="line">        min_distance_id = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.m)] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k)] <span class="comment"># 最小距离对应id列表k*m</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            klist.append(<span class="built_in">int</span>(<span class="built_in">input</span>())-<span class="number">1</span>) <span class="comment"># 输入起始中心点id,从1开始</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.m):</span><br><span class="line">            mindist = <span class="number">20</span> <span class="comment"># 初始化最小距离(要大于任意两点间距离)</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> klist:</span><br><span class="line">                <span class="keyword">if</span> distance_list[i][j] &lt; mindist:</span><br><span class="line">                    mindist = distance_list[i][j]</span><br><span class="line">                    kid = j</span><br><span class="line">            min_distance.append(mindist)</span><br><span class="line">            min_distance_id[kid][i] = i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> min_distance_id</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 更新中心点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_center</span>(<span class="params">self, coordinate_list, min_distance_id</span>):</span></span><br><span class="line">        center_point = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.k)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.k):</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.m):</span><br><span class="line">                mindstid = min_distance_id[i][j]</span><br><span class="line">                <span class="keyword">if</span>(mindstid != <span class="number">0</span>):</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">                    center_point[i][<span class="number">0</span>] += coordinate_list[mindstid-<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">                    center_point[i][<span class="number">1</span>] += coordinate_list[mindstid-<span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">            center_point[i][<span class="number">0</span>] = <span class="built_in">round</span>(center_point[i][<span class="number">0</span>]/count, <span class="number">3</span>)</span><br><span class="line">            center_point[i][<span class="number">1</span>] = <span class="built_in">round</span>(center_point[i][<span class="number">1</span>]/count, <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> center_point</span><br><span class="line"></span><br><span class="line">    <span class="comment">#  再次分组</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">min_distance2</span>(<span class="params">self, coordinate_list, center_point</span>):</span></span><br><span class="line">        k = self.k</span><br><span class="line">        min_distance = []  <span class="comment"># 最小距离</span></span><br><span class="line">        min_distance_id = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.m)] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k)] <span class="comment"># 最小距离对应id</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.m):</span><br><span class="line">            mindist = <span class="number">20</span> <span class="comment"># 初始化最小距离</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">                center_distance = <span class="built_in">abs</span>(coordinate_list[i][<span class="number">0</span>] - center_point[j][<span class="number">0</span>]) + <span class="built_in">abs</span>(coordinate_list[i][<span class="number">1</span>] - center_point[j][<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">if</span> center_distance &lt; mindist:</span><br><span class="line">                    mindist = center_distance</span><br><span class="line">                    kid = j</span><br><span class="line">            min_distance.append(mindist)</span><br><span class="line">            min_distance_id[kid][i] = i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> min_distance_id</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输出分组结果</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">output_result</span>(<span class="params">self, min_distance_id</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.k):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.m):</span><br><span class="line">                <span class="keyword">if</span> min_distance_id[i][j] != <span class="number">0</span>:</span><br><span class="line">                    <span class="built_in">print</span>(min_distance_id[i][j], end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    m = <span class="number">12</span> <span class="comment"># 坐标点个数</span></span><br><span class="line">    k = <span class="number">3</span> <span class="comment"># 分组个数</span></span><br><span class="line">    kme= kmeans(m,k)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;依次输入坐标列表,如 3 4&#x27;</span>)</span><br><span class="line">    coordinate_list = kme.input_coordinate()</span><br><span class="line">    distance_list = kme.calculate_distance(coordinate_list)</span><br><span class="line">    kme.output_distance(distance_list)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始分组</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;初始分组，从1开始依次输入中心点id：&quot;</span>)</span><br><span class="line">    min_distance_id =  kme.min_distance1(distance_list)</span><br><span class="line">    kme.output_result(min_distance_id)</span><br><span class="line">    <span class="comment"># print(min_distance_id)</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        center_point = kme.update_center(coordinate_list, min_distance_id)</span><br><span class="line">        <span class="built_in">print</span>(center_point)</span><br><span class="line">        new_min_distance_id = kme.min_distance2(coordinate_list, center_point)</span><br><span class="line">        <span class="comment"># print(new_min_distance_id)</span></span><br><span class="line">        <span class="keyword">if</span> min_distance_id == new_min_distance_id:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        min_distance_id = new_min_distance_id</span><br><span class="line">        kme.output_result(min_distance_id)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> K-Means </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11中Lambda表达式</title>
      <link href="2021/12/02/C-11%E4%B8%ADLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>2021/12/02/C-11%E4%B8%ADLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>C++11的一大亮点就是引入了Lambda表达式。Lambda 表达式是一种定义匿名函数对象的简便方法，(关闭)在调用的位置或作为自变量传递给函数的位置。很多高级语言在很早以前就已经提供了Lambda表达式的功能，如C#，Python(argsort函数)等。</p><h1 id="Lambda原型"><a href="#Lambda原型" class="headerlink" title="Lambda原型"></a>Lambda原型</h1><p>Lambda表达式完整的声明格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture list] (params list) <span class="keyword">mutable</span> exception-&gt; <span class="keyword">return</span> type &#123; function body &#125;</span><br></pre></td></tr></table></figure><ul><li>capture list：捕获外部变量列表</li><li>params list：形参列表</li><li>mutable：以值捕获方式时是否可以修改捕获的变量(否就省略mutable)</li><li>exception：异常设定</li><li>return type：返回类型</li><li>function body：函数体</li></ul><p>常见的省略成分Lambda表达式有以下几种：</p><ol><li>[capture list] (params list) -&gt; return type {function body}</li><li>[capture list] (params list) {function body}</li><li>[capture list] {function body}</li></ol><ul><li>格式1声明了const类型的表达式（省略了mutable），这种类型的表达式不能修改捕获列表中的值。</li><li>格式2省略了返回值类型，但编译器可以根据以下规则推断出Lambda表达式的返回类型： （1）：如果function body中存在return语句，则该Lambda表达式的返回类型由return语句的返回类型确定； （2）：如果function body中没有return语句，则返回值为void类型。</li><li>格式3中省略了参数列表，类似普通函数中的无参函数。</li></ul><p>举个栗子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  a &lt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; myvec&#123; <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">2</span> &#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">lbvec</span><span class="params">(myvec)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(myvec.<span class="built_in">begin</span>(), myvec.<span class="built_in">end</span>(), cmp); <span class="comment">// 旧式做法</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;predicate function: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> it : myvec)  <span class="comment">// C++11中基于范围的for循环</span></span><br><span class="line">        cout &lt;&lt; it &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(lbvec.<span class="built_in">begin</span>(), lbvec.<span class="built_in">end</span>(), [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123; <span class="keyword">return</span> b &lt; a; &#125;);  <span class="comment">// Lambda表达式</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lambda expression: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> it : lbvec)</span><br><span class="line">        cout &lt;&lt; it &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出如下：</span></span><br><span class="line">predicate function: <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span></span><br><span class="line">lambda expression: <span class="number">7</span> <span class="number">5</span> <span class="number">3</span> <span class="number">3</span> <span class="number">2</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>C++11之前，我们使用STL的sort函数，需要提供一个<a href="https://gzwangu.github.io/2020/08/01/C-%E4%B8%ADsort-%E5%87%BD%E6%95%B0%E5%BC%BA%E5%A4%A7%E5%8A%9F%E8%83%BD/">谓词函数</a>。如果使用C++11的Lambda表达式，我们只需要传入一个匿名函数即可，方便简洁，而且代码的可读性也比旧式的做法好多了。</p><h1 id="捕获外部变量"><a href="#捕获外部变量" class="headerlink" title="捕获外部变量"></a>捕获外部变量</h1><p>Lambda表达式通过在最前面的方括号[ ]来明确指明其内部可以访问的外部变量，这一过程也称过Lambda表达式“捕获”了外部变量。</p><h2 id="值捕获"><a href="#值捕获" class="headerlink" title="值捕获"></a>值捕获</h2><p>值捕获和参数传递中的值传递类似，被捕获的变量的值在Lambda表达式创建时通过值拷贝的方式传入，因此随后对该变量的修改不会影响影响Lambda表达式中的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [a] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;; </span><br><span class="line">    a = <span class="number">234</span>;</span><br><span class="line">    <span class="built_in">f</span>();  <span class="comment">//123</span></span><br><span class="line">    <span class="keyword">auto</span> g = [a](<span class="keyword">int</span> b) &#123; cout &lt;&lt; a+b &lt;&lt; endl; &#125;;</span><br><span class="line">    a = <span class="number">567</span>;</span><br><span class="line">    <span class="built_in">g</span>(<span class="number">10</span>);  <span class="comment">//244</span></span><br><span class="line">    <span class="keyword">auto</span> h = [a] (<span class="keyword">int</span> b)&#123;a=<span class="number">0</span>; cout &lt;&lt; a+b &lt;&lt; endl; &#125;; <span class="comment">//报错，不能修改a</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意以传值方式捕获外部变量，则在Lambda表达式函数体中不能修改该外部变量的值。</p><h2 id="引用捕获"><a href="#引用捕获" class="headerlink" title="引用捕获"></a>引用捕获</h2><p>使用引用捕获一个外部变量，只需要在捕获列表变量前面加上一个引用说明符&amp;。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [&amp;a] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;; </span><br><span class="line">    a = <span class="number">234</span>;</span><br><span class="line">    <span class="built_in">f</span>();  <span class="comment">//234</span></span><br><span class="line">    <span class="keyword">auto</span> g = [&amp;a](<span class="keyword">int</span> b) &#123; cout &lt;&lt; a+b &lt;&lt; endl; &#125;;</span><br><span class="line">    a = <span class="number">567</span>;</span><br><span class="line">    <span class="built_in">g</span>(<span class="number">10</span>);  <span class="comment">//577</span></span><br><span class="line">    <span class="keyword">auto</span> h = [&amp;a] (<span class="keyword">int</span> b)&#123;a=<span class="number">0</span>; cout &lt;&lt; a+b &lt;&lt; endl; &#125;;</span><br><span class="line">    <span class="built_in">h</span>(<span class="number">20</span>);  <span class="comment">//20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="隐式捕获"><a href="#隐式捕获" class="headerlink" title="隐式捕获"></a>隐式捕获</h2><p>让编译器根据函数体中的代码来推断需要捕获哪些变量，这种方式称之为隐式捕获。隐式捕获有两种方式，分别是[=]和[&amp;]。[=]表示以值捕获的方式捕获外部变量，[&amp;]表示以引用捕获的方式捕获外部变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>,b = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [=] &#123; cout &lt;&lt; a+b &lt;&lt; endl; &#125;; </span><br><span class="line">    <span class="built_in">f</span>();  <span class="comment">// 13</span></span><br><span class="line">    <span class="keyword">auto</span> g = [&amp;] &#123; cout &lt;&lt; a+b &lt;&lt; endl; &#125;;</span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    b = <span class="number">15</span>;</span><br><span class="line">    <span class="built_in">g</span>();  <span class="comment">// 25</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="混合方式"><a href="#混合方式" class="headerlink" title="混合方式"></a>混合方式</h2><p>C++11中的Lambda表达式捕获外部变量主要有以下形式：</p><table><thead><tr><th>捕获形式</th><th>说明</th></tr></thead><tbody><tr><td>[ ]</td><td>不捕获任何外部变量</td></tr><tr><td>[变量名, …]</td><td>默认以值捕获指定的多个外部变量，如需引用捕获，则要&amp;声明</td></tr><tr><td>[=]</td><td>以值捕获所有外部变量</td></tr><tr><td>[&amp;]</td><td>以引用捕获所有外部变量</td></tr><tr><td>[=, &amp;x]</td><td>变量x以引用捕获，其余变量以传值捕获</td></tr><tr><td>[&amp;, x]</td><td>变量x以值的捕获，其余变量以引用捕获</td></tr><tr><td>[this]</td><td>通过引用捕获当前对象</td></tr><tr><td>[*this]</td><td>通过传值捕获当前对象</td></tr></tbody></table><h1 id="LeetCode—506-相对名次"><a href="#LeetCode—506-相对名次" class="headerlink" title="LeetCode—506.相对名次"></a>LeetCode—506.相对名次</h1><p>给你一个长度为 n 的整数数组 score ，其中 score[i] 是第 i 位运动员在比赛中的得分。所有得分都 互不相同 。</p><p>运动员将根据得分 决定名次 ，其中名次第 1 的运动员得分最高，名次第 2 的运动员得分第 2 高，依此类推。运动员的名次决定了他们的获奖情况：</p><p>名次第 1 的运动员获金牌 “Gold Medal” 。<br>名次第 2 的运动员获银牌 “Silver Medal” 。<br>名次第 3 的运动员获铜牌 “Bronze Medal” 。<br>从名次第 4 到第 n 的运动员，只能获得他们的名次编号（即，名次第 x 的运动员获得编号 “x”）。<br>使用长度为 n 的数组 answer 返回获奖，其中 answer[i] 是第 i 位运动员的获奖情况。</p><p>示例 1：</p><p>输入：score = [5,4,3,2,1]<br>输出：[“Gold Medal”,”Silver Medal”,”Bronze Medal”,”4”,”5”]<br>解释：名次为 [1st, 2nd, 3rd, 4th, 5th] 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findRelativeRanks</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; score)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; order;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;score.<span class="built_in">size</span>();i++)</span><br><span class="line">            order.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="built_in">sort</span>(order.<span class="built_in">begin</span>(),order.<span class="built_in">end</span>(),[&amp;score](<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;<span class="keyword">return</span> score[a]&gt;score[b];&#125;);  <span class="comment">// 返回的是数组值从大到小的索引值</span></span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">res</span><span class="params">(score.size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;score.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in"><span class="keyword">switch</span></span>(i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:res[order[i]]=<span class="string">&quot;Gold Medal&quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:res[order[i]]=<span class="string">&quot;Silver Medal&quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:res[order[i]]=<span class="string">&quot;Bronze Medal&quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:res[order[i]]=<span class="built_in">to_string</span>(i+<span class="number">1</span>);<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>参考 <a href="https://www.cnblogs.com/DswCnblog/p/5629165.html">C++ 11 Lambda表达式</a></p><p><a href="https://leetcode-cn.com/problems/relative-ranks/">506. 相对名次</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lambda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DevOps导论-中国大学MOOC</title>
      <link href="2021/11/25/DevOps%E5%AF%BC%E8%AE%BA-%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6MOOC/"/>
      <url>2021/11/25/DevOps%E5%AF%BC%E8%AE%BA-%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6MOOC/</url>
      
        <content type="html"><![CDATA[<h1 id="DevOps概述"><a href="#DevOps概述" class="headerlink" title="DevOps概述"></a>DevOps概述</h1><p>1、下列描述中，不属于典型软件发展三大阶段的是：</p><p>A.网络化和服务化</p><p>B.软硬件一体化阶段</p><p>C.软件成为独立产品</p><p>D.软件作坊</p><p>正确答案：D </p><p>2、”Measure twice, Cut once” 是哪个阶段的典型开发特征？</p><p>A.软件成为独立产品阶段</p><p>B.软硬件一体化阶段</p><p>C.网络化阶段</p><p>D.软件作坊阶段</p><p>正确答案：B </p><p>3、‎关于软件过程管理，以下哪一种说法是比较贴切的：</p><p>A.软件过程管理是软件企业发展到较高层次才需要关心的话题。</p><p>B.软件过程管理主要关注软件成本和质量目标的达成。</p><p>C.软件过程管理关注的是企业软件过程能力的稳定输出和提升。</p><p>D.进入互联网时代，软件过程管理是过于老套的话题。</p><p>正确答案：C </p><p>4、软件开发的本质难题中哪一个与软件发展阶段没有直接关系？</p><p>A.一致性</p><p>B.可变性</p><p>C.复杂性</p><p>D.不可见性</p><p>正确答案：D </p><p>5、‏”Code and Fix” 是软件发展哪个阶段的典型开发特征？ </p><p>A.网络化和服务化</p><p>B.软硬件一体化</p><p>C.软件作为独立产品</p><p>D.互联网时代</p><p>正确答案：B </p><p>6、以下哪个因素促成了软件成为独立的产品？</p><p>A.互联网的出现</p><p>B.个人电脑的出现</p><p>C.操作系统的出现</p><p>D.高级程序设计语言的出现</p><p>正确答案：C </p><p>7‌、软件危机和软件工程这两个概念提出时间是？</p><p>A.上世纪七十年代</p><p>B.上世纪六十年代</p><p>C.上世纪八十年代</p><p>D.上世纪五十年代</p><p>正确答案：B </p><p>8、以下描述中，哪几种是网络化和服务化这个阶段的典型软件应用特征？</p><p>A.通过CD和DVD等方式支持大容量和快速分发软件拷贝</p><p>B.通过SaaS等方式来发布软件系统</p><p>C.快速演化、需求不确定</p><p>D.用户数量急剧增加</p><p>正确答案：B、C、D </p><p>9‌、关于形式化方法的描述当中，不正确的有哪些？</p><p>A.这种方法应用范围有限，例如：不适合跟客户讨论需求。</p><p>B.这种方法的主要目的是解决软件开发的效率问题</p><p>C.这种方法对开发人员技能有较高的要求</p><p>D.这种方法是网络化和服务化阶段用来应对软件开发本质四大难题而提出来的</p><p>正确答案：B、D </p><p>10、关于迭代式方法的说法哪些是比较恰当的？</p><p>A.迭代式方法主要特征在于将软件开发过程视作一个逐步学习和交流的过程</p><p>B.迭代式方法是指一类具有类似特征的方法</p><p>C.迭代式方法是上世纪九十年代中后期才出现的一种方法</p><p>D.迭代式方法主要是为了解决软件开发的质量问题</p><p>正确答案：A、B </p><p>11、‎DevOps方法的出现具有一定的必然性，与以下哪些软件应用特征相匹配？</p><p>A.软件定义世界，软件随处可见</p><p>B.软件在社会生活当中扮演了越来越关键的角色</p><p>C.软件系统部署环境越来越错综复杂</p><p>D.用户需求多变所带来了软件系统的快速演化的要求</p><p>正确答案：A、B、C、D </p><p>12、DevOps的哪些特点可以有效支撑当前社会对软件系统的期望？</p><p>A.虚拟机技术的大量应用</p><p>B.敏捷开发、精益思想以及看板方法，支持快速开发、交付、迭代和演化</p><p>C.微服务架构设计</p><p>D.工具链支持高效率的自动化</p><p>正确答案：A、B、C、D </p><p>13、在DevOps化的three ways当中，关注质量问题是第二个阶段才需要考虑的。</p><p>A.√</p><p>B.×</p><p>正确答案：B </p><p>14、DevOps中的XaaS特指 SaaS、PaaS以及IaaS这三种。</p><p>A.√</p><p>B.×</p><p>正确答案：B </p><p>15、DevOps化的Three ways当中，建立反馈机制是二阶段应该实现的目标。</p><p>A.×</p><p>B.√</p><p>正确答案：B </p><h1 id="个体软件过程"><a href="#个体软件过程" class="headerlink" title="个体软件过程"></a>个体软件过程</h1><p>1、下述各个度量项中，哪一个不是PSP的基本度量项？</p><p>A.缺陷</p><p>B.风险</p><p>C.规模</p><p>D.时间</p><p>正确答案：B  </p><p>2、‏关于面向用户的质量观，我们应该关注如下哪些问题：</p><p>A.用户期望的优先级对软件开发的影响？</p><p>B.用户期望是否有优先级？</p><p>C.真实用户是谁？</p><p>D.界面和可操作性是首要的，因为这是用户能直接感受到的。</p><p>正确答案：A、B、C </p><p>3、‎PSP当中为什么用缺陷管理替代质量管理？下述说法中正确的是：</p><p>A.因为缺陷管理相关的活动（例如，测试等）本来就是软件开发中必须要开展的活动。</p><p>B.因为单纯质量管理很难操作。</p><p>C.因为缺陷管理和质量管理其实是一回事。</p><p>D.因为缺陷往往对应了面向用户质量观中的首要用户期望。</p><p>正确答案：B、D </p><p>4、关于PROBE估算法，下述各种说法中，不正确的有哪些？</p><p>A.PROBE估算结果带着小数，肯定不准确，因而， 不应该在项目估算的时候使用。</p><p>B.PROBE方法不需要历史数据。</p><p>C.PROBE方法不能用来估算质量。</p><p>D.PROBE不能给出精确估算，因而适合用来跟用户讨论需求和规模。</p><p>正确答案：A、B、D </p><p>5‍、关于质量路径（Quality Journey），下列说法中哪些不恰当。</p><p>A.质量路径与个体软件工程师无关，是团队层面的集体努力。</p><p>B.高质量软件产品最终还是需要依赖测试来确保。</p><p>C.进入测试之前的高质量，是获得测试之后高质量软件系统的前提条件。</p><p>D.质量路径中所列举的方法都是提升开发质量的有效手段，可以随意选择使用。</p><p>正确答案：A、D </p><p>6、关于评审检查表，下述说法中不恰当的是：</p><p>A.项目团队所有人应该共用一份评审检查表，体现统一性</p><p>B.评审检查表应该是个性化的</p><p>C.评审检查表应该定期更新</p><p>D.评审检查表应该保持稳定，确保缺陷不会被遗漏</p><p>正确答案：A、D  </p><p>7、关于PQI，下述说法中不恰当的是：</p><p>A.PQI五个分指标都可以超过1.0，比如，设计时间多于编码时间的时候，该分指标就超过1.0了</p><p>B.PQI可以用来辅助判断模块开发的质量</p><p>C.PQI可以为过程改进提供依据</p><p>D.PQI越高越好，最好达到1.0</p><p>正确答案：A、D  </p><p>8、‏关于评审，下述说法中不恰当是：</p><p>A.代码的个人评审也应该通过评审检查表来进行。</p><p>B.如果安排了代码的小组评审，那么代码个人评审就可以不用做。</p><p>C.代码的个人评审应该安排在单元测试之后，确保评审对象有着较高的质量，提升评审价值。</p><p>D.代码的个人评审最好交叉进行，因为阅读自己代码容易产生思维定式，不利于缺陷发现。</p><p>正确答案：C、D  </p><p>9、关于质量的各种定义当中，下述哪些质量属性属于内部属性？</p><p>A.可扩展性</p><p>B.可移植性</p><p>C.可靠性</p><p>D.安全性</p><p>正确答案：A、B  </p><p>10、PSP鼓励使用瀑布型生命周期模型。</p><p>A.√</p><p>B.×</p><p>正确答案：B </p><p>11、‍对于初学者来说，代码评审速度可以控制到每小时不超过400行。</p><p>A.×</p><p>B.√</p><p>正确答案：A  </p><p>12、‌“高质量的软件开发是计划出来的”</p><p>A.√</p><p>B.×</p><p>正确答案：A  </p><h1 id="敏捷软件开发"><a href="#敏捷软件开发" class="headerlink" title="敏捷软件开发"></a>敏捷软件开发</h1><p>1、‌下列哪一项更好地描述了敏捷宣言？</p><p>A.它包含了许多敏捷团队使用的实践</p><p>B.它包含了建立敏捷思维方式的价值观</p><p>C.它定义了构建软件的规则</p><p>D.它概述了构建软件的最有效方法</p><p>正确答案：B </p><p>2、你是一家社交媒体公司的开发人员，正在开发一个项目，项目需要一个为企业客户创建私有网站的新功能。 您需要与公司的网络工程师一起确定部署策略，并提出一组工程师可以用于管理站点的服务和工具。 网络工程师希望在你的网络内部部署所有服务，但您和您的团队成员不同意，并且认为服务应该部署在客户的网络上。 为了达成一个协议，该项目的工作已经停止。 哪种敏捷价值最适合这种情况？</p><p>A.工作的软件 高于 详尽的文档</p><p>B.响应变化 高于 遵循计划</p><p>C.客户合作 高于 合同谈判</p><p>D.个体和互动 高于 流程和工具</p><p>正确答案：C </p><p>3、‍你是一个软件团队的开发人员。 一个用户向你的团队询问有关构建新功能的信息，并以规范的形式提供了需求。 她非常确定这个功能要如何工作，并承诺不会有任何变化。 哪种敏捷价值最适用于这种情况？</p><p>A.响应变化 高于 遵循计划</p><p>B.工作的软件 高于 详尽的文档</p><p>C.客户合作 高于 合同谈判</p><p>D.个体和互动 高于 流程和工具</p><p>正确答案：B </p><p>4、‏Sean是一个正在构建财务软件的团队的开发人员。 他的团队被要求开发一个新的交易系统。 他和他的团队召开会议来提出他们正在使用的工作流的图景。 然后，他们将流程放在白板上，流程中的每个步骤都有一列。 经过对团队在白板上的工作项目进行了几周观察，他们注意到这个过程中有几个步骤似乎过载了。对于他们来说，下一步应该做什么？</p><p>‍A.在较慢的步骤中使用更多的人力</p><p>B.对过载步骤中正在进行的工作项目的数量进行限制</p><p>C.与团队合作，在工作进展缓慢的阶段更好地完成工作</p><p>D.专注于完成看板上的工作</p><p>正确答案：B </p><p>5、‎下列哪一个不是精益原则？</p><p>A.识别所有的步骤</p><p>B.尽可能晚的做决定</p><p>C.消除浪费</p><p>D.实施反馈循环</p><p>正确答案：D </p><p>6、下列哪一个更好地描述了如何使用看板？</p><p>A.观察特征如何流经过程，以便团队可以确定如何限制WIP并通过工作流程中的步骤确定最均匀的工作流程</p><p>B.跟踪缺陷和问题，并创建解决产品问题的最快途径</p><p>C.帮助团队自我组织，并了解工作流程中的瓶颈所在</p><p>D.跟踪WIP限制和当前任务状态，以便团队知道他们还有多少工作要做</p><p>正确答案：A </p><p>7、‍以下不是经常出现在Kanban上记事贴中的内容</p><p>A.完成时间</p><p>B.谁在处理这个工作项</p><p>C.工作项描述</p><p>D.团队名词</p><p>正确答案：D </p><p>8、‍一个公司内，各个团队的Kanban列设置应当一致，便于公司管理。</p><p>A.×</p><p>B.√</p><p>正确答案：A </p><p>9、‏在制品规模越小越好，因为这样可以优化前置时间，并且团队的效率会变高。</p><p>A.√</p><p>B.×</p><p>正确答案：B </p><p>10、‏ 在DevOps中，可以使用Kanban方法，也可以使用Scrum等其他敏捷方法。</p><p>A.√</p><p>B.×</p><p>正确答案：A </p><h1 id="软件架构演化"><a href="#软件架构演化" class="headerlink" title="软件架构演化"></a>软件架构演化</h1><p>1、‍下面关于软件架构的描述哪个是不正确的？</p><p>A.软件架构即一系列重要的设计决策。</p><p>B.软件架构是一组特定的架构元素，包括处理元素、数据元素和上下文元素。</p><p>C.软件架构包含一系列重要决策，包括软件组织、构成系统的结构要素等。</p><p>D.软件架构包括系统组件、连接件和约束的集合。</p><p>正确答案：B<br>解析：  B、软件架构不包含上下文元素。</p><p>2、在应用分层架构的软件系统中，最先处理外部请求的是：</p><p>A.应用层</p><p>B.表现层</p><p>C.业务层</p><p>D.数据层</p><p>正确答案：B<br>解析：  B、在应用分层架构的软件系统中，各层处理外部请求的顺序依次是表现层、业务层、持久层和数据层。</p><p>3、以下哪个关于面向服务架构的描述是错误的？</p><p>A.面向服务架构包含服务提供者组件和服务消费者组件</p><p>B.在SOA中，服务消费者消费其他组件提供的服务不需要知道其具体的实现细节</p><p>C.SOA依赖企业服务总线为服务间的相互调用提供支持环境</p><p>D.面向服务架构是一个集中式组件的集合</p><p>正确答案：D<br>解析：  D、面向服务架构应该是分布式组件的集合。</p><p>4、‏以下对于微服务优点的描述中，哪一个是错误的？</p><p>A.微服务可以使用RPC进行服务间通信</p><p>B.微服务系统测试变得非常简单</p><p>C.单个微服务很简单，只关注一个业务功能</p><p>D.不同的微服务可以使用不同的语言进行开发</p><p>正确答案：B<br>解析：  B、分布式系统的复杂性使得系统测试变得复杂</p><p>5、在微服务架构中，ZooKeeper的主要作用是？</p><p>A.开发服务</p><p>B.调用服务</p><p>C.注册服务</p><p>D.封装服务</p><p>正确答案：C</p><p>6、‍除Spring Boot之外，主流的微服务开发框架还有什么？</p><p>A.Django</p><p>B.Apache Dubbo</p><p>C.Kubernetes</p><p>D.MyBaits</p><p>正确答案：B</p><p>7、‎在组成派看来，软件架构是指？</p><p>A.软件架构由软件元素、这些元素的外部可见属性，以及元素之间的关系组成。</p><p>B.软件架构包括系统组件、连接件和约束的集合。</p><p>C.软件架构将系统定义为计算组件及组件间的交互。</p><p>D.软件架构是一系列重要决策的集合，包括构成系统的结构要素及其接口的选择。</p><p>正确答案：A、B、C<br>解析：  D、决策派的观点</p><p>8、分层架构将软件系统的组件分成多个互不重叠的层，包括</p><p>A.应用层</p><p>B.物理层</p><p>C.表现层</p><p>D.数据层</p><p>正确答案：C、D<br>解析：  A、网络分层  B、网络分层</p><p>9、‎分层架构模式的缺点包括：</p><p>A.不易于持续发布和部署</p><p>B.代码调整通常比较麻烦</p><p>C.额外的性能开销</p><p>D.软件升级需要暂停整个服务</p><p>正确答案：A、B、C、D<br>解析：  C、见分层架构部分“分层架构模式特点”。</p><p>10、‍以下哪几个不是面向服务架构强调的实现原则？</p><p>A.服务去中心化</p><p>B.服务简单</p><p>C.服务解耦</p><p>D.服务自治</p><p>正确答案：A、B<br>解析：  A、微服务架构强调的实现原则。  B、微服务架构强调的实现原则。</p><p>11、‍以下选项中，哪些属于微服务架构的特点？</p><p>A.围绕业务能力组织</p><p>B.通过服务组件化</p><p>C.基础设施自动化</p><p>D.内聚和解耦</p><p>正确答案：A、B、C、D你</p><p>12、‎以下选项中，API网关模式的优点有哪些?</p><p>A.确保客户端不受服务实例位置的影响</p><p>B.增加请求往返次数</p><p>C.为每套客户端提供最优API</p><p>D.确保客户端不必关心应用程序的微服务拆分方式</p><p>正确答案：A、C、D<br>解析：  B、应为“减少”</p><p>13、‎与面向服务架构相关的Web服务标准包括：</p><p>A.HTTPS</p><p>B.UML</p><p>C.WSDL</p><p>D.UDDI</p><p>正确答案：A、C、D<br>解析：  B、应改为XML</p><p>14、‏单体应用的所有功能都被集成在一起作为一个单一的单元。</p><p>A.√</p><p>B.×</p><p>正确答案：A </p><p>15、单体架构更多地作为应用的部署架构，单体应用只运行在一个进程中。</p><p>A.√</p><p>B.×</p><p>正确答案：B<br>解析：可能存在单体应用的多个实例运行在多个进程中。</p><p>16、‍微服务架构架构风格是一种将一个单一应用程序开发为一个小型服务的方法。</p><p>A.×</p><p>B.√</p><p>正确答案：A<br>解析：一组小型服务，而非一个。</p><p>17、‍本质上，微服务架构是SOA的一种扩展。</p><p>A.√</p><p>B.×</p><p>正确答案：A </p><p>18、‏核心模式即针对采用微服务系统在通用场景下的所有问题，所使用的成熟的架构解决方案集合。</p><p>A.√</p><p>B.×</p><p>正确答案：B<br>解析：是在特定场景下的特定问题</p><h1 id="云原生与容器技术"><a href="#云原生与容器技术" class="headerlink" title="云原生与容器技术"></a>云原生与容器技术</h1><p>1、‍下列哪项不是Docker容器的特点：</p><p>A.资源使用较少</p><p>B.可以共享操作系统的资源</p><p>C.启动时间是分钟级</p><p>D.创建速度很快</p><p>正确答案：C </p><p>2、下列哪项不是Docker的网络模式</p><p>A.None模式</p><p>B.Host模式</p><p>C.其他全是</p><p>D.Bridge 模式</p><p>正确答案：C </p><p>3、以下哪些是Docker的存储驱动：‎</p><p>A.其他都是</p><p>B.Device mapper</p><p>C.AUFS</p><p>D.OverlayFS</p><p>正确答案：A </p><p>4、‍以下哪个命令可以查看当前运行容器：</p><p>A.docker logs</p><p>B.docker top</p><p>C.docker run</p><p>D.docker ps</p><p>正确答案：D </p><p>5、‏Kubernetes集群将元数据保存在以下哪个组件：</p><p>A.Etcd</p><p>B.Kubelet</p><p>C.Kube-apiserver</p><p>D.以上都不是</p><p>正确答案：A </p><p>6、‎以下哪些是Kubernetes的控制器：</p><p>A.ReplicaSet</p><p>B.Both ReplicaSet and Deployment</p><p>C.Deployment</p><p>D.Rolling Updates</p><p>正确答案：B </p><p>7、‍以下哪些是Kubernetes的核心概念</p><p>A.Services</p><p>B.其他都是</p><p>C.Volumes</p><p>D.Pods</p><p>正确答案：B </p><p>8、‎Kubernetes里面的Replication控制器的职责是：</p><p>A.帮助达到预期的状态</p><p>B.删除或者更新多个Pod</p><p>C.其他都是</p><p>D.当已存在的Pod异常退出后，创建新的Pod</p><p>正确答案：C </p><p>9、‏如何通过命令行创建一个容器</p><p>A.docker create</p><p>B.docker poll</p><p>C.docker start</p><p>D.docker run</p><p>正确答案：D </p><p>10、‏Dockerfile中的命令 RUN, CMD 和ENTRYPOINT几者有何区别?</p><p>A.ENTRYPOINT 配置容器启动时运行的命令</p><p>B.RUN 执行命令并创建新的镜像层，RUN 经常用于安装软件包。</p><p>C.其他都是</p><p>D.CMD 设置容器启动后默认执行的命令及其参数，但 CMD 能够被 docker run 后面跟的命令行参数替换</p><p>正确答案：C </p><p>11、‏使用Kubernetes带来的好处有哪些</p><p>A.自动调度</p><p>B.其他都是</p><p>C.横向扩展</p><p>D.自动回滚</p><p>正确答案：B </p><p>12、‌以下哪项用于确保pod不会被调度到不适当的节点上？</p><p>A.以上都不是</p><p>B.Taints</p><p>C.Taints 和 Tolerations</p><p>D.Tolerations</p><p>正确答案：C </p><p>13、‎Docker容器的状态有</p><p>A.Restarting</p><p>B.Running</p><p>C.Paused</p><p>D.Exited</p><p>正确答案：B、D </p><p>14、‌关于Kubernetes的namespace的论述是否正确：命名空间是在多个用户之间划分群集资源的方法</p><p>A.×</p><p>B.√</p><p>正确答案：B </p><p>15、‎以下描述是否正确：多步构建允许在Dockerfile中使用多个FROM指令。两个FROM指令之间的所有指令会生产一个中间镜像，最后一个FROM指令之后的指令将生成最终镜像。中间镜像中的文件可以通过COPY –from=<image-number>指令拷贝，其中image-number为镜像编号，0为第一个基础镜像。没有被拷贝的文件都不会存在于最终生成的镜像，这样可以减小镜像大小，同时避免出现安全问题。</p><p>A.√</p><p>B.×</p><p>正确答案：A </p><h1 id="DevOps工具链"><a href="#DevOps工具链" class="headerlink" title="DevOps工具链"></a>DevOps工具链</h1><p>1、‎下列哪项不属于DevOps工具生态圈？</p><p>A.编译</p><p>B.持续集成</p><p>C.持续部署</p><p>D.监控</p><p>正确答案：C </p><p>2、‎下列哪项不属于协同开发工具？</p><p>A.Confluence</p><p>B.Kanban</p><p>C.Rally</p><p>D.JIRA</p><p>正确答案：A </p><p>3、下列哪种持续集成工具是目前DevOps领域使用最广泛的？</p><p>A.Jenkins</p><p>B.Travis CI</p><p>C.TeamCity</p><p>D.VSTS</p><p>正确答案：A </p><p>4、‎下列哪种版本管理工具不是同宗同源的？</p><p>A.Git</p><p>B.Subversion</p><p>C.GitHub</p><p>D.GitLab</p><p>正确答案：B </p><p>5、‌以下哪项不是Git的文件目录？</p><p>A.工作目录</p><p>B.git目录</p><p>C.加载区</p><p>D.Documents</p><p>正确答案：D </p><p>6、‏下列哪种编译工具无法编译JAVA语言？</p><p>A.Ant</p><p>B.MSBuild</p><p>C.Maven</p><p>D.Gradle</p><p>正确答案：B </p><p>7、‍下列哪种工具无法实现对远程服务器的配置操作？</p><p>A.JIRA</p><p>B.Puppt</p><p>C.Ansible</p><p>D.Chef</p><p>正确答案：A </p><p>8、‍下列不属于测试的是</p><p>A.SIT部署</p><p>B.单元测试</p><p>C.UI测试</p><p>D.API测试</p><p>正确答案：A </p><p>9、 使用（）工具完成DevOps持续交付流水线编排配置？</p><p>A.Java</p><p>B.Jenkins</p><p>C.JUnit</p><p>D.SonarQube</p><p>正确答案：B </p><p>10、‏Git是何种工具？</p><p>A.单元测试工具</p><p>B.监控工具</p><p>C.版本管理工具</p><p>D.持续集成工具</p><p>正确答案：C </p><p>11、‌以下哪种工具是开源工具？</p><p>A.JUnit</p><p>B.TeamCity</p><p>C.Zabbix</p><p>D.JIRA</p><p>正确答案：A </p><p>12、下列哪种工具能模拟市场上主流浏览器的操作？</p><p>A.Jenkins</p><p>B.JUnit</p><p>C.Selenium</p><p>D.FitNesse</p><p>正确答案：C </p><p>13、JIRA Software不支持极限编程这种敏捷开发方法。</p><p>A.√</p><p>B.×</p><p>正确答案：A </p><p>14、Jenkins支持工作流即代码（pipeline-as-code）。</p><p>A.√</p><p>B.×</p><p>正确答案：A </p><p>15、‏Git使用副本方式存储文件版本。</p><p>A.×</p><p>B.√</p><p>正确答案：A </p><p>16、‏Selenium能实现自动化单元测试。</p><p>A.×</p><p>B.√</p><p>正确答案：A </p><p>17、‌Nagios不属于监控工具。</p><p>A.×</p><p>B.√</p><p>正确答案：A </p><p>18、Zabbix有两种工作模式。</p><p>A.√</p><p>B.×</p><p>正确答案：A </p><p>19、‏SonarQube能完成持续交付流水线编排配置</p><p>A.×</p><p>B.√</p><p>正确答案：A<br>解析：静态代码扫描</p><p>20、Ansible只需要在Server端安装就能实现对远程服务器的配置管理？</p><p>A.×</p><p>B.√</p><p>正确答案：B </p><h1 id="期末考试"><a href="#期末考试" class="headerlink" title="期末考试"></a>期末考试</h1><h2 id="客观题部分"><a href="#客观题部分" class="headerlink" title="客观题部分"></a>客观题部分</h2><p>1单选(1分)<br>‌下列描述中，不属于典型软件发展三大阶段的是：</p><p>A.软硬件一体化阶段</p><p>B.网络化和服务化</p><p>C.软件成为独立产品</p><p>D.软件作坊</p><p>正确答案：D</p><p>2单选(1分)<br>‍”Measure twice, Cut once” 是哪个阶段的典型开发特征？</p><p>A.软硬件一体化阶段</p><p>B.网络化阶段</p><p>C.软件成为独立产品阶段</p><p>D.软件作坊阶段</p><p>正确答案：A</p><p>3单选(1分)<br>关于软件过程管理，以下哪一种说法是比较贴切的：</p><p>A.软件过程管理主要关注软件成本和质量目标的达成。</p><p>B.进入互联网时代，软件过程管理是过于老套的话题。</p><p>C.软件过程管理关注的是企业软件过程能力的稳定输出和提升。</p><p>D.软件过程管理是软件企业发展到较高层次才需要关心的话题。</p><p>正确答案：C</p><p>4单选(1分)<br>‍软件开发的本质难题中哪一个与软件发展阶段没有直接关系？</p><p>A.复杂性</p><p>B.可变性</p><p>C.一致性</p><p>D.不可见性</p><p>正确答案：D</p><p>5单选(1分)<br>‏以下哪个因素促成了软件成为独立的产品？</p><p>A.个人电脑的出现</p><p>B.高级程序设计语言的出现</p><p>C.操作系统的出现</p><p>D.互联网的出现</p><p>正确答案：C</p><p>6单选(1分)<br>‌软件危机和软件工程这两个概念提出时间是？</p><p>A.上世纪六十年代</p><p>B.上世纪八十年代</p><p>C.上世纪七十年代</p><p>D.上世纪五十年代</p><p>正确答案：A</p><p>7单选(1分)<br>‏下述各个度量项中，哪一个不是PSP的基本度量项？</p><p>A.缺陷</p><p>B.时间</p><p>C.风险</p><p>D.规模</p><p>正确答案：C</p><p>8单选(1分)<br>‎根据敏捷宣言，以下哪项描述了更多的价值？</p><p>A.可工作的软件、个体交互、响应变化、相近的文档 </p><p>B.响应变化、个体和交互、流程和工作、客户协作</p><p>C.客户协作、遵循计划、可工作的软件、个体交互</p><p>D.个体和交互、可工作的软件、客户协作、响应变化</p><p>正确答案：D</p><p>9单选(1分)<br>下列哪一项更好地描述了敏捷宣言？</p><p>A.它包含了建立敏捷思维方式的价值观</p><p>B.它定义了构建软件的规则</p><p>C.它概述了构建软件的最有效方法</p><p>D.它包含了许多敏捷团队使用的实践</p><p>正确答案：A</p><p>10单选(1分)<br>‍你是一家社交媒体公司的开发人员，正在开发一个项目，项目需要一个为企业客户创建私有网站的新功能。 您需要与公司的网络工程师一起确定部署策略，并提出一组工程师可以用于管理站点的服务和工具。 网络工程师希望在你的网络内部部署所有服务，但您和您的团队成员不同意，并且认为服务应该部署在客户的网络上。 为了达成一个协议，该项目的工作已经停止。 哪种敏捷价值最适合这种情况？</p><p>A.工作的软件 高于 详尽的文档</p><p>B.客户合作 高于 合同谈判</p><p>C.个体和互动 高于 流程和工具</p><p>D.响应变化 高于 遵循计划</p><p>正确答案：B</p><p>11单选(1分)<br>‏你是一个软件团队的开发人员。 一个用户向你的团队询问有关构建新功能的信息，并以规范的形式提供了需求。 她非常确定这个功能要如何工作，并承诺不会有任何变化。 哪种敏捷价值最适用于这种情况？</p><p>A.客户合作 高于 合同谈判</p><p>B.个体和互动 高于 流程和工具</p><p>C.响应变化 高于 遵循计划</p><p>D.工作的软件 高于 详尽的文档</p><p>正确答案：D</p><p>12单选(1分)<br>‏下列哪一个更好地描述了如何使用看板？</p><p>A.观察特征如何流经过程，以便团队可以确定如何限制WIP并通过工作流程中的步骤确定最均匀的工作流程</p><p>B.跟踪缺陷和问题，并创建解决产品问题的最快途径</p><p>C.帮助团队自我组织，并了解工作流程中的瓶颈所在</p><p>D.跟踪WIP限制和当前任务状态，以便团队知道他们还有多少工作要做</p><p>正确答案：A</p><p>13单选(1分)<br>‍下面关于软件架构的描述哪个是不正确的？</p><p>A.软件架构包括系统组件、连接件和约束的集合。</p><p>B.软件架构即一系列重要的设计决策。</p><p>C.软件架构包含一系列重要决策，包括软件组织、构成系统的结构要素等。</p><p>D.软件架构是一组特定的架构元素，包括处理元素、数据元素和上下文元素。</p><p>正确答案：D</p><p>14单选(1分)<br>以下哪个关于面向服务架构的描述是错误的？</p><p>A.面向服务架构包含服务提供者组件和服务消费者组件</p><p>B.面向服务架构是一个集中式组件的集合</p><p>C.SOA依赖企业服务总线为服务间的相互调用提供支持环境</p><p>D.在SOA中，服务消费者消费其他组件提供的服务不需要知道其具体的实现细节</p><p>正确答案：B</p><p>15单选(1分)<br>以下对于微服务优点的描述中，哪一个是错误的？</p><p>A.不同的微服务可以使用不同的语言进行开发</p><p>B.单个微服务很简单，只关注一个业务功能</p><p>C.微服务可以使用RPC进行服务间通信</p><p>D.微服务系统测试变得非常简单</p><p>正确答案：D</p><p>16单选(1分)<br>‍在微服务架构中，ZooKeeper的主要作用是？</p><p>A.封装服务</p><p>B.调用服务</p><p>C.注册服务</p><p>D.开发服务</p><p>正确答案：C</p><p>17单选(1分)<br>下列哪项不是Docker容器的特点：</p><p>A.资源使用较少</p><p>B.启动时间是分钟级</p><p>C.可以共享操作系统的资源</p><p>D.创建速度很快    </p><p>正确答案：B</p><p>18单选(1分)<br>‏以下哪些是Docker的存储驱动：</p><p>A.Device mapper</p><p>B.AUFS</p><p>C.其他都是</p><p>D.OverlayFS</p><p>正确答案：C</p><p>19单选(1分)<br>‌以下哪个命令可以查看当前运行容器：</p><p>‎A.docker logs</p><p>B.docker ps</p><p>C.docker top</p><p>D.docker run</p><p>正确答案：B</p><p>20单选(1分)<br>‎Kubernetes集群将元数据保存在以下哪个组件：</p><p>A.Kubelet</p><p>B.其他都不是</p><p>C.Etcd</p><p>D.Kube-apiserver</p><p>正确答案：C</p><p>21单选(1分)<br>Kubernetes里面的Replication控制器的职责是：</p><p>A.其他都是</p><p>B.删除或者更新多个Pod     </p><p>C.当已存在的Pod异常退出后，创建新的Pod</p><p>D.帮助达到预期的状态</p><p>正确答案：A</p><p>22单选(1分)<br>‏如何通过命令行创建一个容器</p><p>A.docker create</p><p>B.docker poll</p><p>C.docker start</p><p>D.docker run</p><p>正确答案：D</p><p>23单选(1分)<br>‌Dockerfile中的命令 RUN, CMD 和ENTRYPOINT几者有何区别?</p><p>A.RUN 执行命令并创建新的镜像层，RUN 经常用于安装软件包。</p><p>B.ENTRYPOINT 配置容器启动时运行的命令</p><p>C.CMD 设置容器启动后默认执行的命令及其参数，但 CMD 能够被 docker run 后面跟的命令行参数替换</p><p>D.其他都是</p><p>正确答案：D</p><p>24单选(1分)<br>‌使用Kubernetes带来的好处有哪些</p><p>A.其他都是</p><p>B.横向扩展</p><p>C.自动回滚</p><p>D.自动调度</p><p>正确答案：A</p><p>25单选(1分)<br>下列哪项不属于DevOps工具生态圈？</p><p>A.持续部署</p><p>B.监控</p><p>C.持续集成</p><p>D.编译</p><p>正确答案：A</p><p>26单选(1分)<br>‎下列哪项不属于协同开发工具？</p><p>A.Confluence</p><p>B.Rally</p><p>C.Kanban</p><p>D.JIRA</p><p>正确答案：A</p><p>27单选(1分)<br>下列哪种持续集成工具是目前DevOps领域使用最广泛的？</p><p>A.VSTS</p><p>B.Jenkins</p><p>C.TeamCity</p><p>D.Travis CI</p><p>正确答案：B</p><p>28单选(1分)<br>‎下列哪种版本管理工具不是同宗同源的？</p><p>A.GitLab</p><p>B.Git</p><p>C.Subversion</p><p>D.GitHub</p><p>正确答案：C</p><p>29单选(1分)<br>以下选项中，哪一项不属于API网关模式的优点？</p><p>A.确保客户端不受服务实例位置的影响。</p><p>B.确保客户端不必关心应用程序的微服务拆分方式。</p><p>C.增加请求往返次数。</p><p>D.将从客户端调用多项服务的逻辑转换为从API网关处调用，以简化整个客户端。</p><p>正确答案：C</p><p>30单选(1分)<br>‏以下选项中，哪一项不属于微服务架构的特点？</p><p>A.低内聚和高耦合</p><p>B.去中心化</p><p>C.基础设施自动化</p><p>D.围绕业务能力组织</p><p>正确答案：A</p><p>31多选(2分)<br>‌以下描述中，哪几种是网络化和服务化这个阶段的典型软件应用特征？</p><p>A.通过CD和DVD等方式支持大容量和快速分发软件拷贝</p><p>B.通过SaaS等方式来发布软件系统</p><p>C.用户数量急剧增加</p><p>D.快速演化、需求不确定</p><p>正确答案：B、C、D</p><p>32多选(2分)<br>‌关于形式化方法的描述当中，不正确的有哪些？</p><p>A.这种方法应用范围有限，例如：不适合跟客户讨论需求。</p><p>B.这种方法对开发人员技能有较高的要求</p><p>C.这种方法是网络化和服务化阶段用来应对软件开发本质四大难题而提出来的</p><p>D.这种方法的主要目的是解决软件开发的效率问题</p><p>正确答案：C、D</p><p>33多选(2分)<br>‌关于迭代式方法的说法哪些是比较恰当的？</p><p>A.迭代式方法是指一类具有类似特征的方法</p><p>B.迭代式方法主要特征在于将软件开发过程视作一个逐步学习和交流的过程</p><p>C.迭代式方法是上世纪九十年代中后期才出现的一种方法</p><p>D.迭代式方法主要是为了解决软件开发的质量问题</p><p>正确答案：A、B</p><p>34多选(2分)<br>‍DevOps方法的出现具有一定的必然性，与以下哪些软件应用特征相匹配？</p><p>A.软件系统部署环境越来越错综复杂</p><p>B.软件在社会生活当中扮演了越来越关键的角色</p><p>C.软件定义世界，软件随处可见</p><p>D.用户需求多变所带来了软件系统的快速演化的要求</p><p>正确答案：A、B、C、D</p><p>35多选(2分)<br>‎DevOps的哪些特点可以有效支撑当前社会对软件系统的期望？</p><p>A.敏捷开发、精益思想以及看板方法，支持快速开发、交付、迭代和演化</p><p>B.微服务架构设计</p><p>C.工具链支持高效率的自动化</p><p>D.虚拟机技术的大量应用</p><p>正确答案：A、B、C、D</p><p>36多选(2分)<br>‌关于面向用户的质量观，我们应该关注如下哪些问题：</p><p>A.用户期望的优先级对软件开发的影响？</p><p>B.真实用户是谁？</p><p>C.界面和可操作性是首要的，因为这是用户能直接感受到的。</p><p>D.用户期望是否有优先级？</p><p>正确答案：A、B、D</p><p>37多选(2分)<br>‏关于PROBE估算法，下述各种说法中，不正确的有哪些？</p><p>A.PROBE方法不能用来估算质量。</p><p>B.PROBE方法不需要历史数据。</p><p>C.PROBE不能给出精确估算，因而适合用来跟用户讨论需求和规模。</p><p>D.PROBE估算结果带着小数，肯定不准确，因而， 不应该在项目估算的时候使用。</p><p>正确答案：B、C、D</p><p>38多选(2分)<br>‌关于质量路径（Quality Journey），下列说法中哪些不恰当。</p><p>A.进入测试之前的高质量，是获得测试之后高质量软件系统的前提条件。</p><p>B.高质量软件产品最终还是需要依赖测试来确保。v</p><p>C.质量路径与个体软件工程师无关，是团队层面的集体努力。</p><p>D.质量路径中所列举的方法都是提升开发质量的有效手段，可以随意选择使用。</p><p>正确答案：C、D</p><p>39多选(2分)<br>‌关于评审检查表，下述说法中不恰当的是：</p><p>A.评审检查表应该保持稳定，确保缺陷不会被遗漏</p><p>B.项目团队所有人应该共用一份评审检查表，体现统一性</p><p>C.评审检查表应该定期更新</p><p>D.评审检查表应该是个性化的</p><p>正确答案：A、B</p><p>40多选(2分)<br>关于PQI，下述说法中不恰当的是：</p><p>A.PQI五个分指标都可以超过1.0，比如，设计时间多于编码时间的时候，该分指标就超过1.0了</p><p>B.PQI可以用来辅助判断模块开发的质量</p><p>C.PQI越高越好，最好达到1.0</p><p>D.PQI可以为过程改进提供依据</p><p>正确答案：A、C</p><p>41多选(2分)<br>‎关于质量的各种定义当中，下述哪些质量属性属于内部属性？</p><p>‍A.可靠性</p><p>B.安全性</p><p>C.可扩展性</p><p>D.可移植性</p><p>正确答案：C、D</p><p>42多选(2分)<br>‎在组成派看来，软件架构是指？</p><p>A.软件架构将系统定义为计算组件及组件间的交互。</p><p>B.软件架构由软件元素、这些元素的外部可见属性，以及元素之间的关系组成。</p><p>C.软件架构是一系列重要决策的集合，包括构成系统的结构要素及其接口的选择。</p><p>D.软件架构包括系统组件、连接件和约束的集合。</p><p>正确答案：A、B、D</p><p>43多选(2分)<br>‌分层架构将软件系统的组件分成多个互不重叠的层，包括</p><p>A.应用层</p><p>B.数据层</p><p>C.物理层</p><p>D.表现层</p><p>正确答案：B、D</p><p>44多选(2分)<br>‏分层架构模式的缺点包括：</p><p>A.不易于持续发布和部署</p><p>B.由于层间依赖关系，软件系统的可扩展性差</p><p>C.额外的性能开销</p><p>D.软件升级需要暂停整个服务</p><p>正确答案：A、B、C、D</p><p>45多选(2分)<br>‍以下哪几个不是面向服务架构强调的实现原则？</p><p>A.服务无状态</p><p>B.服务组成</p><p>C.服务简单</p><p>D.服务去中心化</p><p>正确答案：C、D</p><p>46多选(2分)<br>‌以下选项中，哪些属于微服务架构的特点？</p><p>A.围绕业务能力组织</p><p>B.基础设施自动化</p><p>C.内聚和解耦</p><p>D.通过服务组件化</p><p>正确答案：A、B、C、D</p><p>47多选(2分)<br>‎以下选项中，API网关模式的优点有哪些?</p><p>A.增加请求往返次数</p><p>B.为每套客户端提供最优API</p><p>C.确保客户端不必关心应用程序的微服务拆分方式</p><p>D.将从客户端调用多项服务的逻辑转换为从API网关处调用，以简化整个客户端。</p><p>正确答案：B、C、D</p><p>48多选(2分)<br>‌与面向服务架构相关的Web服务标准包括：</p><p>A.HTTPS</p><p>B.WSDL</p><p>C.SOAP</p><p>D.UDDI</p><p>正确答案：A、B、C、D</p><p>49多选(2分)<br>‍Docker容器的状态有</p><p>A.Paused</p><p>B.Exited</p><p>C.Running</p><p>D.Restarting</p><p>正确答案：B、C</p><p>50多选(2分)<br>‎以下对于微服务优点的描述中，哪几项是正确的？</p><p>A.不同的微服务可以使用不同的语言进行开发。</p><p>B.单个微服务很简单，只关注一个业务功能</p><p>C.微服务系统测试变得非常简单</p><p>D.微服务可以使用RPC进行服务间通信</p><p>正确答案：A、B、D</p><p>51判断(1分)<br>DevOps化的Three ways当中，建立反馈机制是二阶段应该实现的目标。</p><p>A.√</p><p>B.×<br>正确答案：A</p><p>52判断(1分)<br>‎一个公司内，各个团队的Kanban列设置应当一致，便于公司管理。</p><p>A.√</p><p>B.×<br>正确答案：B</p><p>53判断(1分)<br>‍单体架构更多地作为应用的部署架构，单体应用只运行在一个进程中。</p><p>A.×</p><p>B.√<br>正确答案：A</p><p>54判断(1分)<br>‏本质上，微服务架构是SOA的一种扩展。</p><p>A.×</p><p>B.√<br>正确答案：B</p><p>55判断(1分)<br>‏核心模式即针对采用微服务系统在通用场景下的所有问题，所使用的成熟的架构解决方案集合。</p><p>A.×</p><p>B.√<br>正确答案：A</p><p>56判断(1分)<br>‌JIRA Software不支持极限编程这种敏捷开发方法。</p><p>A.×</p><p>B.√<br>正确答案：B</p><p>57判断(1分)<br>‌Zabbix有两种工作模式。</p><p>A.√</p><p>B.×<br>正确答案：A</p><p>58判断(1分)<br>‌微服务架构的特点包括“围绕业务能力组织”、“内聚和解耦”、“基础设施自动化”等。</p><p>A.√</p><p>B.×<br>正确答案：A</p><p>59判断(1分)<br>‍持续集成是DevOps理念中重要的一个实践环节，它经历了纯脚本驱动到持续集成工具两个发展阶段，目前正向第三个阶段流水线即代码的阶段发展</p><p>A.√</p><p>B.×<br>正确答案：A</p><p>60判断(1分)<br>‍Ansible是一款开源的配置管理工具。它采用Server和Client管理模式，Server端和Client端均需要安装Ansible，方能实现软件多节点部署。</p><p>A.×</p><p>B.√<br>正确答案：A</p><h2 id="主观题部分"><a href="#主观题部分" class="headerlink" title="主观题部分"></a>主观题部分</h2><p><strong>1( 5分 )</strong><br><strong>‌请谈谈微服务架构与面向服务的架构存在哪些异同？</strong></p><p>回答：<br>1、微服务是一种软件的架构风格，面向服务的架构（SOA）不是一种特定的技术，而是一种分布式计算的软件设计方法。</p><p>2、微服务简单的说就是组合化，它的每部分需要实现的功能可以有不同的小程序单独构成，然后相互之间协同实现一个大的目标。这个角度上来说，两者是一脉相承的，但是面向服务的架构，没有微服务的分离度高，相互之间的关联度还是相对较高。</p><p>3、微服务相比较来说，在各个组件上可以使用不一样的编程语言。</p><p>4、微服务更加关注于解耦，不追求系统之间的相关性。</p><p>5、微服务的系统发生改变只需要构建一个新的服务，简单快捷，但是SOA则需要对整个系统进行修改。</p><p>6、微服务使用的协议一般都是轻量级的协议，就像HTTP、Thrift API等协议，但是SOA则是使用更为复杂多样的多种消息协议。微服务的容错性能会更好，即使一个微服务出现问题，其他的微服务也会正常工作。</p><p>7、每个微服务都有单独的数据库，SOA则是共享一个数据库。</p><p>8、微服务的规模更小，SOA则是一个较大的规模。SOA可以是一个整体，也可以是多个微服务组成的。</p><p>该题得分：3.2<br>整体评价：无</p><p><strong>2( 5分 )</strong><br><strong>‎从你的理解出发，谈谈为什么微服务架构具有高可用性、灵活性等优点？</strong></p><p>回答：<br>1、微服务架构普遍被采用于云原生应用、无服务器计算、以及使用轻量级容器部署的应用等,根据Fowler的观点，由于服务数量众多（与单体应用实现相比），为了有效地开发、维护和运营这类应用，去中心化的持续交付和带有整体服务监控的DevOps是必要的。 遵循这种方法的一个合理性结果是，单独的微服务可以单独扩展。在单体应用架构方法中，一个支持三个功能的应用，即使只有其中一个功能需要添加资源约束，也需要对其进行整体的扩展。微服务则不同，只需要对有资源约束需求的微服务进行扩展， 这样就带来了资源和成本的优化。</p><p>2、微服务并不是单体应用中的一个层，相反，它是一个自成一体的业务功能，具有明确的接口，可以通过自己的内部组件实现分层架构。从策略的角度来看，微服务架构本质上遵循了Unix的 “做一件事，做好一件事 “的理念，改变应用程序的一小部分只需要重建和重新部署一个或少量的服务即可,使用可直达独立部署服务的精细化接口、业务驱动开发（如领域驱动设计）等原则。</p><p>该题得分：5<br>整体评价：无</p><p><strong>3( 5分 )</strong><br><strong>‎请描述一个简单的持续交付流水线所包含的基本步骤。</strong></p><p>‏<br>回答：<br>开发–&gt;版本控制–&gt;代码检查–&gt;构建–&gt;自动化测试–&gt;打包–&gt;远程仓库发布–&gt;自动化部署</p><p>该题得分：5<br>整体评价：无</p><p><strong>4( 5分 )</strong><br><strong>‌请列举出敏捷软件开发中常见的3中开发方法？</strong></p><p>‍<br>回答：<br>1、极限编程（简称XP），是一种近螺旋式的开发方法，它将复杂的开发过程分解为一个个相对比较简单的小周期；通过积极的交流、反馈以及其它一系列的方法，开发人员和客户可以非常清楚开发进度、变化、待解决的问题和潜在的困难等，并根据实际情况及时地调整开发过程。</p><p>2、精益开发，思想起源于丰田公司，旨在创造价值的目标下，通过改良流程不断地消除浪费。这种方法现已被广泛用于生产制造管理，对于IT系统建设，精益开发的常用工具模型是价值流模型。</p><p>3、Scrum 是一个用于开发和维护复杂产品的框架 ，是一个增量的、迭代的开发过程。Scrum以经验性过程控制理论（经验主义）做为理论基础的过程。经验主义主张知识源于经验, 以及基于已知的东西做决定。Scrum 采用迭代、增量的方法来优化可预见性并控制风险。</p><p>该题得分：5<br>整体评价：无</p><p><strong>5( 5分 )</strong><br><strong>‎请描述敏捷软件开发宣言内容？</strong></p><p>回答：<br>我们一直在实践中探寻更好的软件开发方法，<br>身体力行的同时也帮助他人。由此我们建立了如下价值观：</p><p>个体和互动 高于 流程和工具<br>工作的软件 高于 详尽的文档<br>客户合作 高于 合同谈判<br>响应变化 高于 遵循计划</p><p>也就是说，尽管右项有其价值，<br>我们更重视左项的价值。</p><p>该题得分：5<br>整体评价：无</p><p><strong>6( 5分 )</strong><br><strong>‍请解释一下什么是Kanban方法中的WIP？为什么要限制WIP？</strong></p><p>回答：<br>WIP全称是work in progress，表示在途工作量，即同时进行中的工作数量。</p><p>限制WIP可以让团队成员更佳专注与手边的工作，减少工作切换所造成的浪费，因而可以加速工作完成的时间。此外，当工作卡住而无法完成的时候，开发团队不能以此为借口忽略这些被卡住的工作（因为有WIP限制，不能无限制的一直拿工作而不完成它），此时就有可能会有人闲置下来，而影响工作流程与产能。鼓励团队成员一起解决问题，排除阻碍。可以更均衡的工作产出，避免前期开发后期集中或者压缩测试时间，能够更稳健的长久的进行敏捷实践。</p><p>该题得分：5<br>整体评价：无</p><p><strong>7( 5分 )</strong><br><strong>什么叫做面向用户的质量观？这种观点对软件开发有什么影响？</strong></p><p>‍<br>回答：<br>面向用户的质量观是定义质量为满足用户需求的程度。这个定义中需要进一步明确：用户究竟是谁？用户需求的优先级是什么？这种用户的优先级对软件产品的开发过程产生什么样的影响？怎样来度量这种质量观下的质量水平？</p><p>在软件开发中，用缺陷管理来替代质量管理，高质量产品也就意味着要求组成软件产品的各个组件基本无缺陷。缺陷消除的平均代价随着开发过程的进展会显著增加，各个组件的高质量是通过高质量评审来实现的。</p><p>该题得分：5<br>整体评价：无</p><p><strong>8( 5分 )</strong><br><strong>‎DevOps有哪些常见的质量手段有助于确保最终软件服务的质量？</strong></p><p>‏<br>回答：<br>1、持续集成。持续集成 (CI) 是一个开发过程，每天多次将代码集成到共享存储库中。借助自动化测试，CI 帮助允许团队及早识别错误、轻松定位问题，提高了软件质量并缩短了交付时间。</p><p>2、持续部署。通过评估拉取请求并将它们组合到主分支，持续部署为开发人员提供了对流水线末端产品的的关注。它允许企业快速部署、验证新功能，并在测试自动化完成后立即做出响应。有了持续部署流水线，一旦客户提交质量问题，团队就可以轻松处理新版本的错误，因为每个版本都是小批量交付的。</p><p>3、持续测试。在 CI/CD 工作流中，构建往往以小批量进行。因此，为每次构建，手动运行测试用例会非常耗时。持续测试借助自动化手段，尽早、逐步和充分地执行测试，发现问题解决问题。</p><p>4、自动化。借助强大的部署自动化手段和标准化的环境管理来降低部署操作的成本，确保部署任务的可重复性，减少部署出错的可能性。</p><p>5、DevOps 致力于在整个开发过程中的每一个环节都引入QA 和测试管理，使它们成为质量的推动者，并确保产品符合利益相关者和用户所设定的质量标准。QA 实际上被认为是DevOps 中非常关键的组件，甚至于DevOps 强调质量保证是每个人的责任。</p><p>该题得分：3.6<br>整体评价：无</p>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统实验</title>
      <link href="2021/11/24/Linux%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/"/>
      <url>2021/11/24/Linux%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<p>2021级研一《高级Linux系统》课程实验</p><h1 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a>实验一</h1><p>1、按以下磁盘分区规划安装CentOS 7.x：</p><p>/分区：40GB；</p><p>/boot分区：1GB；</p><p>SWAP分区：2GB。</p><p>2、配置FirewallD防火墙，在public区域中添加http服务，5801端口（TCP协议），并保证firewalld服务是启动的。</p><h2 id="CentOS系统安装"><a href="#CentOS系统安装" class="headerlink" title="CentOS系统安装"></a>CentOS系统安装</h2><p>宿主机：Windows 10 64位家庭中文版；Intel(R) Core(TM) i7-7500U CPU @ 2.70GHz  2.90 GHz；12.0 GB RAM；硬盘 1T<br>虚拟机：VMware Workstation 16 Pro<br>ISO镜像：<a href="http://mirrors.nju.edu.cn/centos/7.9.2009/isos/x86_64/">CentOS-7-x86_64-DVD-2009</a><br>安装CentOS-7之前，需要创建新的虚拟机</p><p><img src="101.png"></p><p>选择自定义(高级)，点击下一步</p><p><img src="102.png"></p><p>选择虚拟机硬件兼容性，默认最新</p><p><img src="103.png"></p><p>在新建虚拟机安装向导里选择稍后安装操作系统</p><p><img src="104.png"></p><p>客户机操作系统选择Linux，版本选择CentOS 7 64位</p><p><img src="105.png"></p><p>给虚拟机起名，并选择安装位置</p><p><img src="106.png"></p><p>根据电脑CPU性能为虚拟机选择处理器数量和每个处理器的内核数</p><p><img src="107.png"></p><p>设置虚拟机内存大小，这里设置4GB</p><p><img src="108.png"></p><p>选择虚拟机与真机网络连接方式，选择使用网络地址转换(NAT)</p><p><img src="109.png"></p><p>选择I/O控制器类型，默认即可</p><p><img src="110.png"></p><p>默认选择SCSI(S)磁盘类型</p><p><img src="111.png"></p><p>选择使用哪个磁盘，创建新虚拟磁盘</p><p><img src="112.png"></p><p>选择磁盘大小，设置50GB，不要勾选立即分配所有磁盘空间</p><p><img src="113.png"></p><p>指定存储磁盘的文件，默认即可</p><p><img src="114.png"></p><p>完成创建虚拟机向导</p><p><img src="115.png"></p><p>打开新创建的虚拟机里的编辑虚拟机设置，找到CD/DVD(IDE)一栏，点击使用ISO镜像文件，把本地光盘镜像挂载上</p><p><img src="116.png"></p><p><img src="117.png"></p><p>点击开启此虚拟机，开始安装CentOS 7系统</p><p><img src="118.png"></p><p>选择第一项Install CentOS 7，直接安装CentOS 7等待即可</p><p><img src="119.png"></p><p>选择安装语言，简体中文</p><p><img src="120.png"></p><p>安装信息摘要</p><p><img src="121.png"></p><p>时间和日期设置为亚洲地区，上海城市</p><p><img src="122.png"></p><p>选择汉语键盘布局，点击完成即可</p><p><img src="123.png"></p><p>软件选择GNOME桌面</p><p><img src="124.png"></p><p>点击安装位置，选择我要配置分区，点击完成</p><p><img src="125.png"></p><p><img src="126.png"></p><p>点击加号，选择/boot，给boot分区分1GB，点击添加挂载点</p><p><img src="127.png"></p><p>设置SWAP分区2GB</p><p><img src="128.png"></p><p>设置/分区40GB</p><p><img src="129.png"></p><p>按照上面步骤都分区完毕，点击完成，弹出更改摘要，点击接受更改</p><p><img src="130.png"></p><p>点击网络和主机名，先打开网卡获取到IP地址，再更改主机名</p><p><img src="131.png"></p><p>最后点击开始安装</p><p><img src="132.png"></p><p>设置ROOT密码</p><p><img src="133.png"></p><p>创建用户</p><p><img src="134.png"></p><p>等待系统安装完毕重启系统即可</p><p><img src="135.png"></p><p>初始设置里接受许可证，完成配置</p><p><img src="136.png"></p><p>安装成功界面如下</p><p><img src="137.png"></p><h2 id="FirewallD防火墙配置"><a href="#FirewallD防火墙配置" class="headerlink" title="FirewallD防火墙配置"></a>FirewallD防火墙配置</h2><p>配置FirewallD防火墙，依次点击应用程序—&gt;杂项—防火墙</p><p><img src="138.png"></p><p>配置选择永久，区域选择public，服务里勾选http</p><p><img src="139.png"></p><p>点击端口—&gt;添加，配置5801端口（TCP协议）</p><p><img src="140.png"></p><p>重启后查看防火墙状态、5801端口和public区域的详细信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl status firewalld </span><br><span class="line">firewall-cmd --query-port=5801/tcp</span><br><span class="line">firewall-cmd --list-all</span><br></pre></td></tr></table></figure><p><img src="141.png"></p><p>最后设置防火墙开机启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable firewalld</span><br></pre></td></tr></table></figure><p><img src="142.png"></p><h1 id="实验二"><a href="#实验二" class="headerlink" title="实验二"></a>实验二</h1><h2 id="第三章-字符界面操作基础"><a href="#第三章-字符界面操作基础" class="headerlink" title="第三章-字符界面操作基础"></a>第三章-字符界面操作基础</h2><p>1、使用shutdown命令设定在30分钟之后关闭计算机。</p><ul><li>shutdown -h +30</li></ul><p><img src="201.png"></p><p>2、使用命令将“cat /etc/inittab”设置为别名name，然后再取消别名。</p><ul><li>alias name=’cat /etc/inittab’</li><li>unalias name</li></ul><p><img src="202.png"></p><p>3、使用echo命令和输出重定向创建文本文件/root/nn，内容是Hello，然后再使用追加重定向输入内容为Linux。</p><ul><li>echo Hello&gt; /root/nn</li><li>echo Linux &gt;&gt; /root/nn</li></ul><p><img src="203.png"></p><p>4、使用管道方式分页显示/var目录下的内容。</p><ul><li>ls /var |more</li></ul><p><img src="204.png"></p><p>5、使用cat命令显示文件/etc/passwd和/etc/shadow，只有正确显示第一个文件时才显示第二个文件。</p><ul><li>cat /etc/passwd &amp;&amp; cat /etc/shadow</li></ul><p><img src="205.png"></p><p>6、使用vi编辑器创建文本文件/root/v，文件内容为hell，最后保存退出。</p><ul><li>vi  /root/v</li><li>a</li><li>hell</li><li>“ESC” Enter</li><li>ZZ</li></ul><p><img src="206.png"></p><p>系统默认进入到命令模式，按字母键“a”进入插入模式</p><p><img src="207.png"></p><p>在插入模式下进行文本编辑，内容为hell</p><p><img src="208.png"></p><p>编辑完成，按“Esc”键回到命令模式，再输入ZZ保存退出。</p><p><img src="209.png"></p><h2 id="第四章-目录和文件管理"><a href="#第四章-目录和文件管理" class="headerlink" title="第四章-目录和文件管理"></a>第四章-目录和文件管理</h2><p>1、使用命令切换到/etc目录，并显示当前工作目录路径。</p><ul><li>cd /etc</li><li>pwd</li></ul><p><img src="210.png"></p><p>2、使用命令显示/root目录下所有文件目录的详细信息，包括隐藏文件。</p><ul><li>ls -al /root</li></ul><p><img src="211.png"></p><p>3、使用命令创建空文件/root/ab，并将该文件的时间记录更改为2019年8月8日8点8分。</p><ul><li>touch /root/ab</li><li>touch -t 201908080808 /root/ab</li></ul><p><img src="212.png"></p><p>4、使用命令创建具有默认权限为744的目录/root/ak，然后将/etc/inittab文件复制到该目录中，最后再将该目录及其目录下的文件一起删除。</p><ul><li>mkdir -m 744 /root/ak</li><li>cp /etc/inittab /root/ak</li><li>rm -rf /root/ak</li></ul><p><img src="213.png"></p><p>5、统计文件/etc/inittab的行数、单词和字节数。</p><ul><li>wc /etc/inittab</li></ul><p><img src="214.png"></p><p>6、使用命令创建/root/a文件的硬链接文件/root/b和软链接文件/root/c。</p><ul><li>ln /root/a /root/b</li><li>ln -s /root/a /root/c</li></ul><p><img src="215.png"></p><p>先创建空文件/root/a，再创建/root/a文件的硬链接文件/root/b和软链接文件/root/c。a和b文件inode相同，链接数2为硬链接文件，c文件inode不同于a、b，链接数1为软链接文件。</p><h2 id="第五章-Linux常用操作命令"><a href="#第五章-Linux常用操作命令" class="headerlink" title="第五章-Linux常用操作命令"></a>第五章-Linux常用操作命令</h2><p>1、使用命令一次3行显示/etc/inittab文件内容。</p><ul><li>more -3 /etc/inittab</li></ul><p><img src="216.png"></p><p>2、使用cat命令创建mm.txt文件，文件内容为Hello。</p><ul><li>cat &gt;mm.txt&lt;&lt;EOF</li><li>Hello</li><li>EOF</li></ul><p><img src="217.png"></p><p>3、使用命令查找/etc目录下的文件fstab。</p><ul><li>find /etc -name fstab</li></ul><p><img src="218.png"></p><p>4、使用命令将当前计算机的主机名修改为IT。</p><ul><li>hostname IT</li></ul><p><img src="219.png"></p><p>5、使用命令显示公元2018年8月的月历。</p><ul><li>cal 8 2018</li></ul><p><img src="220.png"></p><p>6、使用命令将当前计算机时间设置为2018年8月6日。</p><ul><li>date -s 180806</li></ul><p><img src="221.png"></p><p>7、使用命令显示/etc/fstab文件的文件类型。</p><ul><li>ll /etc/fstab</li></ul><p><img src="222.png"></p><p>8、使用命令显示/root目录的磁盘占用量。</p><ul><li>du -h /root</li></ul><p><img src="223.png"></p><h1 id="实验三"><a href="#实验三" class="headerlink" title="实验三"></a>实验三</h1><h2 id="第七章-用户和组群账户管理"><a href="#第七章-用户和组群账户管理" class="headerlink" title="第七章-用户和组群账户管理"></a>第七章-用户和组群账户管理</h2><p>1、使用命令创建用户账户zhangsan，并设置其密码为111111，设置用户名全称为“张三”。</p><ul><li>useradd zhangsan</li><li>passwd zhangsan</li><li>usermod -c 张三 zhangsan</li></ul><p><img src="301.png"></p><p>2、使用命令修改用户账户zhangsan的UID为1700，其Shell类型为/bin/ksh。</p><ul><li>usermod -u 1700 zhangsan</li><li>usermod -s /bin/ksh zhangsan</li></ul><p><img src="302.png"></p><p>3、使用命令删除用户账户zhangsan，并且在删除该用户的同时一起删除其主目录。</p><ul><li>userdel -r zhangsan</li></ul><p><img src="303.png"></p><p>4、使用命令创建组群group1，并且在创建时设置其GID为1800。</p><ul><li>groupadd -g 1800 group1</li></ul><p><img src="304.png"></p><p>5、使用命令修改组群group1的新组群名称为“shanghai”。</p><ul><li>groupmod -n shanghai group1</li></ul><p><img src="305.png"></p><h2 id="第八章-磁盘分区和文件系统管理"><a href="#第八章-磁盘分区和文件系统管理" class="headerlink" title="第八章-磁盘分区和文件系统管理"></a>第八章-磁盘分区和文件系统管理</h2><p>1、对硬盘上的剩余空间进行分区，创建两个逻辑驱动器，容量分别为1GB和3GB。</p><p>(1)查看磁盘分区情况：</p><ul><li>fdisk -l</li></ul><p><img src="306.png"></p><p>(2)创建扩展分区，将剩余磁盘空间全都划分给扩展分区：</p><ul><li>fdisk /dev/sda</li></ul><p><img src="307.png"></p><p><img src="308.png"></p><p>(3)创建两个逻辑分区，容量分别为1GB和3GB：</p><p><img src="309.png"></p><p><img src="310.png"></p><p>(4)使用partprobe命令手动将分区信息同步到内核：</p><p><img src="311.png"></p><p>(5)格式化逻辑分区（非必要）：</p><p><img src="312.png"></p><p><img src="313.png"></p><p>2、对1GB分区创建文件系统为xfs，并将其以只读的方式挂载到/mnt/kk目录中。</p><ul><li>mkfs -t xfs /dev/sda5  #若上步格式化成ext4，需要强制格式化使用-f</li><li>mount -o ro /dev/sda5 /mnt/kk</li></ul><p><img src="314.png"></p><p>3、修改/etc/fstab文件，使得1GB分区开机时自动挂载到/mnt/kk目录中。</p><ul><li>blkid /dev/sda5</li><li>nano /etc/fstab</li><li>UUID={UUID} /mnt/kk xfs defaults 1 2</li></ul><p><img src="315.png"></p><p><img src="316.png"></p><p>4、在计算机上添加交换文件，文件大小为1GB。</p><ul><li>dd if=/dev/zero of=/swapfile bs=1024 count=1048576  #1024*1024</li><li>chown root:root /swapfile   #不加权限可能会报错</li><li>chomd 0600 /swapfile </li><li>mkswap /swapfile</li><li>swapon /swapfile</li><li>nano /etc/fstab</li><li>/swapfile swap swap defaults 0 0</li></ul><p><img src="317.png"></p><p><img src="318.png"></p><h2 id="第九章-软件包管理"><a href="#第九章-软件包管理" class="headerlink" title="第九章-软件包管理"></a>第九章-软件包管理</h2><p>1、使用rpm命令安装bind-chroot软件包，安装完毕后查看该软件包的描述信息。</p><p>依次安装bind-license-9.11.4-26.P2.el7_9.7.noarch.rpm</p><p>bind-libs-lite-9.11.4-26.P2.el7_9.7.x86_64.rpm</p><p>bind-libs-9.11.4-26.P2.el7_9.7.x86_64.rpm</p><p>bind-9.11.4-26.P2.el7_9.7.x86_64.rpm</p><p>bind-chroot-9.11.4-26.P2.el7_9.7.x86_64.rpm</p><ul><li>rpm -ivh bind-chroot-9.11.4-26.P2.el7_9.7.x86_64.rpm</li></ul><p><img src="319.png"></p><p>2、使用rpm命令查询crontabs软件包所包含的文件列表。</p><ul><li>rpm -ql crontabs</li></ul><p><img src="320.png"></p><p>3、使用rpm命令查询/etc/crontab文件属于哪个软件包。</p><ul><li>rpm -qf /etc/crontab</li></ul><p><img src="321.png"></p><p>4、在Linux系统上修改软件仓库为<a href="https://mirrors.nju.edu.cn./">https://mirrors.nju.edu.cn。</a></p><p><a href="http://mirrors.nju.edu.cn/help/centos">参考CentOS 镜像使用帮助</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo sed -e &#x27;s|^mirrorlist=|#mirrorlist=|g&#x27; \</span><br><span class="line">         -e &#x27;s|^#baseurl=http://mirror.centos.org|baseurl=https://mirror.nju.edu.cn|g&#x27; \</span><br><span class="line">         -i.bak \</span><br><span class="line">         /etc/yum.repos.d/CentOS-Base.repo</span><br><span class="line">         </span><br><span class="line">sudo yum makecache         </span><br></pre></td></tr></table></figure><p><img src="322.png"></p><p><img src="323.png"></p><p>5、使用yum命令安装samba软件包。</p><ul><li>yum install samba</li></ul><p><img src="324.png"></p><p><img src="325.png"></p><p>6、使用yum命令删除bind软件包。</p><ul><li>yum remove bind</li></ul><p><img src="326.png"></p><p>7、归档/root/abc目录，生成文件为/root/abc.tar。</p><ul><li>tar cvf /root/abc.tar /root/abc </li></ul><p><img src="327.png"></p><p>8、使用tar命令调用gzip压缩程序将/root/abc目录压缩成/root/abc.tar.gz文件。</p><ul><li>tar zcvf /root/abc.tar.gz /root/abc </li></ul><p><img src="328.png"></p><h1 id="实验四"><a href="#实验四" class="headerlink" title="实验四"></a>实验四</h1><h2 id="第十章-权限和所有者"><a href="#第十章-权限和所有者" class="headerlink" title="第十章-权限和所有者"></a>第十章-权限和所有者</h2><p>1、使用文字设定法对/root/ab文件设置权限，所有者为读取、写入和执行权限，同组用户为读取和写入权限，而其他用户没有任何权限。</p><ul><li>chmod u=rwx,g=rw,o=- /root/ab</li></ul><p><img src="401.png"></p><p>2、使用数字设定法设置/root/ab文件的权限，所有者只拥有读取和写入权限。</p><ul><li>chmod 600 /root/ab</li></ul><p><img src="402.png"></p><p>3、将/root/ab文件的所有者更改为用户zhangsan。</p><ul><li>chown zhangsan /root/ab</li></ul><p><img src="403.png"></p><h2 id="第十一章-Linux日常管理和维护"><a href="#第十一章-Linux日常管理和维护" class="headerlink" title="第十一章-Linux日常管理和维护"></a>第十一章-Linux日常管理和维护</h2><p>1、使用ps命令显示root用户的进程。</p><ul><li>ps -u root</li></ul><p><img src="404.png"></p><p>2、强制杀死crond进程。</p><ul><li>ps -ef | grep crond</li><li>kill -9 1249</li></ul><p><img src="405.png"></p><p>3、修改/etc/crontab文件实现自动化，使得每星期一的11:00将/boot目录及其子目录和文件复制到/root/abc目录下。</p><ul><li>nano /etc/crontab</li><li>0 11 * * 1 root cp -r /boot/ /root/abc/</li></ul><p><img src="406.png"></p><p><img src="407.png"></p><p>4、将网卡名称eno16777736更改为eth0。</p><p>（1）初始网卡名称为ens33</p><p><img src="408.png"></p><p>（2）编辑文件/etc/sysconfig/grub，在GRUB_CMDLINE_LINUX行尾部添加net.ifnames=0 biosdevname=0</p><p><img src="409.png"></p><p>（3）执行grub2-mkconfig -o /boot/grub2/grub.cfg，再重启系统</p><p><img src="410.png"></p><p>（4）ifconfig查看网卡名称已更改为eth0</p><p><img src="411.png"></p><p>5、使用GRUB2破解root用户的密码。</p><p>（1）在启动界面，内核名称上按“e”</p><p><img src="412.png"></p><p>（2）找到linux16开头的行，在行尾输入rd.break，按ctrl+x进入</p><p><img src="413.png"></p><p>（3）重新挂载根分区，进入根目录并修改用户密码，新建空文件，再连续输入2次“exit”（下图有误reboot应为exit）使selinux生效</p><ul><li>mount -o remount,rw /sysroot</li><li>chroot /sysroot</li><li>passwd</li><li>输入2次一样的密码</li><li>touch /.autorelabel</li><li>exit 两次</li></ul><p><img src="414.png"></p><p>6、设置GRUB2 PBKDF2加密口令。</p><p>（1）通过grub2-mkpasswd-pbkdf2生成密码</p><p><img src="415.png"></p><p>（2）将密码传到/boot/grub2/user.cfg文件，然后使其生效</p><ul><li>GRUB2_PASSWORD=’grub.pbkdf2.sha512.10000.570DA….E1B’</li><li>echo “GRUB2_PASSWORD=$GRUB2_PASSWORD”  &gt; /boot/grub2/user.cfg</li><li>grub2-mkconfig -o /boot/grub2/grub.cfg</li></ul><p><img src="416.png"></p><h2 id="第十二章-Linux网络基本配置"><a href="#第十二章-Linux网络基本配置" class="headerlink" title="第十二章-Linux网络基本配置"></a>第十二章-Linux网络基本配置</h2><p>1、通过修改/etc/sysconfig/network-scripts/ifcfg-eno16777736文件，设置计算机IP地址为192.168.0.2，子网掩码为255.255.255.0，网关IP地址为192.168.0.1。</p><ul><li>BOOTPROTO=static     # 静态分配</li><li>IPADDR=192.168.0.2       # IP地址</li><li>NETMASK=255.255.255.0     # 掩码值</li><li>GATEWAY=192.168.0.1           # 网关地址</li><li>systemctl restart network</li></ul><p><img src="417.png"></p><p><img src="418.png"></p><p><img src="419.png"></p><p>2、设置计算机解析域名时所指向的主DNS服务器IP地址为202.96.209.5。</p><ul><li>nano /etc/resolv.conf </li><li>nameserver 202.96.209.5</li><li>service network restart   </li></ul><p><img src="420.png"></p><p><img src="421.png"></p><p><img src="422.png"></p><p>3、配置网卡eno16777736别名设备eno16777736:1的IP地址为192.168.0.3，并且激活网卡eno16777736:1设备。</p><ul><li>ifconfig eth0:1 192.168.0.3</li><li>ifconfig eth0:1 up</li></ul><p><img src="423.png"></p><p>4、使用命令显示当前计算机系统的内核路由表信息。</p><ul><li>netstat -r</li></ul><p><img src="424.png"></p><p>5、显示端口号为22的连接情况。</p><ul><li>netstat -antu |grep 22</li></ul><p><img src="425.png"></p><p>6、捕获经过网络接口eno16777736的数据包。</p><ul><li>tcpdump -i eth0</li></ul><p><img src="426.png"></p><p>7、使用命令启动named服务，并且设置该服务在计算机启动时一起启动。</p><ul><li>systemctl start named.service</li><li>systemctl enable named.service</li></ul><p><img src="427.png"></p><h1 id="实验五"><a href="#实验五" class="headerlink" title="实验五"></a>实验五</h1><h2 id="第十三章-远程连接服务器配置"><a href="#第十三章-远程连接服务器配置" class="headerlink" title="第十三章-远程连接服务器配置"></a>第十三章-远程连接服务器配置</h2><p>1、在Linux系统中按以下要求配置OpenSSH服务器，然后在Windows系统中使用PuTTY软件连接到该服务器上，而且要求能显示中文字符。OpenSSH服务器监听端口：2200、不允许空口令用户登录和禁止用户lisi登录。</p><ul><li>nano /etc/ssh/sshd_config</li><li>Port 22</li><li>PermitEmptyPasswords no</li><li>DenyUsers lisi</li><li>systemctl start sshd.service</li></ul><p><img src="501.png"></p><p><img src="502.png"></p><p><img src="503.png"></p><p><img src="504.png"></p><p>2、用root用户把本地文件/root/a传送到远程主机（使用127.0.0.1模拟）的/root/目录下，并改名为b。</p><ul><li>scp /root/a <a href="mailto:&#x72;&#111;&#111;&#x74;&#64;&#49;&#x32;&#x37;&#x2e;&#x30;&#x2e;&#x30;&#46;&#x31;">&#x72;&#111;&#111;&#x74;&#64;&#49;&#x32;&#x37;&#x2e;&#x30;&#x2e;&#x30;&#46;&#x31;</a>:/root/b</li></ul><p><img src="505.png"></p><p>3、在Linux系统中配置VNC服务器，然后在Windows系统中使用VNC Viewer软件连接到该服务器。</p><ul><li>yum -y install tigervnc-server</li><li>vncserver</li><li>firewall-cmd –add-port=5902/tcp –permanent  #虚拟桌面号1开5901</li><li>firewall-cmd –reload</li></ul><p><img src="506.png"></p><p><img src="507.png"></p><p><img src="508.png"></p><p><img src="509.png"></p><h2 id="第十四章-NFS服务器配置"><a href="#第十四章-NFS服务器配置" class="headerlink" title="第十四章-NFS服务器配置"></a>第十四章-NFS服务器配置</h2><p>1、在Linux系统中按以下要求配置NFS服务器，然后在NFS客户端上将共享目录挂载到本地的/mnt/it目录下。共享目录：it、导出选项：共享目录具有读取和写入的权限。</p><ul><li>nano /etc/exports</li><li>/it  *(rw,no_root_squash)</li><li>systemctl start nfs-server.service</li><li>mount 192.168.160.131:/it /mnt/it  #NFS客户端</li></ul><p><img src="510.png"></p><p><img src="511.png"></p><p>2、在NFS客户端上设置开机自动挂载NFS文件系统，将NFS服务器上的共享目录以读取和写入的权限自动挂载到本地的/mnt/it目录下。</p><ul><li>nano /etc/fstab</li><li>192.168.160.131:/it /mnt/it nfs defaults 0 0</li></ul><p><img src="512.png"></p><p><img src="513.png"></p><h2 id="补充实验"><a href="#补充实验" class="headerlink" title="补充实验"></a>补充实验</h2><p>1、创建一个VG和LV，PE大小8M，LV中PE个数为100，将LV格式化为ext4文件系统，开机时自动挂载到/mnt/wshare，其中VG名称为wgroup ,LV名称为wshare。</p><p>2、为wshare逻辑卷创建大小为160M的快照wshare_snap，并将快照挂载到/mnt/wshare_snap。</p><p>3、将SELinux模式改为许可模式（Permissive）。</p>]]></content>
      
      
      <categories>
          
          <category> 课程实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中string的用法</title>
      <link href="2021/10/21/C-%E4%B8%ADstring%E7%9A%84%E7%94%A8%E6%B3%95/"/>
      <url>2021/10/21/C-%E4%B8%ADstring%E7%9A%84%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>串（String）是由 n(n&gt;=0) 个字符组成的有限序列，又名字符串。通常记为 s = “a0a1a2…an-1”，其中 ai 是串中的字符，n 是串的字符个数，也是串的长度，它不包括串结束符 ‘\0’，长度为 0 的串称为空串。</p><p>串空是任意串的子串；任一串是它自身的字串。除它本身外，一个串的其他子串都是他的真子串。</p><p>C++ 有关字符串的库函数名称为 <strong># include&lt;string&gt;</strong></p><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">string s;  <span class="comment">// 初始化一个空字符串  </span></span><br><span class="line">s = <span class="string">&quot;12345&quot;</span>;  <span class="comment">// 拷贝初始化 string s = &quot;12345&quot;;</span></span><br><span class="line">string ss[<span class="number">5</span>];  <span class="comment">// 初始化一个空字符串数组</span></span><br><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;123&quot;</span>)</span></span>;  <span class="comment">// 直接初始化</span></span><br><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(s1)</span></span>;  <span class="comment">// s2是s1的副本</span></span><br><span class="line">string s3=s2;  <span class="comment">// s3是s2的副本</span></span><br><span class="line"><span class="function">string <span class="title">s4</span><span class="params">(<span class="number">5</span>,<span class="string">&#x27;a&#x27;</span>)</span></span>;  <span class="comment">// s4 = &quot;aaaaa&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> cs[]=<span class="string">&quot;12345&quot;</span>;</span><br><span class="line"><span class="function">string <span class="title">s5</span><span class="params">(cs,<span class="number">3</span>)</span></span>;  <span class="comment">// 复制字符串cs的前3个字符到s5中</span></span><br><span class="line">string s6=<span class="string">&quot;0123456&quot;</span>;</span><br><span class="line"><span class="function">string <span class="title">s7</span><span class="params">(s6,<span class="number">2</span>)</span></span>;  <span class="comment">//从s6下标为2的字符开始拷贝至结束</span></span><br><span class="line"><span class="function">string <span class="title">s8</span><span class="params">(s6,<span class="number">2</span>,<span class="number">4</span>)</span></span>;  <span class="comment">// 从s6下标2开始4个字符的拷贝，若超过s6.size只拷贝到s6尾部</span></span><br><span class="line"><span class="function">string <span class="title">s9</span><span class="params">(s6,<span class="number">2</span>,<span class="number">10</span>)</span></span>;  <span class="comment">// s9.size = 5</span></span><br><span class="line"></span><br><span class="line">cout&lt;&lt;s,s1...s9&lt;&lt;endl;</span><br><span class="line"><span class="number">12345</span></span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="number">123</span></span><br><span class="line">aaaaa</span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="number">0123456</span></span><br><span class="line"><span class="number">23456</span></span><br><span class="line"><span class="number">2345</span></span><br><span class="line"><span class="number">23456</span>  </span><br></pre></td></tr></table></figure><h1 id="串处理"><a href="#串处理" class="headerlink" title="串处理"></a>串处理</h1><p><strong>substr 操作</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;0123456&quot;</span>;</span><br><span class="line"><span class="comment">// s.substr(pos,n)返回从位置为pos后面的n个字符组成的串</span></span><br><span class="line">string s1 = s.<span class="built_in">substr</span>(<span class="number">1</span>,<span class="number">5</span>); <span class="comment">// 12345</span></span><br><span class="line"><span class="comment">// s.substr(pos)得到一个从pos到结尾的串</span></span><br><span class="line">string s2 = s.<span class="built_in">substr</span>(<span class="number">4</span>); <span class="comment">// 456</span></span><br></pre></td></tr></table></figure><p><strong>insert 操作</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;0123456789&quot;</span>;</span><br><span class="line">string str1 = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">string str2 = <span class="string">&quot;ABCDEFGHIJKLMN&quot;</span>;</span><br><span class="line">string::iterator it;</span><br><span class="line"><span class="comment">//s.insert(pos,str)在s的pos位置插入str</span></span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">6</span>,str1); <span class="comment">// 012345abcd6789</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//s.insert(pos,str,a,n)在s的pos位置插入str中位置a到后面的n个字符</span></span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">6</span>,str2,<span class="number">3</span>,<span class="number">4</span>); <span class="comment">// 012345DEFGabcd6789</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//s.insert(pos,cstr,n)//在pos位置插入cstr字符串从开始到后面的n个字符</span></span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">10</span>,<span class="string">&quot;must be string&quot;</span>,<span class="number">8</span>); <span class="comment">// 012345DEFGmust be abcd6789</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//s.insert(pos,cstr)在s的pos位置插入cstr</span></span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">10</span>,<span class="string">&quot;string &quot;</span>); <span class="comment">// 012345DEFGstring must be abcd6789</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//s.insert(pos,n,ch)在s.pos位置上面插入n个ch</span></span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">10</span>,<span class="number">2</span>,<span class="string">&#x27;:&#x27;</span>); <span class="comment">// 012345DEFG::string must be abcd6789</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//s.insert(s.it,ch)在s的it指向位置插入一个字符ch，返回新插入的位置的迭代器</span></span><br><span class="line">it = str.<span class="built_in">insert</span>(str.<span class="built_in">begin</span>()+<span class="number">6</span>,<span class="string">&#x27;-&#x27;</span>); <span class="comment">// 012345-DEFG::string must be abcd6789</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//s.insert(s.it,n,ch)在s的it所指向位置插入n个ch</span></span><br><span class="line">str.<span class="built_in">insert</span> (str.<span class="built_in">end</span>(),<span class="number">3</span>,<span class="string">&#x27;.&#x27;</span>); <span class="comment">// 012345-DEFG::string must be abcd6789...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//s.insert(it,str.ita,str.itb)在it所指向的位置插入[ita,itb)的字符串</span></span><br><span class="line">str.<span class="built_in">insert</span> (it+<span class="number">1</span>,str2.<span class="built_in">begin</span>(),str2.<span class="built_in">begin</span>()+<span class="number">3</span>); <span class="comment">// 012345-ABCDEFG::string must be abcd6789...</span></span><br></pre></td></tr></table></figure><p><strong>erase 操作</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;0123456789&quot;</span>;</span><br><span class="line"><span class="comment">//s.erase(pos,n)删除pos位置开始n个字符</span></span><br><span class="line">str.<span class="built_in">erase</span>(<span class="number">3</span>,<span class="number">2</span>); <span class="comment">// 01256789</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//s.erase(s.it)删除迭代器指向的字符</span></span><br><span class="line">str.<span class="built_in">erase</span>(str.<span class="built_in">begin</span>()+<span class="number">3</span>); <span class="comment">// 0126789</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//s.erase(str.ita,str.itb)删除迭代器范围的字符</span></span><br><span class="line">str.<span class="built_in">erase</span>(str.<span class="built_in">begin</span>()+<span class="number">3</span>, str.<span class="built_in">end</span>()<span class="number">-1</span>); <span class="comment">// 0129</span></span><br></pre></td></tr></table></figure><p><strong>append 操作</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">string str1 = <span class="string">&quot;12345&quot;</span>;</span><br><span class="line">string str2 = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//s.append(str)直接追加一个str的字符串</span></span><br><span class="line">str.<span class="built_in">append</span>(str1); <span class="comment">// 012345</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//s.append(str,pos,n)追加str中pos位置开始的n个字符</span></span><br><span class="line">str.<span class="built_in">append</span>(str2,<span class="number">4</span>,<span class="number">2</span>); <span class="comment">// 012345ef</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//s.append(cstr,n)追加字符串形参cstr的前n个字符</span></span><br><span class="line">str.<span class="built_in">append</span>(<span class="string">&quot;string&quot;</span>,<span class="number">2</span>); <span class="comment">// 012345efst</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//s.append(cstr)直接追加cstr</span></span><br><span class="line">str.<span class="built_in">append</span>(<span class="string">&quot;haha&quot;</span>); <span class="comment">// 012345efsthaha</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//s.append(n,ch)添加n个ch</span></span><br><span class="line">str.<span class="built_in">append</span>(<span class="number">3</span>,<span class="string">&#x27;.&#x27;</span>); <span class="comment">// 012345efsthaha...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//s.append(str.ita,str.itb)添加str迭代器范围的字符串</span></span><br><span class="line">str.<span class="built_in">append</span>(str2.<span class="built_in">begin</span>()+<span class="number">2</span>,str2.<span class="built_in">end</span>()<span class="number">-2</span>); <span class="comment">// 012345efsthaha...cde</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串追加也可以用重载运算符实现</span></span><br><span class="line">str += <span class="string">&quot;add&quot;</span>; <span class="comment">// 012345efsthaha...cdeadd</span></span><br></pre></td></tr></table></figure><p>replace 操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;012345678&quot;</span>;</span><br><span class="line">string str1 = <span class="string">&quot;12345&quot;</span>;</span><br><span class="line">string str2 = <span class="string">&quot;abcd&quot;</span>;    </span><br><span class="line"></span><br><span class="line"><span class="comment">//s.replace(pos,n,str)从pos位置开始n个字符被str代替</span></span><br><span class="line">str.<span class="built_in">replace</span>(<span class="number">4</span>,<span class="number">3</span>,str1); <span class="comment">// 01231234578</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//s.replace(pos1,n1,str,pos2,n2)从pos1位置开始n1个字符被str串pos2位置开始n2个字符代替</span></span><br><span class="line">str.<span class="built_in">replace</span>(<span class="number">3</span>,<span class="number">5</span>,str2,<span class="number">1</span>,<span class="number">2</span>); <span class="comment">// 012bc578</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//s.replace(pos,n,cstr)从pos位置开始n个字符被cstr代替</span></span><br><span class="line">str.<span class="built_in">replace</span>(<span class="number">3</span>,<span class="number">4</span>,<span class="string">&quot;string&quot;</span>); <span class="comment">// 012string8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//s.replace(pos,n1,cstr,n2)从pos位置开始n1个字符被cstr的前n2个字符代替</span></span><br><span class="line">str.<span class="built_in">replace</span>(<span class="number">3</span>,<span class="number">5</span>,<span class="string">&quot;sample&quot;</span>,<span class="number">4</span>);  <span class="comment">// 012sampg8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//s.replace(pos,n1,n2,ch)从pos位置开始n1个字符被n2个ch字符代替</span></span><br><span class="line">str.<span class="built_in">replace</span>(<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">&#x27;!&#x27;</span>); <span class="comment">// 012sam!!!8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用迭代器同上</span></span><br><span class="line">str.<span class="built_in">replace</span>(str.<span class="built_in">begin</span>()+<span class="number">3</span>,str.<span class="built_in">end</span>()<span class="number">-1</span>,str1); <span class="comment">// 012123458</span></span><br><span class="line">str.<span class="built_in">replace</span>(str.<span class="built_in">begin</span>()+<span class="number">3</span>,str.<span class="built_in">end</span>()<span class="number">-4</span>,str2.<span class="built_in">begin</span>(),str2.<span class="built_in">end</span>()<span class="number">-1</span>); <span class="comment">// 012abc3458</span></span><br><span class="line">str.<span class="built_in">replace</span>(str.<span class="built_in">begin</span>()+<span class="number">3</span>,str.<span class="built_in">begin</span>()+<span class="number">5</span>,<span class="string">&quot;it-str&quot;</span>); <span class="comment">// 012it-strc3458</span></span><br><span class="line">str.<span class="built_in">replace</span>(str.<span class="built_in">begin</span>()+<span class="number">4</span>,str.<span class="built_in">begin</span>()+<span class="number">8</span>,<span class="string">&quot;sample&quot;</span>,<span class="number">3</span>); <span class="comment">// 012isamrc3458</span></span><br><span class="line">str.<span class="built_in">replace</span>(str.<span class="built_in">begin</span>()+<span class="number">1</span>,str.<span class="built_in">end</span>()<span class="number">-4</span>,<span class="number">1</span>,<span class="string">&#x27;.&#x27;</span>); <span class="comment">// 0.3458</span></span><br></pre></td></tr></table></figure><p><strong>assign 操作</strong></p><p>assign 操作在一起列容器当中都存在，比如 vector 等等。是一个很基本的操作函数，string 使用 assign 可以灵活的对其进行赋值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">string str;</span><br><span class="line">string str1 = <span class="string">&quot;01234567&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//s.assign(str)直接把str赋值给s</span></span><br><span class="line">str.<span class="built_in">assign</span>(str1); <span class="comment">// 01234567</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//s.assign(str,pos,n)把str中pos位置开始的n个字符赋给s</span></span><br><span class="line">str.<span class="built_in">assign</span>(str1,<span class="number">4</span>,<span class="number">3</span>); <span class="comment">//456</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//s.assign(cstr)直接使用参数赋值</span></span><br><span class="line">str.<span class="built_in">assign</span>(<span class="string">&quot;c-string&quot;</span>); <span class="comment">// c-string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//s.assign(n,ch)赋值n个ch字符</span></span><br><span class="line">str.<span class="built_in">assign</span>(<span class="number">5</span>,<span class="string">&#x27;*&#x27;</span>); <span class="comment">// *****</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//s.assign(str.ita,str.itb)指定str迭代器范围的字符串</span></span><br><span class="line">str.<span class="built_in">assign</span>(str1.<span class="built_in">begin</span>()+<span class="number">1</span>,str1.<span class="built_in">end</span>()<span class="number">-2</span>); <span class="comment">// 12345</span></span><br></pre></td></tr></table></figure><h1 id="串搜索"><a href="#串搜索" class="headerlink" title="串搜索"></a>串搜索</h1><p><strong>find 和 rfind 用法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//（1）size_t find (const string&amp; str, size_t pos = 0) const;  //查找对象--string类对象</span></span><br><span class="line"><span class="comment">//（2）size_t find (const char* s, size_t pos = 0) const; //查找对象--字符串</span></span><br><span class="line"><span class="comment">//（3）size_t find (const char* s, size_t pos, size_t n) const;  //查找对象--字符串的前n个字符</span></span><br><span class="line"><span class="comment">//（4）size_t find (char c, size_t pos = 0) const;  //查找对象--字符</span></span><br><span class="line">string str1 = <span class="string">&quot;I will find you and love you.&quot;</span>;</span><br><span class="line">string str2 = <span class="string">&quot;you&quot;</span>;</span><br><span class="line"><span class="keyword">size_t</span> ff_index;</span><br><span class="line"><span class="keyword">size_t</span> lf_index;</span><br><span class="line"></span><br><span class="line"><span class="comment">// s.find(str)在s中查找第一个出现的str，找到则返回出现的位置，否则返回-1</span></span><br><span class="line">ff_index = str1.<span class="built_in">find</span>(str2); <span class="comment">// 12</span></span><br><span class="line">ff_index = str1.<span class="built_in">find</span>(<span class="string">&quot;will&quot;</span>); <span class="comment">// 2</span></span><br><span class="line">lf_index = str1.<span class="built_in">rfind</span>(str2); <span class="comment">// 25</span></span><br><span class="line">lf_index = str1.<span class="built_in">rfind</span>(<span class="string">&quot;will&quot;</span>); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// // s.find(cstr,pos,n)从s的第pos位置查找ctsr参数字符串的前n个字符</span></span><br><span class="line">ff_index = str1.<span class="built_in">find</span>(<span class="string">&quot;you are cute&quot;</span>,<span class="number">13</span>,<span class="number">3</span>); <span class="comment">// 25</span></span><br><span class="line">lf_index = str1.<span class="built_in">rfind</span>(<span class="string">&quot;you are cute&quot;</span>,<span class="number">30</span>,<span class="number">4</span>); <span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// // s,find(ch)查找第一个ch字符</span></span><br><span class="line">ff_index = str1.<span class="built_in">find</span>(<span class="string">&#x27;f&#x27;</span>); <span class="comment">// 7</span></span><br><span class="line">lf_index = str1.<span class="built_in">rfind</span>(<span class="string">&#x27;o&#x27;</span>); <span class="comment">// 26</span></span><br></pre></td></tr></table></figure><p><strong>find….of 用法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// find_first_of(args) 查找args中任何一个字符第一次出现的位置</span></span><br><span class="line"><span class="comment">// find_last_of(args) 最后一个出现的位置</span></span><br><span class="line"><span class="comment">// find_fist_not_of(args) 查找第一个不在args中的字符</span></span><br><span class="line"><span class="comment">// find_last_not_of 查找最后一个不在args中出现的字符</span></span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;software string find is hard.&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">size_t</span> ffo,flo,ffno,flno;</span><br><span class="line">ffo = str.<span class="built_in">find_first_of</span>(<span class="string">&quot;aeiou&quot;</span>); <span class="comment">// 1</span></span><br><span class="line">flo = str.<span class="built_in">find_last_of</span>(<span class="string">&quot;aeiou&quot;</span>); <span class="comment">// 25</span></span><br><span class="line">ffno = str.<span class="built_in">find_first_not_of</span>(<span class="string">&quot;aeiou&quot;</span>); <span class="comment">// 0</span></span><br><span class="line">flno = str.<span class="built_in">find_last_not_of</span>(<span class="string">&quot;aeiou&quot;</span>); <span class="comment">// 28</span></span><br></pre></td></tr></table></figure><p><strong>compare 用法</strong></p><p>如果两个字符串相等，那么返回0，调用对象大于参数返回1，小于返回-1。string 重载了运算符，可以直接用 &gt;、&lt; 和 ==来进行比较。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">string s1=<span class="string">&quot;123&quot;</span>,s2=<span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> cmp = s1.<span class="built_in">compare</span>(s2); <span class="comment">// 0</span></span><br><span class="line">s1 = <span class="string">&quot;223&quot;</span>;</span><br><span class="line">s2 = <span class="string">&quot;1234&quot;</span>;</span><br><span class="line">cmp =  s1.<span class="built_in">compare</span>(s2); <span class="comment">// 1</span></span><br><span class="line">s1 = <span class="string">&quot;012345&quot;</span>;</span><br><span class="line">s2 = <span class="string">&quot;12345&quot;</span>;</span><br><span class="line">cmp = s1.<span class="built_in">compare</span>(s2); <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//s.compare(pos,n,str)s串pos位置开始的n个字符和str比较</span></span><br><span class="line">cmp = s1.<span class="built_in">compare</span>(<span class="number">1</span>,<span class="number">5</span>,s2); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//s.compare(pos1,n1,str,pos2,n2)s串pos1位置开始的n1个字符和str串pos2位置开始的n2个字符比较</span></span><br><span class="line">cmp = s1.<span class="built_in">compare</span>(<span class="number">2</span>,<span class="number">3</span>,s2,<span class="number">2</span>,<span class="number">3</span>); <span class="comment">// -1 234&lt;345</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用数据结构及C++实现</title>
      <link href="2021/09/16/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8AC++%E5%AE%9E%E7%8E%B0/"/>
      <url>2021/09/16/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8AC++%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>最近刷算法题发现能想到用什么数据结构来高效率解题，太弱了具体实现和用法却不会。以前上学没好好听课，现在来恶补一下数据结构。</p><p>按照视点的不同，数据结构分为<strong>逻辑结构</strong>和<strong>物理结构</strong>。</p><ul><li>逻辑结构：指数据元素之间的逻辑关系，这里的逻辑关系是指数据元素之间的前后关系，与数据在计算机中的存储位置无关。</li><li>物理结构：指数据的逻辑结构在计算机中的存储形式，也叫做存储结构。</li></ul><p>数据的逻辑结构主要分为<strong>线性结构</strong>和<strong>非线性结构</strong>。</p><ul><li>线性结构：数据元素之间是一对一线性关系，所有结点都最多只有一个直接前趋结点和一个直接后继结点。常见的有<em>数组、队列、链表、栈</em>。</li><li>非线性结构：数据元素之间具有多个对应关系，一个结点可能有多个直接前趋结点和多个直接后继结点。常见的有<em>多维数组、广义表、树结构和图结构等。</em></li></ul><p>数据的<strong>物理结构（存储结构）</strong>，表示数据元素之间的逻辑关系的存储形式，数据的逻辑结构根据需要可以采用多种存储结构，常用的存储结构有：</p><ol><li>顺序存储：存储顺序是连续的，在内存中用一组地址连续的存储单元依次存储线性表的各个数据元素，其数据间的逻辑关系和物理关系是一致的。</li><li>链式存储：把数据元素存放在任意的存储单元里，这组存储单元不一定是连续的，元素节点存放数据元素和通过指针指向相邻元素的地址信息。</li><li>索引存储：除建立存储结点信息外，还建立附加的索引表来标识节点的地址。索引表由若干索引项组成。</li><li>散列存储：也称Hash存储，由节点的关键码值决定节点的存储地址。</li></ol><p>常用的数据结构有：</p><ul><li>数组（Array）</li><li>链表（Linked List）</li><li>栈（Stack）</li><li>队列（Queue）</li><li>串（String）</li><li>树（Tree）</li><li>集合和字典（Set &amp; Map）</li><li>图（Graph）</li></ul><h1 id="数组（Array）"><a href="#数组（Array）" class="headerlink" title="数组（Array）"></a>数组（Array）</h1><p>数组是最基本最常用的数据结构，是一种线性表顺序存储结构，用一段地址连续的内存空间来存储相同类型的数据元素，可通过数组名和下标进行数据的访问和更新。</p><p>优点：</p><ul><li>无须为表示数组元素之间的逻辑关系而增加额外的存储空间</li><li>可以快速地存取表中任一位置的元素</li></ul><p>缺点：</p><ul><li>插入和删除操作需要移动大量元素</li><li>当数组长度变化较大时，难以确定存储空间的容量</li><li>造成存储空间的“碎片”</li></ul><h1 id="链表（Linked-List）"><a href="#链表（Linked-List）" class="headerlink" title="链表（Linked List）"></a>链表（Linked List）</h1><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p>用一组任意的存储单元存储线性表的数据元素，是一种物理存储单元上非连续的存储结构。</p><p>在链式结构中，除了存储数据元素信息（<strong>数据域</strong>），还要存储它的后继元素的地址（<strong>指针域</strong>），这两部分信息组成<strong>结点</strong>。链表的每个结点只包含一个指针域称为单链表，对指针域进行反向链接，还可以形成双向链表或者循环链表。</p><p><img src="Node.png"></p><p>为了更加方便地对链表进行操作，会在单链表的第一个结点前附设一结点，称为<strong>头结点</strong>。头结点的数据域可以不储存任何信息，也可以储存链表的长度等公共数据。若链表为空表，则头结点的指针域为空（NULL）。</p><p><img src="LinkedList.png" alt="带头结点的单链表"></p><p>链表和数组在实际的使用过程中需要根据自身的优劣势进行选择，区别对比如下：</p><table><thead><tr><th align="center"></th><th align="center">数组</th><th align="center">链表</th></tr></thead><tbody><tr><td align="center">内存地址</td><td align="center">连续的内存空间</td><td align="center">任意的内存空间</td></tr><tr><td align="center">访问方式</td><td align="center">随机访问</td><td align="center">顺序访问</td></tr><tr><td align="center">线性表长度</td><td align="center">长度固定，一般不可动态扩展</td><td align="center">长度可动态变化</td></tr><tr><td align="center">增删效率</td><td align="center">低，需要移动被修改元素后的所有元素</td><td align="center">高，只需修改指针指向</td></tr><tr><td align="center">查询效率</td><td align="center">高，可通过数组名和下标直接访问O(1)</td><td align="center">低，只能通过遍历节点一次查询O(n)</td></tr></tbody></table><p>单链表及常用操作C++实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构建结点类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> data;</span><br><span class="line">        Node *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构建单链表类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkList</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">LinkList</span>();  <span class="comment">//</span></span><br><span class="line">        ~<span class="built_in">LinkList</span>();  <span class="comment">//</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">CreateLinkList</span><span class="params">(<span class="keyword">int</span> n)</span></span>; </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">TravalLinkList</span><span class="params">()</span></span>;        <span class="comment">//遍历线性表</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">GetLength</span><span class="params">()</span></span>;              <span class="comment">//获取线性表长度</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>;               <span class="comment">//判断单链表是否为空</span></span><br><span class="line">        <span class="function">Node *<span class="title">Find</span><span class="params">(<span class="keyword">int</span> data)</span></span>; <span class="comment">//查找节点</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">InsertElemAtEnd</span><span class="params">(<span class="keyword">int</span> data)</span></span>;            <span class="comment">//在尾部插入指定的元素</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">InsertElemAtIndex</span><span class="params">(<span class="keyword">int</span> data,<span class="keyword">int</span> n)</span></span>;    <span class="comment">//在指定位置插入指定元素</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">InsertElemAtHead</span><span class="params">(<span class="keyword">int</span> data)</span></span>;           <span class="comment">//在头部插入指定元素</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">DeleteElemAtEnd</span><span class="params">()</span></span>;       <span class="comment">//在尾部删除元素</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">DeleteAll</span><span class="params">()</span></span>;             <span class="comment">//删除所有数据</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">DeleteElemAtPoint</span><span class="params">(<span class="keyword">int</span> data)</span></span>;     <span class="comment">//删除指定的数据</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">DeleteElemAtHead</span><span class="params">()</span></span>;      <span class="comment">//在头部删除节点</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Node *head;              <span class="comment">//头结点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化单链表</span></span><br><span class="line">LinkList::<span class="built_in">LinkList</span>()&#123;</span><br><span class="line">    head = <span class="keyword">new</span> Node;</span><br><span class="line">    head-&gt;data = <span class="number">0</span>;</span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁单链表</span></span><br><span class="line">LinkList::~<span class="built_in">LinkList</span>()&#123;</span><br><span class="line">    Node *ptem = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(head-&gt;next)&#123;</span><br><span class="line">        ptem = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> ptem;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> head;</span><br><span class="line">    head = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建单链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkList::CreateLinkList</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;n error&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Node *pnew,*ptem;  <span class="comment">//声明新结点和临时结点</span></span><br><span class="line">        ptem = head;  <span class="comment">//临时结点指向头结点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            pnew = <span class="keyword">new</span> Node;  <span class="comment">//新结点分配内存</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;input &quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot; value &quot;</span> ;</span><br><span class="line">            cin&gt;&gt;pnew-&gt;data;</span><br><span class="line">            pnew-&gt;next = <span class="literal">nullptr</span>;  <span class="comment">//新结点指向地址为空</span></span><br><span class="line">            ptem-&gt;next = pnew;  <span class="comment">//临时结点指向新结点（链接）</span></span><br><span class="line">            ptem = pnew;  <span class="comment">//新结点设为临时结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历单链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkList::TravalLinkList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next==<span class="literal">nullptr</span>)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Empty LinkList&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Node *p = head;  <span class="comment">//p指向头结点</span></span><br><span class="line">        <span class="keyword">while</span> (p-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            p = p-&gt;next;  <span class="comment">//p指向下一个地址</span></span><br><span class="line">            cout&lt;&lt;p-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取单链表的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinkList::GetLength</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node *p = head;  <span class="comment">// p指向头结点</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断单链表是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LinkList::IsEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next)  <span class="comment">// 判断第一个结点为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找结点</span></span><br><span class="line"><span class="function">Node *<span class="title">LinkList::Find</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    Node *p = head;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data==data)</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        p = p-&gt;next;  <span class="comment">//p指向p的下一个地址</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在尾部插入指定的元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkList::InsertElemAtEnd</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    Node *p = head;  <span class="comment">//p指向头结点</span></span><br><span class="line">    Node *pnew = <span class="keyword">new</span> Node;  <span class="comment">//声明待插入结点</span></span><br><span class="line">    pnew-&gt;data = data;</span><br><span class="line">    pnew-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next)&#123; <span class="comment">//找到尾部结点</span></span><br><span class="line">        p = p-&gt;next; </span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next = pnew;  <span class="comment">// 尾部结点指向新结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在指定位置插入指定元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkList::InsertElemAtIndex</span><span class="params">(<span class="keyword">int</span> data,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">1</span> || n&gt;<span class="built_in">GetLength</span>())  <span class="comment">//位置小于或大于链表长</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;n error&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Node *p = head;</span><br><span class="line">        Node *pnew = <span class="keyword">new</span> Node;</span><br><span class="line">        pnew-&gt;data = data;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;n)&#123;  <span class="comment">//找到待插入位置上一个结点</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        pnew-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next = pnew;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在头部插入指定元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkList::InsertElemAtHead</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    Node *pnew = <span class="keyword">new</span> Node;</span><br><span class="line">    pnew-&gt;data = data;</span><br><span class="line">    pnew-&gt;next = head-&gt;next;</span><br><span class="line">    head-&gt;next = pnew;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在尾部删除元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkList::DeleteElemAtEnd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node *p = head;</span><br><span class="line">    Node *ptem = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next)&#123;</span><br><span class="line">        ptem = p;  <span class="comment">// ptem倒数第二个结点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    p = <span class="literal">nullptr</span>;</span><br><span class="line">    ptem-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除所有数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkList::DeleteAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node *p = head-&gt;next;</span><br><span class="line">    Node *ptem = <span class="keyword">new</span> Node;</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        ptem = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        head-&gt;next = p;</span><br><span class="line">        <span class="keyword">delete</span> ptem;</span><br><span class="line">        <span class="comment">//ptem= nullptr;</span></span><br><span class="line">    &#125;</span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除指定的数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkList::DeleteElemAtPoint</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    Node *ptem = <span class="keyword">new</span> Node;</span><br><span class="line">    Node *p = head;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;data!=data)&#123;</span><br><span class="line">        ptem = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ptem-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    p = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在头部删除节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkList::DeleteElemAtHead</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node *p = head-&gt;next;</span><br><span class="line">    head-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    p = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表（circuar linkedlist)。循环链表解决了一个很麻烦的问题即如何从当中一个结点出发，访问到链表的全部结点。</p><p><img src="CircuarLinkedList.png" alt="循环链表"></p><p>为了方便查找开始结点和终端结点，不再使用头指针，而是用指向终端结点的<strong>尾指针</strong>来表示循环链表。</p><p><strong>约瑟夫环问题</strong>：已知n个人（以编号0,1,2,3,…,n）分别表示）围坐在一张圆桌周围。从编号0的人开始报数，数到m的那个人出列；他的下一个人又从1开始报数，数到m的那个人又出列：依此规律重复下去，知道圆桌周围的人全都出列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环链表结点类</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环链表类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleList</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node *head;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CircleList</span>();</span><br><span class="line">    ~<span class="built_in">CircleList</span>();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CreateCircleList</span><span class="params">(<span class="keyword">int</span> n)</span></span>;  <span class="comment">// 创建循环链表</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InsertCircleList</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> data)</span></span>;  <span class="comment">// 第pos个元素后插入data</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DeleteCircleList</span><span class="params">()</span></span>;  <span class="comment">// 删除循环链表</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DeleteNode</span><span class="params">(<span class="keyword">int</span> pos)</span></span>;  <span class="comment">// 删除第pos个结点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TravalCircleList</span><span class="params">()</span></span>;  <span class="comment">// 遍历链表</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetLength</span><span class="params">()</span></span>;  <span class="comment">// 获取链表长度 </span></span><br><span class="line">    <span class="function">Node *<span class="title">GetHead</span><span class="params">()</span></span>;  <span class="comment">//获取头结点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CircleList::<span class="built_in">CircleList</span>()&#123;</span><br><span class="line">    head = <span class="keyword">new</span> Node;</span><br><span class="line">    head-&gt;data = <span class="number">0</span>;</span><br><span class="line">    head-&gt;next = head; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CircleList::~<span class="built_in">CircleList</span>()&#123;</span><br><span class="line">    Node *ptem = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (ptem!=head)&#123;</span><br><span class="line">        head-&gt;next = ptem-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> ptem;</span><br><span class="line">        ptem = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> head;</span><br><span class="line">    head = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CircleList::CreateCircleList</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;n error&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Node *pnew, *ptem = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            pnew = <span class="keyword">new</span> Node;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;input &quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot; value &quot;</span> ;</span><br><span class="line">            cin&gt;&gt;pnew-&gt;data;</span><br><span class="line">            pnew-&gt;next= head;</span><br><span class="line">            ptem-&gt;next = pnew;</span><br><span class="line">            ptem = pnew;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CircleList::GetLength</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    Node *p = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p!=head)&#123;</span><br><span class="line">        len++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CircleList::InsertCircleList</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos&gt;<span class="built_in">GetLength</span>()||pos&lt;<span class="number">1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;pos error&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Node *pnew = <span class="keyword">new</span> Node;</span><br><span class="line">        Node *p = head;</span><br><span class="line">        <span class="keyword">while</span> ((pos--)&gt;<span class="number">1</span>)&#123;  <span class="comment">// 找到待插入结点的上个结点</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pnew-&gt;data = data;</span><br><span class="line">        pnew-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next = pnew;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CircleList::DeleteNode</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    Node *p = head,*pd;</span><br><span class="line">    <span class="keyword">if</span>(pos==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next!=head)&#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head-&gt;next;  <span class="comment">// 新头结点</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (pos&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(pos--&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    pd = p-&gt;next;</span><br><span class="line">    p-&gt;next = pd-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> pd;</span><br><span class="line">    pd = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CircleList::DeleteCircleList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node *ptem = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (ptem!=head)</span><br><span class="line">    &#123;</span><br><span class="line">        head-&gt;next = ptem-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> ptem;</span><br><span class="line">        ptem = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CircleList::TravalCircleList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node *ptem = head-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(ptem==head)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;empty&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(ptem!=head)&#123;</span><br><span class="line">            cout&lt;&lt;ptem-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            ptem = ptem-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">CircleList::GetHead</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n;  <span class="comment">// n 个旅客，m 报数值</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;n m&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    CircleList clist;</span><br><span class="line">    clist.<span class="built_in">CreateCircleList</span>(n<span class="number">-1</span>);  <span class="comment">// 用上头结点</span></span><br><span class="line">    Node *p = clist.<span class="built_in">GetHead</span>(),*pre;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;m;j++)&#123;</span><br><span class="line">            pre = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;delete: &quot;</span>&lt;&lt;p-&gt;data&lt;&lt;endl;</span><br><span class="line">        pre-&gt;next = p-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">        p = pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用数学方式解决属实没看懂，<a href="https://blog.csdn.net/u011500062/article/details/72855826">参考</a>：在 n 个数中最后留下来的数 = 在 n 中去除第 m 个数后剩下 n-1 个数中留下来的数。在0-n-1个数：0，1，2，m-2，m-1，m，…，n-1，去除一个m-1后，剩下为：0，1，2，m-2，m，…，n-1，在这 n-1 个数中，每次计数需要从 m 开始，推导公式 <strong>f(n,m)=(f(n−1,m)+m)%n</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;<span class="comment">// 约瑟夫环</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 判断边界</span></span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;   <span class="comment">// 最后留下的数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            s = (s + m) % i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>双向链表（double linkedlist）是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。</p><p>在插入和删除时，需要修改两个指针变量。假设存储元素 e 的结点为 s，要实现将结点 s 插入到结点 p 和 p-&gt;next 之间需要下面几步。<strong>先搞定 s 的前驱和后继，再搞定后结点的前驱，最后解决前结点的后继。</strong></p><p><img src="DoubleLinkedlistInsertion.png" alt="双向链表的插入"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s-&gt;prior = p;  <span class="comment">//(1) </span></span><br><span class="line">s-&gt;next = p-&gt;next;  <span class="comment">//(2)</span></span><br><span class="line">p-&gt;next-&gt;prior = s;  <span class="comment">//(3)</span></span><br><span class="line">p-&gt;next = s;  <span class="comment">//(4)</span></span><br></pre></td></tr></table></figure><p>若要删除结点 p，只需要下面两个步骤</p><p><img src="DoubleLinkedlistDeletion.png" alt="双向链表的删除"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;prior-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next-&gt;prior = p-&gt;prior;</span><br><span class="line"><span class="built_in"><span class="keyword">delete</span></span>(p);</span><br></pre></td></tr></table></figure><h1 id="栈（Stack）"><a href="#栈（Stack）" class="headerlink" title="栈（Stack）"></a>栈（Stack）</h1><p><strong>栈（Stack）</strong>是限定仅在表尾进行插入和删除操作的线性表。</p><p>允许插入和删除的一端称为<strong>栈顶(top)<strong>，另一端称为</strong>栈底(bottom)<strong>，不含任何数据元素的栈称为</strong>空栈</strong>。栈又称为**后进先出(LIFO)**的线性表，简称 LIFO 结构。</p><p>栈是线性表的特例，也有两种典型的存储方式：基于数组的顺序存储（<strong>顺序栈</strong>）和基于链表的链式存储（<strong>链式栈</strong>）</p><h2 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h2><p>用数组下标为 0 的一端作为栈底，数组最大允许存放元素个数为 maxSize，定义一个 top 变量来指示栈顶元素在数组中的位置，top = -1 时，置栈为空。</p><p><img src="SeqStack.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SeqStack</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> *data;  <span class="comment">// 数组指针</span></span><br><span class="line">    <span class="keyword">int</span> top;  <span class="comment">// 栈顶下标</span></span><br><span class="line">    <span class="keyword">int</span> maxSize;  <span class="comment">// 栈容量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SeqStack</span>(<span class="keyword">int</span> ms=<span class="number">10</span>);</span><br><span class="line">    ~<span class="built_in">SeqStack</span>();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetTop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsEmoty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MakeEmpty</span><span class="params">()</span></span>&#123;top = <span class="number">-1</span>;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetSize</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> top+<span class="number">1</span>;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SeqStack::<span class="built_in">SeqStack</span>(<span class="keyword">int</span> ms)&#123;</span><br><span class="line">    maxSize = ms;</span><br><span class="line">    data = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">    top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SeqStack::~<span class="built_in">SeqStack</span>()&#123;</span><br><span class="line">    <span class="keyword">delete</span> []data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeqStack::Push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(top == maxSize<span class="number">-1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;stack overflow!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        data[++top] = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeqStack::Pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(top == <span class="number">-1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;stack empty!&quot;</span>&lt;&lt;endl; </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        top--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SeqStack::GetTop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(top == <span class="number">-1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;stack empty!&quot;</span>&lt;&lt;endl; </span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data[top];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SeqStack::IsEmoty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (top == <span class="number">-1</span>)? <span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有两个相同类型的栈，我们为它们各自开辟了数组空间，极有可能是第一个栈已经满了，再进栈就溢出了，而另一个栈还有很多存储空间空闲。我们完全可以用一个数组来存储两个栈，数组有两个端点，两个栈有两个栈底，让一个栈的栈底为数组的始端，即下标为 0 处，另一个栈为栈的末端，即下标为数组长度 maxSize-1 处。这样两个栈如果增加元素，就是两端点向中间延伸。</p><p><img src="SeqDoubleStack.png"></p><p>当然，这只是针对两个具有相同数据类型的栈的一个设计上的技巧，如果不是相同数据类型的栈，或者是多个栈共享栈空间，这种办法不但不能更好地处理问题，反而会使问题变得更复杂。</p><h2 id="链式栈"><a href="#链式栈" class="headerlink" title="链式栈"></a>链式栈</h2><p>栈的链式存储结构，简称为链式栈。链式栈的栈顶在链表的表头，栈的插入和删除操作都在表头（不需要头结点）。</p><p><img src="LinkStack.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkStack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node *top;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LinkStack</span>()&#123;top = <span class="literal">nullptr</span>;&#125;;</span><br><span class="line">    ~<span class="built_in">LinkStack</span>();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetTop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetSize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MakeEmpty</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LinkStack::~<span class="built_in">LinkStack</span>()&#123;</span><br><span class="line">    Node *p;</span><br><span class="line">    <span class="keyword">while</span> (top != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        p = top;</span><br><span class="line">        top = top-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkStack::Push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    Node *pnew = <span class="keyword">new</span> Node;</span><br><span class="line">    pnew-&gt;data = x;</span><br><span class="line">    pnew-&gt;next = top;</span><br><span class="line">    top = pnew;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkStack::Pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(top != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        Node *pd = top;</span><br><span class="line">        top = top-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> pd;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;stack empty&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinkStack::GetTop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(top != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> top-&gt;data;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;stack empty&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinkStack::GetSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node *p = top;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkStack::MakeEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node *p;</span><br><span class="line">    <span class="keyword">while</span> (top != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        p = top;</span><br><span class="line">        top = top-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h2><p>现在许多高级语言，都对栈结构进行了封装，可以不用关注它的实现细节，可以直接使用 stack 的 push 和 pop 等方法。</p><p>把一个直接或间接调用自己的函数，称为<strong>递归函数</strong>。每个递归定义必须至少有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出。</p><p>利用<strong>后缀表达</strong>法书写表达式不需要括号，也称为逆波兰表示(RPN)。后缀表达式的计算：<strong>从左到右遍历表达式的每个数字和操作符，遇到是数字就进栈，遇到是操作符 op，就将栈顶连续两个数字 X(先) 和 Y(后) 出栈，进行运算 Y op  X，计算结果进栈，直到表达式所有项都遍历处理完，栈顶存放的就是表达式最终的结果。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string exp;  <span class="comment">// 后缀表达式</span></span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; st;  <span class="comment">// int 类型栈</span></span><br><span class="line">    cin&gt;&gt;exp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;exp.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(exp[i]&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; exp[i]&lt;=<span class="string">&#x27;9&#x27;</span>)  <span class="comment">// 如果是数字</span></span><br><span class="line">            st.<span class="built_in">push</span>(exp[i]-<span class="string">&#x27;0&#x27;</span>);  <span class="comment">// 字符转数字并进栈</span></span><br><span class="line">        <span class="keyword">else</span>&#123;  <span class="comment">// 操作符</span></span><br><span class="line">            <span class="keyword">int</span> x = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">int</span> y = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in"><span class="keyword">switch</span></span> (exp[i])&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: st.<span class="built_in">push</span>(y+x);<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: st.<span class="built_in">push</span>(y-x);<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: st.<span class="built_in">push</span>(y*x);<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: st.<span class="built_in">push</span>(y/x);<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;st.<span class="built_in">top</span>()&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;st.top()&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码看着正确，运行也正确，可是有个很大的缺陷，只能计算 10 以内的加减乘除表达式。</p><p>编译程序利用后缀表达法仅用一个栈就可以很快算出表达式的值，而我们平时用的都是标准的四则运算表达式(中缀表达式)，如何<strong>将中缀表达转换为后缀表达</strong>？</p><ol><li>手工方式</li></ol><ul><li><p>按先乘除后加减的原则给表达式加括号</p></li><li><p>由内到外把每个括号里的表达式换成后缀</p><p>eg：a+b*c+(d*e+f)*g = ((a+(b*c))+(((d*e)+f)*g)) = ((a+bc*)+(de*+f)*g) = ((abc*+)+(de*f+g*)) = abc*+de*f+g*+</p></li></ul><ol><li><p>栈的方式</p><p>规则：从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级不高于栈顶符号(乘除优先加减），则栈顶元素依次出栈并输出操作符元素，并将当前符号进栈，一直到最终输出后缀表达式为止。</p></li></ol><h1 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h1><p>队列是只允许在表的一端插入，另一端删除的线性表。是一种先进先出(FIFO)结构的线性表，运行插入的一端为队尾，允许删除的一端为队头。</p><p><img src="Queue.png"></p><h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><p>循环队列是基于数组的存储方式，把数组的前端和后端连接起来，形成一个环形的表，用 front 和 rear 分别指示队列的队头和队尾元素下一位置，初始化时都置为 0，maxSize 是数组的最大长度。在队尾插入新元素和队头删除元素时，队尾和队头指针分别按顺时针方向进 1，两指针进到 maxSize -1 后，再进一个位置就自动到 0。</p><ul><li>队头指针进 1：front = (front+1)%maxSize</li><li>队尾指针进 1：rear = (rear+1)%maxSize</li></ul><p>如果循环列表读取元素速度快于存储速度，队头很快追上队尾，当 front == rear 时，队列就变成空队列；如果列表存储元素速度快于读取速度，队尾很快追上队头，当 (rear+1)%maxSize  == front 时，队列已满。在循环列表中，最多存放 maxSize-1 个元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SeqQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> rear,front;</span><br><span class="line">    <span class="keyword">int</span> *data;</span><br><span class="line">    <span class="keyword">int</span> maxSize;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SeqQueue</span>(<span class="keyword">int</span> ms = <span class="number">10</span>);</span><br><span class="line">    ~<span class="built_in">SeqQueue</span>();</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsFull</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> ((rear+<span class="number">1</span>)%maxSize==front)?<span class="literal">true</span>:<span class="literal">false</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DeQueue</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetFront</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetSize</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> (rear-front+maxSize)%maxSize;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SeqQueue::<span class="built_in">SeqQueue</span>(<span class="keyword">int</span> ms)&#123;</span><br><span class="line">    maxSize = ms;</span><br><span class="line">    rear = front = <span class="number">0</span>;</span><br><span class="line">    data = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SeqQueue::~<span class="built_in">SeqQueue</span>()&#123;</span><br><span class="line">    <span class="keyword">delete</span> []data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeqQueue::EnQueue</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">IsFull</span>()==<span class="literal">true</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Queue is full&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        data[rear] = x;</span><br><span class="line">        rear = (rear+<span class="number">1</span>)%maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeqQueue::DeQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rear == front)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Queue is empty&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        front = (front+<span class="number">1</span>)%maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SeqQueue::GetFront</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rear == front)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Queue is empty&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data[front];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h2><p>链式队列是基于单链表的存储方式，队列的队头指针指向单链表的第一个结点，队尾指针指向单链表的最后一个结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkQueue</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node *front,*rear;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LinkQueue</span>();</span><br><span class="line">    ~<span class="built_in">LinkQueue</span>();</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Isempty</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> (front==<span class="literal">nullptr</span>)? <span class="literal">true</span>:<span class="literal">false</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DeQueue</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetFront</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetSize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MakeEmpty</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LinkQueue::<span class="built_in">LinkQueue</span>(<span class="comment">/* args */</span>)&#123;</span><br><span class="line">    front = rear = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LinkQueue::~<span class="built_in">LinkQueue</span>()&#123;</span><br><span class="line">    <span class="built_in">MakeEmpty</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkQueue::EnQueue</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(front == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        front = rear = <span class="keyword">new</span> Node;</span><br><span class="line">        rear-&gt;data = x;</span><br><span class="line">        rear-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Node *pn = <span class="keyword">new</span> Node;</span><br><span class="line">        pn-&gt;data = x;</span><br><span class="line">        pn-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        rear-&gt;next = pn;</span><br><span class="line">        rear = pn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkQueue::DeQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Isempty</span>())&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Queue is empty&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Node *p = front;</span><br><span class="line">        front = front-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinkQueue::GetFront</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Isempty</span>())&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Queue is empty&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> front-&gt;data;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinkQueue::GetSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node *p = front;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkQueue::MakeEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node *pd;</span><br><span class="line">    <span class="keyword">while</span> (front!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        pd = front;</span><br><span class="line">        front = front-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> pd;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="队列应用"><a href="#队列应用" class="headerlink" title="队列应用"></a>队列应用</h2><p>二项展开式 (a+b)^i 的系数，其系数构成杨辉三角。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="comment">// 打印的行数</span></span><br><span class="line">    <span class="keyword">int</span> i,j,t,s=<span class="number">0</span>;  <span class="comment">// 第i行j列的数值为t </span></span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);  <span class="comment">// 预先放入i=1的系数</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="number">0</span>);  <span class="comment">// 每行尾部加入0</span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=(i+<span class="number">2</span>);j++)&#123;</span><br><span class="line">            t = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            q.<span class="built_in">push</span>(s+t);  <span class="comment">// 下一行的数值进队列</span></span><br><span class="line">            s = t;</span><br><span class="line">            <span class="keyword">if</span>(s) cout&lt;&lt;s&lt;&lt;<span class="string">&quot; &quot;</span>;  <span class="comment">// 0不输出</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="串（String）"><a href="#串（String）" class="headerlink" title="串（String）"></a>串（String）</h1><p>见 <a href="https://gzwangu.github.io/2021/10/21/C-%E4%B8%ADstring%E7%9A%84%E7%94%A8%E6%B3%95/">https://gzwangu.github.io/2021/10/21/C-%E4%B8%ADstring%E7%9A%84%E7%94%A8%E6%B3%95/</a></p><h1 id="树（Tree）"><a href="#树（Tree）" class="headerlink" title="树（Tree）"></a>树（Tree）</h1><p>树是由 n(n&gt;=0)个有限结点组成一个具有层次关系的集合。n=0 时为空树，非空树具有以下的特点：</p><ul><li>每个结点有零个或多个子结点；</li><li>没有父结点的节点称为根(Root)结点，根结点是唯一的；</li><li>每一个非根结点有且只有一个父结点；</li><li>除了根结点外，每个子结点可以分为多个不相交的子树；</li></ul><p><img src="Tree.png"></p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p>树的结点包含一个数据元素及若干指向其子树的分支。结点拥有的子树数称为<strong>结点的度</strong>(Degree)。度为 0 的结点称为叶结点(Leaf)或终端结点；度不为 0 的结点称为非终端结点或分支结点。除根结点之外，分支结点也称为内部结点。树的度是树内各结点的度的最大值。如图所示，因为这棵树结点的度的最大值是结点 D 的度为 3，所以树的度也为 3。</p><p><img src="DegreeOfTree.png"></p><p>结点的子树的根称为该结点的孩子(Child)，相应地，该结点称为孩子的双亲(Parent)。同一个双亲的孩子之间互称兄弟(Sibling)。</p><p>结点的层次从根开始定义起，根为第一层，根的孩子为第二层。若某结点在第 i 层，则其子树的根就在第 i+1 层，其双亲在同一层的结点互为堂兄弟。树中结点的最大层次称为<strong>树的深度(Depth)或高度</strong>，当前树的深度为4。</p><p><img src="DepthOfTree.png"></p><p>森林(Forest)是 m(m&gt;=0)棵互不相交的树的集合。</p><p>在日常的应用中，我们讨论和用的更多的是树的其中一种结构，就是<strong>二叉树</strong>。</p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树(Binary Tree)是 n(n&gt;=0)个结点的有限集合，该集合或者为空集(称为空二叉树)，或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。二叉树的特点有：</p><ul><li>每个结点最多有两棵子树，不存在度大于 2 的结点</li><li>左子树和右子树是有顺序的，次序不能任意颠倒</li><li>即使树中某结点只有一棵子树，也要区分它是左子树还是右子树</li></ul><p><img src="BinaryTree.png"></p><p><strong>满二叉树</strong>：在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。</p><p><strong>完全二叉树</strong>：对一棵具有 n 个结点的二叉树按层序编号，如果编号为i(1&lt;i&lt;n)的结点与同样深度的满二叉树中编号为 i 的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。</p><p><strong>二叉树的性质</strong></p><ol><li>在二叉树的第 i 层上至多有2^(i-1)个结点(i≥1)</li><li>深度为 k 的二叉树至多有2^(k-1)个结点(k&gt;1)</li><li>对任何一棵二叉树 T，如果其叶子结点数为 n0，度为 2 的结点数为 n2，则 n0 = n2 + 1。</li><li>具有 n 个结点的完全二叉树的深度为[(log2)n]+1（[x]表示不大于 x 的最大整数）</li></ol><h2 id="二叉链表"><a href="#二叉链表" class="headerlink" title="二叉链表"></a>二叉链表</h2><p>二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域是比较合适的，我们称这样的链表叫做二叉链表。</p><p>lchild | data |  rchid ，其中 data 是数据域，lchild 和 rchid 都是指针域，分别存放指向左孩子和右孩子的指针。</p><p>二叉树有深度遍历和层次遍历，深度遍历有前序、中序以及后序三种遍历方法。</p><ul><li>前序遍历：根结点 —&gt; 左子树 —&gt; 右子树</li><li>中序遍历：左子树 —&gt; 根结点 —&gt; 右子树</li><li>后序遍历：左子树 —&gt; 右子树 —&gt; 根结点</li><li>层次遍历：从上而下逐层，同一层中从左到右遍历</li></ul><p><img src="PreMidPostOrder.png"></p><p>前序遍历：ABDGHCEIF；中序遍历：GDHBAEICF；后序遍历：GHDBIEFCA；层次遍历：ABCDEFGHI</p><ul><li>已知先序和后序，不能唯一确定二叉树</li><li>已知先序或后序，而又知中序，则能唯一确定二叉树</li><li>先序、中序相同时，二叉树没有左子树</li><li>后序、中序相同时，二叉树没有右子树</li><li>后序、先序相同时，只有一个根节点</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树结点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BtNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    BtNode *left;</span><br><span class="line">    BtNode *right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        BtNode *root;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">BinaryTree</span>()&#123;root = <span class="literal">nullptr</span>;&#125;  <span class="comment">//构造函数</span></span><br><span class="line">        ~<span class="built_in">BinaryTree</span>();                <span class="comment">//析构函数</span></span><br><span class="line">        <span class="function">BtNode* <span class="title">getRoot</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> root;&#125;  <span class="comment">//获取根结点</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> data)</span></span>;      <span class="comment">//插入结点</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(BtNode *root)</span></span>;  <span class="comment">//中序遍历</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(BtNode *root)</span></span>;  <span class="comment">//先序遍历</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(BtNode *root)</span></span>;  <span class="comment">//后序遍历</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">levelorder</span><span class="params">(BtNode *root)</span></span>;  <span class="comment">//层次遍历</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">preorder_nonrecursive</span><span class="params">(BtNode *root)</span></span>; <span class="comment">//非递归先序遍历</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">postorder_nonrecursive</span><span class="params">(BtNode *root)</span></span>; <span class="comment">//非递归后序遍历</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">inorder_nonrecursive</span><span class="params">(BtNode *root)</span></span>; <span class="comment">//非递归中序遍历</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(<span class="keyword">int</span> data)</span></span>;  <span class="comment">//删除结点</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">deleteTree</span><span class="params">(BtNode *root)</span></span>;  <span class="comment">//删除二叉树</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(BtNode *root)</span></span>;  <span class="comment">//获取二叉树高度</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">countLeaf</span><span class="params">(BtNode *root)</span></span>;  <span class="comment">//获取叶子结点个数</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">countNode</span><span class="params">(BtNode *root)</span></span>;  <span class="comment">//获取结点个数</span></span><br><span class="line">        <span class="function">BtNode* <span class="title">search</span><span class="params">(BtNode *root, <span class="keyword">int</span> data)</span></span>;  <span class="comment">//查找结点</span></span><br><span class="line">        <span class="function">BtNode* <span class="title">minValue</span><span class="params">(BtNode *root)</span></span>;  <span class="comment">//获取最小值</span></span><br><span class="line">        <span class="function">BtNode* <span class="title">maxValue</span><span class="params">(BtNode *root)</span></span>;   <span class="comment">//获取最大值</span></span><br><span class="line">        <span class="function">BtNode* <span class="title">successor</span><span class="params">(BtNode *root, <span class="keyword">int</span> data)</span></span>;  <span class="comment">//获取后继结点</span></span><br><span class="line">        <span class="function">BtNode* <span class="title">predecessor</span><span class="params">(BtNode *root, <span class="keyword">int</span> data)</span></span>;  <span class="comment">//获取前驱结点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BinaryTree::~<span class="built_in">BinaryTree</span>()&#123;</span><br><span class="line">    <span class="built_in">deleteTree</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BinaryTree::insert</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    BtNode *newNode = <span class="keyword">new</span> <span class="built_in">BtNode</span>();</span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">    newNode-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        root = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        BtNode *temp = root;</span><br><span class="line">        <span class="keyword">while</span>(temp != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(data &lt; temp-&gt;data)&#123;</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;left == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    temp-&gt;left = newNode;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    temp = temp-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    temp-&gt;right = newNode;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    temp = temp-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BinaryTree::inorder</span><span class="params">(BtNode *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;left);</span><br><span class="line">        cout&lt;&lt;root-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BinaryTree::preorder</span><span class="params">(BtNode *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        cout&lt;&lt;root-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">preorder</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">preorder</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BinaryTree::postorder</span><span class="params">(BtNode *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="built_in">postorder</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">postorder</span>(root-&gt;right);</span><br><span class="line">        cout&lt;&lt;root-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 层次遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BinaryTree::levelorder</span><span class="params">(BtNode *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    BtNode *temp = root;</span><br><span class="line">    queue&lt;BtNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(temp);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        temp = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        cout&lt;&lt;temp-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(temp-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(temp-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BinaryTree::deleteNode</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    BtNode *temp = root;</span><br><span class="line">    BtNode *parent = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(temp != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp-&gt;data == data)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            parent = temp;</span><br><span class="line">            <span class="keyword">if</span>(data &lt; temp-&gt;data)&#123;</span><br><span class="line">                temp = temp-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                temp = temp-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(temp == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;没有找到要删除的节点&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(temp-&gt;left == <span class="literal">nullptr</span> &amp;&amp; temp-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(parent == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            root = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(parent-&gt;left == temp)&#123;</span><br><span class="line">                parent-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                parent-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(temp-&gt;left == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(parent == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            root = temp-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(parent-&gt;left == temp)&#123;</span><br><span class="line">                parent-&gt;left = temp-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                parent-&gt;right = temp-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(temp-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(parent == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            root = temp-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(parent-&gt;left == temp)&#123;</span><br><span class="line">                parent-&gt;left = temp-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                parent-&gt;right = temp-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        BtNode *successor = <span class="built_in">minValue</span>(temp-&gt;right);</span><br><span class="line">        temp-&gt;data = successor-&gt;data;</span><br><span class="line">        <span class="built_in">deleteNode</span>(successor-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BinaryTree::deleteTree</span><span class="params">(BtNode *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="built_in">deleteTree</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">deleteTree</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">delete</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取二叉树高度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinaryTree::getHeight</span><span class="params">(BtNode *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> leftHeight = <span class="built_in">getHeight</span>(root-&gt;left);</span><br><span class="line">    <span class="keyword">int</span> rightHeight = <span class="built_in">getHeight</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> leftHeight &gt; rightHeight ? leftHeight + <span class="number">1</span> : rightHeight + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取叶子结点个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinaryTree::countLeaf</span><span class="params">(BtNode *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">countLeaf</span>(root-&gt;left) + <span class="built_in">countLeaf</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取结点个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinaryTree::countNode</span><span class="params">(BtNode *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">countNode</span>(root-&gt;left) + <span class="built_in">countNode</span>(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找结点</span></span><br><span class="line"><span class="function">BtNode* <span class="title">BinaryTree::search</span><span class="params">(BtNode *root, <span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;data == data)&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data &lt; root-&gt;data)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">search</span>(root-&gt;left, data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">search</span>(root-&gt;right, data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取最小值</span></span><br><span class="line"><span class="function">BtNode* <span class="title">BinaryTree::minValue</span><span class="params">(BtNode *root)</span></span>&#123;</span><br><span class="line">    BtNode *temp = root;</span><br><span class="line">    <span class="keyword">while</span>(temp-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        temp = temp-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取最大值</span></span><br><span class="line"><span class="function">BtNode* <span class="title">BinaryTree::maxValue</span><span class="params">(BtNode *root)</span></span>&#123;</span><br><span class="line">    BtNode *temp = root;</span><br><span class="line">    <span class="keyword">while</span>(temp-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        temp = temp-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找后继结点</span></span><br><span class="line"><span class="function">BtNode* <span class="title">BinaryTree::successor</span><span class="params">(BtNode *root, <span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    BtNode *temp = <span class="built_in">search</span>(root, data);</span><br><span class="line">    <span class="keyword">if</span>(temp == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(temp-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">minValue</span>(temp-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    BtNode *parent = root;</span><br><span class="line">    <span class="keyword">while</span>(parent != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(parent-&gt;left == temp)&#123;</span><br><span class="line">            <span class="keyword">return</span> parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            parent = parent-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找前驱结点</span></span><br><span class="line"><span class="function">BtNode* <span class="title">BinaryTree::predecessor</span><span class="params">(BtNode *root, <span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    BtNode *temp = <span class="built_in">search</span>(root, data);</span><br><span class="line">    <span class="keyword">if</span>(temp == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(temp-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">maxValue</span>(temp-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    BtNode *parent = root;</span><br><span class="line">    <span class="keyword">while</span>(parent != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(parent-&gt;right == temp)&#123;</span><br><span class="line">            <span class="keyword">return</span> parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            parent = parent-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非递归前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BinaryTree::preorder_nonrecursive</span><span class="params">(BtNode *root)</span></span>&#123;</span><br><span class="line">    stack&lt;BtNode*&gt; s;</span><br><span class="line">    BtNode *p = root;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">nullptr</span> || !s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            cout&lt;&lt;p-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            s.<span class="built_in">push</span>(p);</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        p = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        p = p-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非递归中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BinaryTree::inorder_nonrecursive</span><span class="params">(BtNode *root)</span></span>&#123;</span><br><span class="line">    stack&lt;BtNode*&gt; s;</span><br><span class="line">    BtNode *p = root;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">nullptr</span> || !s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            s.<span class="built_in">push</span>(p);</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        p = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        cout&lt;&lt;p-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        p = p-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非递归后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BinaryTree::postorder_nonrecursive</span><span class="params">(BtNode *root)</span></span>&#123;</span><br><span class="line">    stack&lt;BtNode*&gt; s;</span><br><span class="line">    BtNode *p = root;</span><br><span class="line">    BtNode *pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">nullptr</span> || !s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            s.<span class="built_in">push</span>(p);</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        p = s.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;right == <span class="literal">nullptr</span> || p-&gt;right == pre)&#123;</span><br><span class="line">            cout&lt;&lt;p-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            pre = p;</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            p = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            p = p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    BinaryTree btree;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; btarry = &#123; <span class="number">7</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">15</span>, <span class="number">35</span>, <span class="number">6</span>, <span class="number">45</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> bta: btarry)&#123;</span><br><span class="line">        btree.<span class="built_in">insert</span>(bta);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;前序遍历：&quot;</span>&lt;&lt;endl;</span><br><span class="line">    btree.<span class="built_in">preorder</span>(btree.<span class="built_in">getRoot</span>());</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    btree.<span class="built_in">preorder_nonrecursive</span>(btree.<span class="built_in">getRoot</span>());</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;中序遍历：&quot;</span>&lt;&lt;endl;</span><br><span class="line">    btree.<span class="built_in">inorder</span>(btree.<span class="built_in">getRoot</span>());</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    btree.<span class="built_in">inorder_nonrecursive</span>(btree.<span class="built_in">getRoot</span>());</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;后序遍历：&quot;</span>&lt;&lt;endl;</span><br><span class="line">    btree.<span class="built_in">postorder</span>(btree.<span class="built_in">getRoot</span>());</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    btree.<span class="built_in">postorder_nonrecursive</span>(btree.<span class="built_in">getRoot</span>());</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;层次遍历：&quot;</span>&lt;&lt;endl;</span><br><span class="line">    btree.<span class="built_in">levelorder</span>(btree.<span class="built_in">getRoot</span>());</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    btree.<span class="built_in">levelorder_nonrecursive</span>(btree.<span class="built_in">getRoot</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Huffman树及应用"><a href="#Huffman树及应用" class="headerlink" title="Huffman树及应用"></a>Huffman树及应用</h2><p>从树中一个结点到另一个结点之间的分支构成两个结点之间的<strong>路径</strong>，路径上的分支数目称做<strong>路径长度</strong>。如二叉树a中，根结点到结点D的路径长度就为4，二叉树b中根结点到结点D的路径长度为2。树的路径长度就是从树根到每一结点的路径长度之和。二叉树a的树路径长度就为1+1+2+2+3+3+4+4=20。二叉树b的树路径长度就为1+2+3+3+2+1+2+2=16。</p><p><img src="Huffman.png"></p><p>考虑到带权的结点，结点的带权的路径长度为从该结点到树根之间的路径长度与结点上权的乘积。树的带权路径长度为树中所有叶子结点的带权路径长度之和。其中带权路径长度WPL最小的二叉树称做<strong>哈夫曼树</strong>，也称为最优二叉树。</p><p>哈夫曼算法描述</p><ol><li>根据给定的n个权值{ W1,W2…,Wn }构成n棵二叉树的集合F={T1,T2…,Tn}，其中每棵二叉树Ti中只有一个带权为Wi根结点，其左右子树均为空。</li><li>在F中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左右子树上根结点的权值之和。</li><li>在F中删除这两棵树，同时将新得到的二叉树加入F中。</li><li>重复2和3步骤，直到F只含一棵树为止。这棵树便是赫夫曼树。</li></ol><p><strong>哈夫曼编码</strong></p><p>假设六个字母的频率为A 27, B 8,C 15, D 15,E 30,F5，合起来正好是100%。那就意味着，我们完全可以重新按照赫夫曼树来规划它们。</p><p><img src="HuffmanCode.png"></p><table><thead><tr><th align="center">字母</th><th align="center">A</th><th align="center">B</th><th align="center">C</th><th align="center">D</th><th align="center">E</th><th align="center">F</th></tr></thead><tbody><tr><td align="center">编码</td><td align="center">01</td><td align="center">1001</td><td align="center">101</td><td align="center">00</td><td align="center">11</td><td align="center">1000</td></tr></tbody></table><h1 id="集合和字典（Set-amp-Map）"><a href="#集合和字典（Set-amp-Map）" class="headerlink" title="集合和字典（Set &amp; Map）"></a>集合和字典（Set &amp; Map）</h1><h2 id="集合（Set）"><a href="#集合（Set）" class="headerlink" title="集合（Set）"></a>集合（Set）</h2><p>集合是成员（元素）的一个集群，集合中的成员可以是原子（单元素），也可以是集合，集合的成员必须是互不相同的。可以采用位向量或有序链表实现集合。</p><p>set集合是c++ stl库中自带的一个容器，set具有以下两个特点：</p><ul><li>set中的元素都是排好序的</li><li>set集合中没有重复的元素</li></ul><p>set跟vector差不多，它跟vector的唯一区别就是，set里面的元素是有序的且唯一的，只要你往set里添加元素，它就会自动排序，而且，如果你添加的元素set里面本来就存在，那么这次添加操作就不执行。</p><p>set集合常用操作：</p><ul><li>begin() 　  　 返回set容器的第一个元素的地址</li><li>end() 　　　  返回set容器的最后一个元素地址</li><li>clear() 　　    删除set容器中的所有的元素</li><li>empty() 　      判断set容器是否为空</li><li>max_size() 　 返回set容器可能包含的元素最大个数</li><li>size() 　　　  返回当前set容器中的元素个数</li><li>erase(it)          删除迭代器指针it处元素</li><li>insert(a)          插入某个元素</li></ul><p><strong>当set集合中的元素为结构体时，该结构体必须实现运算符‘&lt;’的重载</strong></p><h2 id="字典（Map）"><a href="#字典（Map）" class="headerlink" title="字典（Map）"></a>字典（Map）</h2><p>讨论字典抽象数据结构类型时，从键（key）到值（value）的映射，把字典定义为&lt;key-value&gt;对的集合。</p><p>字典的组织方式有：</p><ul><li>线性表</li><li>跳表</li><li>散列表</li></ul><p>map是c++ stl库中自带的一个容器，它提供一对一的数据处理能力，是一种二叉树的数据存储结构。map内部自建一颗红黑树(一 种非严格意义上的平衡二叉树)，这颗树具有对数据自动排序的功能，所以在map内部所有的数据都是有序的。map具有以下特点：</p><ul><li>键与值一 一对应</li><li>键唯一，不存在相同的键对应不同的值。</li><li>按Key有序排列</li><li>根据key值快速查找记录，查找的复杂度基本是Log(N)</li></ul><p>map集合常用操作：</p><ul><li>begin 指向起始</li><li>end 指向末尾</li><li>rbegin 指向倒序起始（即末尾）</li><li>rend 指向倒序末尾（即起始）</li><li>empty 判断容器是否为空</li><li>size 返回容器大小</li><li>max_size 返回容器最大尺寸</li><li>元素访问 operater[ ] 和 at</li><li>insert 插入元素</li><li>erase 删除元素</li><li>swap 交换两个map容器内容</li><li>clear 清除容器</li><li>emplace 构造并插入元素</li><li>find 获得指向元素的迭代器</li><li>count 对某个键的元素计数</li><li>lower_bound 返回下边界的迭代器</li><li>upper_bound 返回上边界的迭代器</li><li>equal_range 获得相同元素的范围</li></ul><h1 id="图（Graph）"><a href="#图（Graph）" class="headerlink" title="图（Graph）"></a>图（Graph）</h1>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>轻量级网络—MobileNetV1</title>
      <link href="2021/03/31/%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%BD%91%E7%BB%9C%E2%80%94MobileNetV1/"/>
      <url>2021/03/31/%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%BD%91%E7%BB%9C%E2%80%94MobileNetV1/</url>
      
        <content type="html"><![CDATA[<h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>MobileNet 是用于移动和嵌入式视觉应用的高效模型。基于一种流线型（streamlined）的架构，该架构使用深度可分离卷积（depthwise separable convolutions）来构建轻量级深度神经网络。同时引入两个简单的全局超参数，在延迟和准确率之间进行了有效的权衡。这些超参数允许模型构建者根据问题的约束为其应用程序选择适当大小的模型。论文在资源和精度权衡方面进行了大量的实验，并与其他流行的 ImageNet 分类模型对比显示了的强大性能。然后，论文在广泛的应用和用例中论证了移动网络的有效性，包括目标检测、细粒度分类、人脸属性和大规模地理定位。</p><p><img src="Figure1.png"></p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>深度卷积神经网络在计算机视觉中变得无处不在，为了获得更高的精度而使网络更加深更复杂。然而，这些提高准确性的进步并不一定使网络在规模和速度方面更有效。在许多现实世界的应用中，如机器人、自动驾驶汽车和增强现实，识别任务需要在一个计算有限的平台上及时执行。</p><p>本文描述了使用一种高效的网络架构和一组两个超参数（宽度和分辨率）来构建非常小、低延迟的模型，这模型可以轻松满足移动和嵌入式视觉应用的设计要求。</p><h1 id="Prior-Work"><a href="#Prior-Work" class="headerlink" title="Prior Work"></a>Prior Work</h1><p>在最近的文献中，构建小而高效的神经网络方法通常有两种：<strong>压缩预训练网络</strong>和<strong>直接训练小型网络</strong>。</p><h1 id="MobileNet-Architecture"><a href="#MobileNet-Architecture" class="headerlink" title="MobileNet Architecture"></a>MobileNet Architecture</h1><p>在本节中，首先描述构建 MobileNet 的核心层<strong>深度可分离卷积</strong>。然后描述 MobileNet 的网络结构，并对<strong>宽度乘法器</strong>和<strong>分辨率乘法器</strong>这两个模型超参数进行了描述。</p><h2 id="Depthwise-Separable-Convolution"><a href="#Depthwise-Separable-Convolution" class="headerlink" title="Depthwise Separable Convolution"></a>Depthwise Separable Convolution</h2><p>MobileNet 是基于深度可分离卷积构建的网络，它是将标准卷积拆分为了两个操作：<strong>深度卷积</strong>（depthwise convolution）和 <strong>逐点卷积</strong>（pointwise convolution）。</p><p>深度卷积和标准卷积不同，对于标准卷积而言其卷积核是用在所有的输入通道上（input channels），而深度卷积将卷积核拆分成为<strong>单通道</strong>形式，针对每个输入通道采用不同的卷积核，就是说一个卷积核对应一个输入通道，<strong>对每一通道进行卷积</strong>操作，这样就得到了和输入特征图通道数一致的输出特征图。而逐点卷积就是普通的卷积，只不过其采用 1x1 的卷积核，主要作用就是对特征图进行升维和降维。</p><p>这么做的好处就是可以大幅度<strong>降低参数量</strong>和<strong>计算量</strong>，但是能达到和标准卷积差不多的效果。</p><p><img src="Figure2.png"></p><ul><li>F 为输入特征图；DF 为输入的宽度和高度；M 为输入通道数</li><li>K 为卷积核；DK 为卷积核的维度</li><li>G 为输出特征图； DG 为输出的宽度和高度；N为输出通道数</li></ul><p><strong>假设步长（stride）为 1 且填充（padding），这时候卷积前后的尺寸不变（DG=DF）</strong></p><p><strong>标准卷积</strong></p><ul><li>卷积核的尺寸是 Dk×Dk×M，一共有N个，所以标准卷积的参数量（params）是：DK x DK x M x N    </li><li>输出特征图大小为 DF x DF，一共要做 DF x DF 次乘加运算，所以标准卷积的计算量是：DK x DK x M x N x DF x DF</li></ul><p><strong>深度可分离卷积</strong></p><p><img src="DepthwiseSeparableConvolution.png"></p><ul><li>深度卷积的卷积核尺寸 Dk×Dk×1，一共 M 个；逐点卷积的卷积核尺寸为 1×1×M，一共有 N 个，所以深度可分离卷积的参数量是：DK x DK x M + M x N</li><li>深度卷积和逐点卷积得到的输出特征图大小都是 DF x DF，各做 DF x DF 次乘运算，所以深度可分离卷积的计算量是：DK x DK x M x DF x DF + M x N x DF x DF</li></ul><p>可以减少如下的计算量:</p><p>（DK x DK x M x DF x DF + M x N x DF x DF）/（DK x DK x M x N x DF x DF）= 1 / N + 1 / DK^2</p><p>MobileNet 使用 3 × 3 深度可分离卷积，它比标准卷积的计算量少 8 到 9 倍，而精度只有 1% 很小的降低。</p><p><img src="Table4.png"></p><h2 id="Network-Structure-and-Training"><a href="#Network-Structure-and-Training" class="headerlink" title="Network Structure and Training"></a>Network Structure and Training</h2><p>下图左边是标准卷积层，右边是 MobileNet 的卷积层。首先使用 3×3 的深度卷积提取特征，接着是一个 BN（Batch Normalization，批量标准化）层，随后是一个 ReLU（非线性激活函数，这里使用的是 <strong>ReLU6</strong>） 层，在之后就会 1x1 逐点卷积，最后就是 BN 和 ReLU 了。这也很符合深度可分离卷积，将左边的标准卷积拆分成右边的一个深度卷积加一个逐点卷积。</p><p><img src="Figure3.png"></p><p>MobileNetV1 的具体结构如下:</p><p><img src="Table1.png"></p><ul><li>Conv：标准卷积</li><li>s2：卷积步长 stride 为 2</li><li>dw：深度卷积</li><li>Avg Pool：平均池化</li><li>FC：全连接层</li><li>将深度卷积和逐点卷积看做两层，共 28 层网络</li></ul><p>MobileNet 模型结构将几乎所有的计算都放到密集的 1×1 卷积中。这可以通过高度优化的通用矩阵乘法（GEMM）函数来实现。通常卷积是由 GEMM 实现的，但需要在内存中进行初始的重新排序称为 im2col，以便将其映射到 GEMM。例如，这种方法在流行的 Caffe 包中使用。1×1 卷积不需要在内存中重新排序，可以直接用 GEMM 实现，GEMM 是最优化的数值线性代数算法之一。MobileNet 在 1 × 1 的卷积中花费了 95% 的计算时间，也占有 75% 的参数，几乎所有的附加参数都在全连接层中。</p><p><img src="Table2.png"></p><h2 id="Width-Multiplier-Thinner-Models"><a href="#Width-Multiplier-Thinner-Models" class="headerlink" title="Width Multiplier: Thinner Models"></a>Width Multiplier: Thinner Models</h2><p>虽然基本的 MobileNe t架构已经很小并且延迟很低，但是很多时候特定的用例或应用程序可能需要模型更小更快。为了构建这些更小、计算成本更低的模型，论文引入了一个非常简单的参数 α，称为<strong>宽度乘数</strong>。宽度乘数 α 的作用是在每一层均匀地细化网络。</p><p>对于给定的层和宽度乘数 α，输入通道数 M 变为 αM，输出通道数 N 变为 αN。具有宽度乘数 α 的深度可分卷积的计算量为：DK x DK x αM x DF x DF + αM x αN x DF x DF  </p><p>其中 α∈(0，1]，通常设置为 1、0.75、0.5 和 0.25</p><h2 id="Resolution-Multiplier-Reduced-Representation"><a href="#Resolution-Multiplier-Reduced-Representation" class="headerlink" title="Resolution Multiplier: Reduced Representation"></a>Resolution Multiplier: Reduced Representation</h2><p>降低神经网络计算量的第二个超参数是<strong>分辨率乘数 ρ</strong>，将此方法应用到输入图像中，每一层的内部表示都由相同的乘法器减少。在实践中，可以通过设置输入分辨率隐式地设置 ρ 值。深度可分离的卷积计算量为：DK x DK x M x ρDF x ρDF + M x N x ρDF x ρDF</p><p>其中 ρ ∈ ( 0，1]，通常设置输入分辨率为 224 , 192 , 160 和 128 </p><p>用宽度乘子 α 和分辨率乘子 ρ 来表示网络核心层的计算代价为深度可分离的卷积：DK x DK x αM x ρDF x ρDF + αM x αN x ρDF x ρDF</p><p>此时看下计算量对比：</p><p>（DK x DK x αM x ρDF x ρDF + αM x αN x ρDF x ρDF）/ （DK x DK x M x N x DF x DF）= αρ / N + (αρ / DK)^2</p><p>下面例子是标准卷积和 MobileNet 深度可分离卷积及带有超参数的模型计算量和参数量对比，其中 DK= 3, M = 512, N = 512, DF= 14。</p><p><img src="Table3.png"></p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>论文提出了一种基于深度可分离卷积的新模型 MobileNet，同时提出了两个超参数用于快速调节模型适配到特定环境，来构建更小、更快的网络。实验部分将 MobileNet 与许多先进模型做对比，展现出 MobileNet 的在尺寸、速度、准确性上的优越性。最后，论文证明了 MobileNet 在广泛应用于各种任务时的有效性。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CNN </tag>
            
            <tag> MobileNetV1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卷积神经网络中的参数量和计算量</title>
      <link href="2021/03/30/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%E9%87%8F%E5%92%8C%E8%AE%A1%E7%AE%97%E9%87%8F/"/>
      <url>2021/03/30/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%E9%87%8F%E5%92%8C%E8%AE%A1%E7%AE%97%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<p>在设计一个 CNN 时，通常要考虑两个事情，即计算量和参数量。前者决定了网络训练的快慢，后者决定了计算设备需要多大的内存或显存。</p><p>参数量指的是卷积核中的参数的数量，计算量指的是卷积神经网络执行数值运算的次数。</p><p>由于参数共享，参数量只与特征图 feature map 的数量有关，而与 feature map 的大小无关，计算量与二者都有关。</p><table><thead><tr><th>符号</th><th>解释</th></tr></thead><tbody><tr><td>M</td><td>输入通道</td></tr><tr><td>N</td><td>输出通道</td></tr><tr><td>(K,K）</td><td>卷积核</td></tr><tr><td>(Hin,Win）</td><td>输入特征图</td></tr><tr><td>(Hout,Wout)</td><td>输出特征图</td></tr></tbody></table><table><thead><tr><th>卷积类型</th><th>参数量</th><th>计算量</th><th>特点</th></tr></thead><tbody><tr><td>标准卷积</td><td>K x K x M x N</td><td>K x K x M x N x Hout x Wout</td><td>卷积核 channel = 输入特征图 channel；输出特征图 channel = 卷积核个数</td></tr><tr><td>深度可分离卷积</td><td>K x K x M + M x N</td><td>K x K x M x Hout x Wout + M x N x Hout x Wout</td><td>深度卷积卷积核 channel = 1；输入特征图 channel = 卷积核个数 = 输出特征图 channel</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CNN </tag>
            
            <tag> 参数量 </tag>
            
            <tag> 计算量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MobileNet-SSD模型的训练与tflite格式转换</title>
      <link href="2021/03/27/MobileNet-SSD%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%AE%AD%E7%BB%83%E4%B8%8Etflite%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/"/>
      <url>2021/03/27/MobileNet-SSD%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%AE%AD%E7%BB%83%E4%B8%8Etflite%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>最近在做毕业设计嵌入式端的目标检测系统，看了前人写的论文大多数用的都是 MobileNet-SSD 模型，就去学习了一下。MobileNet v1 是 Google 2017年发表的用于移动和嵌入式视觉应用程序的高效模型，其核心思想就是提出了深度可分离卷积（Depthwise Separable Convolution）来代替标准卷积，同时引入两个全局超参数（宽度和分辨率）进一步缩小模型规模来构建更小、更快的移动网络。其后 v2 v3 版本（还没学）都是在 v1 基础上引入新技术不断缩小模型。</p><p>在树莓派 4B（Raspberry Pi OS、4GB、tensorflow 1.4）直接调用 <a href="https://github.com/tensorflow/models/blob/master/research/object_detection/g3doc/tf1_detection_zoo.md">TensorFlow object detection API</a> 中的 ssd_mobilenet_v2_coco 预训练模型卡的起飞，大概只有0.8-0.9 FPS，毫无目标检测体验。想着把模型在 VOC2012 数据集上再次训练，下面是 MobileNet-SSD 模型训练过程。</p><h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><ol><li>Github 下载/克隆 <a href="https://github.com/tensorflow/models">tensorflow-models</a>，后面的操作都要在这个目录下执行，建议创建 Python 虚拟环境</li><li>下载数据集 <a href="http://host.robots.ox.ac.uk/pascal/VOC/voc2012/VOCtrainval_11-May-2012.tar">VOC2012</a>，也可以使用 <a href="https://github.com/tzutalin/labelImg">LabelImg</a> 制作数据集训练自己的数据</li><li>下载 MobileNet-SSD 预训练模型，这里我下载的是 <a href="http://download.tensorflow.org/models/object_detection/ssd_mobilenet_v1_coco_2018_01_28.tar.gz">ssd_mobilenet_v1_coco</a></li></ol><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><table><thead><tr><th>基本配置</th><th>版本</th></tr></thead><tbody><tr><td>CPU</td><td>Intel(R) Core(TM) i7-7500U CPU @ 2.70GHz   2.90 GHz</td></tr><tr><td>GPU</td><td>AMD Radeon(TM) 530 (没用)</td></tr><tr><td>RAM</td><td>12 GB</td></tr><tr><td>OS</td><td>Windows 10</td></tr><tr><td>Python</td><td>3.7.9</td></tr><tr><td>TensorFlow</td><td>1.15.5</td></tr></tbody></table><h2 id="设置-PYTHONPATH"><a href="#设置-PYTHONPATH" class="headerlink" title="设置 PYTHONPATH"></a>设置 PYTHONPATH</h2><p>需要修改 PYTHONPATH 环境变量以指向刚下载的 tensorflow-models 内的某些目录，这里我把文件重命名为 <code>models</code>。</p><table><thead><tr><th>变量名</th><th>变量值（根据自己的路径修改）</th></tr></thead><tbody><tr><td>PYTHONPATH</td><td>path\to\models;path\to\models\research\slim;</td></tr></tbody></table><p><img src="PYTHONPATH.png"></p><h2 id="安装-protobuf"><a href="#安装-protobuf" class="headerlink" title="安装 protobuf"></a>安装 protobuf</h2><p>这是一个轻便高效的序列化数据结构的协议，可以用于网络通信和数据存储的工具库（类似Json），但相比于Json，Protobuf 有更高的转化效率。Windows 下的安装很简单，只需到 github 上下载 <a href="https://github.com/protocolbuffers/protobuf/releases">protobuf</a> 对应版本压缩包安装即可，如 protoc-3.15.6-win64.zip。</p><p>现在，使用 protoc 来编译目标检测 API 使用的协议 proto 文件来产生 py 文件。proto 文件放在 <code>models\research\object_detection\protos\</code> 中，从 <code>research/</code> 目录执行命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd models/research/</span></span><br><span class="line">protoc object_detection/protos/*.proto --python_out=.</span><br></pre></td></tr></table></figure><p>这时 protos 文件夹下会生成相应的 py 文件。</p><h2 id="安装-API"><a href="#安装-API" class="headerlink" title="安装 API"></a>安装 API</h2><p>继续在<code>research/</code>目录下执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python setup.py build</span><br><span class="line">python setup.py install</span><br><span class="line">python object_detection/builders/model_builder_test.py  <span class="comment"># 测试是否安装成功</span></span><br></pre></td></tr></table></figure><h1 id="配置和训练"><a href="#配置和训练" class="headerlink" title="配置和训练"></a>配置和训练</h1><p>在<code>object_detection/</code>目录下创建目录<code>ssd_model</code>，把下载好的 VOC2012 数据集解压进去，数据集路径为 <code>models\research\object_detection\ssd_model\VOCdevkit\</code>。执行以下命令将 VOC 数据集转换成 tfrecord 格式的数据。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python ./object_detection/dataset_tools/create_pascal_tf_record.py --label_map_path=object_detection/data/pascal_label_map.pbtxt --data_dir=object_detection/ssd_model/VOCdevkit/ --year=VOC2012 --<span class="built_in">set</span>=train --output_path=object_detection/ssd_model/pascal_train.record </span><br><span class="line">python ./object_detection/dataset_tools/create_pascal_tf_record.py --label_map_path=object_detection/data/pascal_label_map.pbtxt --data_dir=object_detection/ssd_model/VOCdevkit/ --year=VOC2012 --<span class="built_in">set</span>=val --output_path=object_detection/ssd_model/pascal_val.record</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后会在<code>ssd_model/</code>目录下生成<code>pascal_train.record</code>和<code>pascal_val.record</code>两个文件，分别有650M左右。</p><p><img src="pascal_train_val.png"></p><p>复制 <code>object_detection\data\pascal_label_map.pbtxt</code> 和<code>object_detection\samples\configs\ssd_mobilenet_v1_coco.config</code>到 <code>ssd_model/</code> 目录下，接着把之前下载的<code>ssd_mobilenet_v1_coco</code>解压到<code>ssd_model/ssd_mobilenet</code>下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp object_detection/data/pascal_label_map.pbtxt object_detection/ssd_model/ </span><br><span class="line">cp object_detection/samples/configs/ssd_mobilenet_v1_coco.config object_detection/ssd_model/</span><br></pre></td></tr></table></figure><p>此时 <code>ssd_model</code> 下应有以下文件：</p><p><img src="ssd_model.png"></p><p>打开 pascal_label_map.pbtxt，这个文件里面是类似 Json 格式的 label 集，列出了数据集里有哪些<code>label</code>。Pascal VOC 这个数据集<code>label</code>共有20个。然后打开配置文件 <code>ssd_mobilenet_v1_coco.config</code>，把<code>num_classes</code>改为<code>20</code><br>配置默认训练次数<code>num_steps: 200000</code>，根据自己需要改，注意这个训练是很慢的，差不多以天为单位，所以可以适当改小点。</p><p>然后根据自己文件路径修改一些文件路径：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 预训练模型 ckpt 文件的位置</span><br><span class="line">fine_tune_checkpoint: &quot;D:/Code/Python/tfmodels/models/research/object_detection/ssd_model/ssd_mobilenet/model.ckpt&quot;</span><br><span class="line"></span><br><span class="line"># 训练数据位置以及标签文件位置</span><br><span class="line">train_input_reader: &#123;</span><br><span class="line">  tf_record_input_reader &#123;</span><br><span class="line">    input_path: &quot;D:/Code/Python/tfmodels/models/research/object_detection/ssd_model/pascal_train.record&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  label_map_path: &quot;D:/Code/Python/tfmodels/models/research/object_detection/ssd_model/pascal_label_map.pbtxt&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 测试数据位置和相应标签文件位置，shuffle表示是否随机选取测试图片</span><br><span class="line">eval_input_reader: &#123;</span><br><span class="line">  tf_record_input_reader &#123;</span><br><span class="line">    input_path: &quot;D:/Code/Python/tfmodels/models/research/object_detection/ssd_model/pascal_val.record&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  label_map_path: &quot;D:/Code/Python/tfmodels/models/research/object_detection/ssd_model/pascal_label_map.pbtxt&quot;</span><br><span class="line">  shuffle: false</span><br><span class="line">  num_readers: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>object_detection\</code> 下新建文件夹 <code>train</code> 保存训练数据。完成之后，我们就可以训练了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd models/research/</span></span><br><span class="line">python object_detection/model_main.py \</span><br><span class="line">--pipeline_config_path=object_detection/ssd_model/ssd_mobilenet_v1_coco.config \</span><br><span class="line">--model_dir=object_detection/train \</span><br><span class="line">--alsologtostderr</span><br><span class="line"><span class="comment"># pipeline_config_path 为修改后的config文件的位置</span></span><br><span class="line"><span class="comment"># train_dir 为训练产生数据的保存位置</span></span><br></pre></td></tr></table></figure><p>训练可视化可以在 tensorboard 中查看训练情况，在浏览器中打开 <a href="http://localhost:6006/">http://localhost:6006/</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensorboard --logdir=path/to/object_detection/train  <span class="comment"># 保存训练数据文件夹</span></span><br></pre></td></tr></table></figure><p><img src="tensorboard.png"></p><p>经过漫长的等待，在<code>/object_detection/train</code>目录下生成了训练好的模型。（下图未训练完）</p><p><img src="train.png"></p><p>创建文件夹<code>ssd_model/model</code>导出训练好的模型，生成 pb 文件，再把 pascal_label_map.pbtxt 的内容改成<code>txt</code>作为 labe l文件，这个模型就可以使用了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">python object_detection/export_inference_graph.py \</span><br><span class="line">--input_type image_tensor \</span><br><span class="line">--pipeline_config_path object_detection/ssd_model/ssd_mobilenet_v1_coco.config \</span><br><span class="line">--trained_checkpoint_prefix object_detection/train/model.ckpt-77 \</span><br><span class="line">--output_directory object_detection/ssd_model/model/</span><br></pre></td></tr></table></figure><h1 id="测试模型"><a href="#测试模型" class="headerlink" title="测试模型"></a>测试模型</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> six.moves.urllib <span class="keyword">as</span> urllib</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> tarfile</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"><span class="keyword">from</span> object_detection.utils <span class="keyword">import</span> label_map_util</span><br><span class="line"><span class="keyword">from</span> object_detection.utils <span class="keyword">import</span> visualization_utils <span class="keyword">as</span> vis_util</span><br><span class="line"><span class="keyword">from</span> distutils.version <span class="keyword">import</span> StrictVersion</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># This is needed since the notebook is stored in the object_detection folder.</span></span><br><span class="line">sys.path.append(<span class="string">&quot;..&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> StrictVersion(tf.__version__) &lt; StrictVersion(<span class="string">&#x27;1.9.0&#x27;</span>):</span><br><span class="line">    <span class="keyword">raise</span> ImportError(<span class="string">&#x27;Please upgrade your TensorFlow installation to v1.9.* or later!&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">CWD_PATH = os.getcwd()</span><br><span class="line">PATH_TO_CKPT = os.path.join(CWD_PATH, <span class="string">&#x27;model&#x27;</span>, <span class="string">&#x27;frozen_inference_graph.pb&#x27;</span>)</span><br><span class="line"><span class="comment"># List of the strings that is used to add correct label for each box.</span></span><br><span class="line">PATH_TO_LABELS = os.path.join(CWD_PATH, <span class="string">&#x27;pascal_label_map.pbtxt&#x27;</span>)</span><br><span class="line"></span><br><span class="line">NUM_CLASSES = <span class="number">100</span></span><br><span class="line">start = time.time()</span><br><span class="line"></span><br><span class="line">detection_graph = tf.Graph()</span><br><span class="line"><span class="keyword">with</span> detection_graph.as_default():</span><br><span class="line">    od_graph_def = tf.compat.v1.GraphDef()</span><br><span class="line">    <span class="keyword">with</span> tf.io.gfile.GFile(PATH_TO_CKPT, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> fid:</span><br><span class="line">        serialized_graph = fid.read()</span><br><span class="line">        od_graph_def.ParseFromString(serialized_graph)</span><br><span class="line">        tf.import_graph_def(od_graph_def, name=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">label_map = label_map_util.load_labelmap(PATH_TO_LABELS)</span><br><span class="line">categories = label_map_util.convert_label_map_to_categories(label_map, max_num_classes=NUM_CLASSES, use_display_name=<span class="literal">True</span>)</span><br><span class="line">category_index = label_map_util.create_category_index(categories)</span><br><span class="line"><span class="keyword">with</span> detection_graph.as_default():</span><br><span class="line">    <span class="keyword">with</span> tf.compat.v1.Session(graph=detection_graph) <span class="keyword">as</span> sess:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            ret, image_np = cap.read()</span><br><span class="line">            <span class="comment"># Expand dimensions since the model expects images to have shape: [1, None, None, 3]</span></span><br><span class="line">            image_np_expanded = np.expand_dims(image_np, axis=<span class="number">0</span>)</span><br><span class="line">            image_tensor = detection_graph.get_tensor_by_name(<span class="string">&#x27;image_tensor:0&#x27;</span>)</span><br><span class="line">            <span class="comment"># Each box represents a part of the image where a particular object was detected.</span></span><br><span class="line">            boxes = detection_graph.get_tensor_by_name(<span class="string">&#x27;detection_boxes:0&#x27;</span>)</span><br><span class="line">            <span class="comment"># Each score represent how level of confidence for each of the objects.</span></span><br><span class="line">            <span class="comment"># Score is shown on the result image, together with the class label.</span></span><br><span class="line">            scores = detection_graph.get_tensor_by_name(<span class="string">&#x27;detection_scores:0&#x27;</span>)</span><br><span class="line">            classes = detection_graph.get_tensor_by_name(<span class="string">&#x27;detection_classes:0&#x27;</span>)</span><br><span class="line">            num_detections = detection_graph.get_tensor_by_name(<span class="string">&#x27;num_detections:0&#x27;</span>)</span><br><span class="line">            <span class="comment"># Actual detection.</span></span><br><span class="line">            (boxes, scores, classes, num_detections) = sess.run(</span><br><span class="line">                [boxes, scores, classes, num_detections],</span><br><span class="line">                feed_dict=&#123;image_tensor: image_np_expanded&#125;)</span><br><span class="line">            <span class="comment"># Visualization of the results of a detection.</span></span><br><span class="line">            image = image_np</span><br><span class="line">            vis_util.visualize_boxes_and_labels_on_image_array(</span><br><span class="line">                image_np, np.squeeze(boxes),</span><br><span class="line">                np.squeeze(classes).astype(np.int32),</span><br><span class="line">                np.squeeze(scores), category_index,</span><br><span class="line">                use_normalized_coordinates=<span class="literal">True</span>,</span><br><span class="line">                line_thickness=<span class="number">2</span>)</span><br><span class="line">            final_score = np.squeeze(scores)</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> scores <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> final_score[i] &gt; <span class="number">0.5</span>:</span><br><span class="line">                    count = count + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;the count of objects is: &quot;</span>, count)</span><br><span class="line">            im_shape = image.shape</span><br><span class="line">            im_width = im_shape[<span class="number">1</span>]</span><br><span class="line">            im_height = im_shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> count != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(count):</span><br><span class="line">                    <span class="comment"># print(boxes[0][i])</span></span><br><span class="line">                    y_min = boxes[<span class="number">0</span>][i][<span class="number">0</span>] * im_height</span><br><span class="line">                    x_min = boxes[<span class="number">0</span>][i][<span class="number">1</span>] * im_width</span><br><span class="line">                    y_max = boxes[<span class="number">0</span>][i][<span class="number">2</span>] * im_height</span><br><span class="line">                    x_max = boxes[<span class="number">0</span>][i][<span class="number">3</span>] * im_width</span><br><span class="line">                    cv2.rectangle(image, (<span class="built_in">int</span>(x_min), <span class="built_in">int</span>(y_min)), (<span class="built_in">int</span>(x_max), <span class="built_in">int</span>(y_max)), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line">                    <span class="comment">#print(&quot;object&#123;0&#125;: &#123;1&#125;&quot;.format(i, category_index[classes[0][i]][&#x27;name&#x27;]), &#x27;,Center_X:&#x27;, int((x_min + x_max) / 2), &#x27;,Center_Y:&#x27;, int((y_min + y_max) / 2))</span></span><br><span class="line">            <span class="comment"># print(x_min,y_min,x_max,y_max)</span></span><br><span class="line"></span><br><span class="line">            seconds = time.time() - start</span><br><span class="line">            start = time.time()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Time taken : &#123;0&#125; seconds&quot;</span>.<span class="built_in">format</span>(seconds))</span><br><span class="line">            cv2.imshow(<span class="string">&#x27;object detection&#x27;</span>, cv2.resize(image, (<span class="number">800</span>, <span class="number">600</span>))) <span class="comment"># cv2.resize(image_np, (800,600))</span></span><br><span class="line">            <span class="keyword">if</span> cv2.waitKey(<span class="number">25</span>) &amp; <span class="number">0xFF</span> == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">                cv2.destroyAllWindows()</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">cap.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h1 id="TFLite-模型转换"><a href="#TFLite-模型转换" class="headerlink" title="TFLite 模型转换"></a>TFLite 模型转换</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p><a href="https://www.tensorflow.org/lite/guide?hl=zh-cn">TensorFlow Lite</a> 是一组工具，可帮助开发者在移动设备、嵌入式设备和 IoT 设备上运行 TensorFlow 模型。包括两个主要组件：TensorFlow Lite 解释器和 TensorFlow Lite 转换器。</p><p>解释器可以在手机、嵌入式 Linux 设备和微控制器等很多不同类型的硬件上运行经过专门优化的模型（.tflite），转换器可将 TensorFlow 模型转换为方便解释器使用的格式，并可引入优化以减小二进制文件的大小和提高性能。下面详细讲下转换过程。</p><p>TensorFlow Lite 转换器提供两种转换方法：</p><ul><li>Python API：它让您可以更轻松地在模型开发流水线中转换模型、应用优化、添加元数据，并且拥有更多功能</li><li>命令行：它仅支持基本模型转换</li></ul><p>将 SavedModel 转换为 TensorFlow Lite 模型，官方给提供了两种方式的实例代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="comment"># Convert the model</span></span><br><span class="line"><span class="comment"># TensorFlow 1.x</span></span><br><span class="line">converter = tf.compat.v1.lite.TFLiteConverter.from_saved_model(saved_model_dir) <span class="comment"># path to the SavedModel directory</span></span><br><span class="line"><span class="comment"># TensorFlow 2.x</span></span><br><span class="line"><span class="comment"># converter = tf.lite.TFLiteConverter.from_saved_model(saved_model_dir) </span></span><br><span class="line">tflite_model = converter.convert()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Save the model.</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;model.tflite&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(tflite_model)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tflite_convert \</span><br><span class="line">  --saved_model_dir=/tmp/mobilenet_saved_model \</span><br><span class="line">  --output_file=/tmp/mobilenet.tflite</span><br></pre></td></tr></table></figure><p>示例代码中的 <code>saved_model_dir</code> 和 <code>mobilenet_saved_model</code> 路径一定要写对，正确的是上面训练好的模型 <code>model/saved_model</code> ，不要只写到 <code>model</code> ，否则会报下面错误。</p><blockquote><p>OSError: SavedModel file does not exist at: object_detection/ssd_model/model/{saved_model.pbtxt|saved_model.pb}</p></blockquote><p>当你开始转换，看着终端不断输出，然后它就又会报错了。</p><blockquote><p>ValueError: None is only supported in the 1st dimension. Tensor ‘image_tensor’ has invalid shape ‘[None, None, None, 3]’.</p></blockquote><h2 id="开始转换"><a href="#开始转换" class="headerlink" title="开始转换"></a>开始转换</h2><p>从我们上面训练好的模型转换成 tflite 只需要两步：</p><ol><li><p>先把 model.ckpt 转成 pb 和 pbtxt 文件，用的是 <code>object_detection/export_tflite_ssd_graph.py</code>，可以参考 <a href="https://github.com/tensorflow/models/blob/master/research/object_detection/export_tflite_ssd_graph.py">export_tflite_ssd_graph.py</a>，下面是示例代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd models/research/</span></span><br><span class="line">python object_detection/export_tflite_ssd_graph.py \</span><br><span class="line">  --pipeline_config_path path\to\ssd_model\model\pipeline.config \</span><br><span class="line">  --trained_checkpoint_prefix path\to\ssd_model\model\model.ckpt \</span><br><span class="line">  --output_directory path\to\ssd_model\model</span><br><span class="line">  </span><br><span class="line"><span class="comment"># pipeline_config_path pipeline 配置文件位置</span></span><br><span class="line"><span class="comment"># trained_checkpoint_prefix ckpt 文件位置</span></span><br><span class="line"><span class="comment"># output_directory 导出 pb 文件位置</span></span><br></pre></td></tr></table></figure><p>此时在 <code>ssd_model\model</code> 下会生成两个文件：<code>tflite_graph.pb</code> 和 <code>tflite_graph.pbtxt</code></p></li><li><p>接下来把 pb 转为 tflite 文件，官方给的示例代码总是报错原因就在这，我们少了第一步，直接转换了 <code>saved_model.pb</code> 到 <code>tflite</code>，同时也缺少模型转换参数，下面是示例代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tflite_convert \</span><br><span class="line">  --graph_def_file=path\to\ssd_model\model\tflite_graph.pb \</span><br><span class="line">  --output_file=path\to\ssd_model\model\ssd_mobilenet.tflite \</span><br><span class="line">  --input_arrays=normalized_input_image_tensor \</span><br><span class="line">  --output_arrays=<span class="string">&#x27;TFLite_Detection_PostProcess&#x27;</span>,<span class="string">&#x27;TFLite_Detection_PostProcess:1&#x27;</span>,<span class="string">&#x27;TFLite_Detection_PostProcess:2&#x27;</span>,<span class="string">&#x27;TFLite_Detection_PostProcess:3&#x27;</span> \</span><br><span class="line">  --input_shape=1,300,300,3 \</span><br><span class="line">  --allow_custom_ops</span><br><span class="line"></span><br><span class="line"><span class="comment"># graph_def_file 第一步中 tflite_graph.pb路径</span></span><br><span class="line"><span class="comment"># output_file tflite 导出路径</span></span><br><span class="line"><span class="comment"># input_shape 1,x,x,1 根据配置文件修改</span></span><br></pre></td></tr></table></figure><p>至此我们完成了 tflite 模型转换。</p><p>可以在嵌入式、移动端部署了，下图是使用的  ssd_mobilenet_v1_coco.tflite 模型在树莓派部署效果图。推断时间大概在 400-500 ms，实时性不是很好，使用最新的 ssd_mobilenet_v3_small 速度大约提高了一倍，ssd_mobilenet_v3_large 推断时间比 v1 略高100ms，但是准确率有很大的提升，大厂的产品不得不服啊！<img src="ssd_mobilenet_v1.jpg"></p></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://wossoneri.github.io/2017/12/12/%5BTensorflow%5DTrain-model-with-SSD-MobileNet/#toc-heading-1">[Tensorflow] 使用SSD-MobileNet训练模型</a></p><p><a href="https://www.jianshu.com/p/20f7f3755ddd">MobileNet SSD V2模型的压缩与tflite格式的转换（补充版）</a></p><p><a href="https://www.tensorflow.org/lite/convert/index?hl=zh-cn">TensorFlow Lite 转换器</a></p><p><a href="https://www.jianshu.com/p/630c27cb8c55?utm_campaign=haruki">30组-MobileNets论文解读和MobileNetV2简介</a></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CNN </tag>
            
            <tag> MobileNet-SSD </tag>
            
            <tag> tensorflow lite </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习基础知识</title>
      <link href="2021/03/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>2021/03/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>人工智能的浪潮正在席卷全球。</p><p>2016年，谷歌阿尔法围棋以 4:1 战胜围棋世界冠军、职业九段棋手李世石，不仅让深度学习为人们所知，而且掀起了人工智能的“大众热”。随之也产生了一些学术名词如：人工智能（Artificial Intelligence, AI）、机器学习（Machine Learning, ML）、深度学习（Deep Learning, DL）、强化学习（Reinforcement Learning, RL）等，很多人分不清他们彼此之间的关系。</p><p><img src="AI.jpg" alt="AI 研究分支"></p><p>简单说，人工智能范围最大，涵盖机器学习、深度学习和强化学习。机器学习是一种实现人工智能的方法，深度学习和强化学习都是实现机器学习的技术。</p><p>机器学习之父 Tom Mitchell 如此定义机器学习：“每个机器学习都可以被精准地定义为：1.任务 T；2.训练过程 E；3.模型表现 P。而学习过程则可以被拆解为为了实现任务 T，我们通过训练 E，逐步提高表现 P 的一个过程“。深度学习是用于建立、模拟人脑进行分析学习的神经网络，并模仿人脑的机制来解释数据的一种机器学习技术。强化学习用于描述和解决智能体在与环境的交互过程中通过学习策略以达成回报最大化或实现特定目标的问题。</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++字符串、字符数组长度</title>
      <link href="2020/08/20/C-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6/"/>
      <url>2020/08/20/C-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p>在 C++ 中常用的获取字符串长度或者字符串数组长度的函数有：</p><ul><li>length()</li><li>size()</li><li>strlen()</li><li>sizeof()</li></ul><p>str.length() 和 str.size() 用来求字符串（<strong>string 类型</strong>）的长度。</p><p>strlen(str) 是用于求<strong>字符数组</strong>的长度，其参数是char*。当数组名作为参数传入时，实际上数组就退化成指针了。</p><p>sizeof(str) 是运算符，在头文件中 typedef 为 unsigned int，其值在编译时即计算好了，参数可以是数组、指针、类型、对象、函数等。由于在编译时计算，因此 <strong>sizeof() 不能用来返回动态分配的内存空间的大小</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;01234&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> s2[<span class="number">10</span>] = <span class="string">&quot;0123456&quot;</span>;</span><br><span class="line">cout&lt;&lt;s1.<span class="built_in">length</span>()&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;s1.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="built_in">strlen</span>(s2)&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(s2)&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(s1)&lt;&lt;endl;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串长度 </tag>
            
            <tag> 字符数组长度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中sort()函数强大功能</title>
      <link href="2020/08/01/C-%E4%B8%ADsort-%E5%87%BD%E6%95%B0%E5%BC%BA%E5%A4%A7%E5%8A%9F%E8%83%BD/"/>
      <url>2020/08/01/C-%E4%B8%ADsort-%E5%87%BD%E6%95%B0%E5%BC%BA%E5%A4%A7%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p>最近在刷王道考研机试指南（机试小白），惊奇的发现 sort() 函数功能不是简单排个序。</p><p>sort()函数原型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(start,end,cmp);</span><br><span class="line"><span class="comment">// start表示要排序数组的起始地址</span></span><br><span class="line"><span class="comment">// end表示数组结束地址的下一位</span></span><br><span class="line"><span class="comment">// cmp用于规定排序的方法，可不填，默认升序</span></span><br></pre></td></tr></table></figure><p>sort() 函数包含在头文件为 <strong>#include &lt;algorithm&gt;</strong> 的 c++ 标准库中</p><p>一般我就使用两个参数的，第三个参数默认从小到大排序。例如对数组 a[n] 排序：sort(a,a+n);</p><p>sort() 函数的强大之处是在它的第三个参数排序方法，<strong>可以任意的设定自己的规则，使排序对象按照自己指定的规则进行排序</strong>。</p><p><strong>cmp 函数定义规则</strong>：当 cmp 的返回值为 true 时，即表示 cmp 函数的第一个参数将会排在第二个参数之前，反之，第一个参数将会排在第二个参数之后。</p><p><strong>例 2.2 成绩排序</strong>：有 N 个学生的数据，将学生数据按成绩高低排序，如果成绩相同则按姓名字符的字母序排序，如果姓名的字母序也相同则按照学生的年龄排序，并输出N个学生排序后的信息。</p><p>输入：测试数据有多组，每组输入第- 行有一个整数 N (N&lt;=1000) ,接下来的N行包括N个学生的数据。每个学生的数据包括姓名(长度不超过 100 的字符串)、年龄(整型数)、成绩(小于等于 100 的正数)。</p><p>输出：将学生信息按成绩进行排序，成绩相同的则按姓名的字母序进行排序。然后输出学生信息，按照如下格式：姓名 年龄 成绩</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span> <span class="comment">// 万能头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stu</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">int</span> grade;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Stu a,Stu b)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a.grade!=b.grade)</span><br><span class="line"><span class="keyword">return</span> a.grade&lt;b.grade;  <span class="comment">// 分数不一样</span></span><br><span class="line"><span class="keyword">int</span> tmp = <span class="built_in">strcmp</span>(a.name,b.name); <span class="comment">// 以下分数相同 </span></span><br><span class="line"><span class="keyword">if</span>(tmp!=<span class="number">0</span>) <span class="keyword">return</span> tmp&lt;<span class="number">0</span>;<span class="comment">// 姓名字母序不同 </span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> a.age&lt;b.age;<span class="comment">// 姓名字母序相同、年龄不同 </span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">Stu s[n];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">cin&gt;&gt;s[i].name&gt;&gt;s[i].age&gt;&gt;s[i].grade;</span><br><span class="line"><span class="built_in">sort</span>(s,s+n,cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">cout&lt;&lt;s[i].name&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;s[i].age&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;s[i].grade&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学建模之预测模型</title>
      <link href="2020/07/29/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E4%B9%8B%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%9E%8B/"/>
      <url>2020/07/29/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E4%B9%8B%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>在数学建模中，常常会涉及一些预测类问题。预测方法种类繁多，从经典的单耗法、弹性系数法、统计分析法，到现在的灰色预测法、专家系统法和模糊数学法、甚至刚刚兴起的神经元网络法、优选组合法和小波分析法等200余种算法。下面将简要介绍几类预测方法：灰色预测模型、微分方程模型、差分方程模型、马尔可夫预测、插值与拟合、时间序列预测、神经元网络。</p><table><thead><tr><th>模型名称</th><th>模型简介</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>灰色预测模型</td><td>该模型使用的不是原始数据的序列，而是生成的数据序列。核心体系是Grey Model，即对原始数据作累加生成（或其他处理生成）得到近似的指数规律再进行建模的方法。</td><td>在处理较少的特征值数据，不需要数据的样本空间足够大，就能解决历史数据少、序列的完整性以及可靠性低的问题，能将无规律的原始数据进行生成得到规律较强的生成序列。</td><td>只适用于中短期的预测，只适合近似于指数增长的预测</td></tr><tr><td>微分方程模型</td><td>因果预测模型，大多为物理、几何方面的典型问题，其基本规律随着时间的增长呈指数增长，根据变量个数确定微分方程模型。</td><td>适用于短、中、长期的预测，既能反映内部规律以及事物的内在关系，也能够分析两个因素之间的相关关系，精度高便与改进。如传染病的预测模型、经济增长（或人口）的预测模型、Lanchester 战争预测模型。</td><td>由于反映的内部规律，方程建立与局部规律的独立性为假定基础，长期预测的偏差性较大，且微分方程的解比较难以得到。</td></tr><tr><td>差分方程模型</td><td>利用差分方程建模研究实际问题，常常需要根据统计数据用最小二乘法来拟合出差分方程的系数。</td><td>差分方程代替微分方程描述，在方程中避免了导函数，可以用迭代的方式求解。适用于商品销售量的预测、投资保险收益率的预测。</td><td>精度较低（用割线代替切线）</td></tr><tr><td>马尔可夫预测</td><td>某一系统在已知情况下，系统未来时刻的情况只与现在时刻有关，与历史数据无关的情况。</td><td>对过程的状态预测效果良好，可考虑用于生产现场危险状态的预测。研究一个商店的未来某一时刻的销售额，当现在时刻的累计销售额已知。</td><td>不适宜用于系统中长期预测</td></tr><tr><td>插值与拟合</td><td>适用于物体轨迹图像的模型。例如，导弹的运动轨迹测量的预测分析。</td><td>分为曲面拟合和曲线拟合，拟合就是要找出一种方法（函数）使得得到的仿真曲线（曲面）最大程度的接近原来的曲线（曲线），甚至重合。这个拟合的好坏程度可以用一个指标来判断。</td><td></td></tr><tr><td>时间序列预测</td><td>根据客观事物发展的这种连续规律性，运用过去的历史数据，通过统计分析，进一步推测市场未来的发展趋势。时间序列在时间序列分析预测法处于核心位置</td><td>一般用ARMA模型拟合时间序列，预测该时间序列未来值。Daniel 检验平稳性。自动回归 AR(Auto regressive)和移动平均 MA(Moving Average)预测模型。</td><td>经济类问题，从长期看具有一定的规律，而短期可能受到宏观调控、市场现时期的需求供应变化使得预测困难。</td></tr><tr><td>神经元网络</td><td>在控制与优化、预测与管理、模式识别与图像处理、通信等方面有十分广泛的应用。常用的是 BP 神经网络和径向基函数神经网络。</td><td>多层前向 BP 网络适用于求解内部机制复杂的问题，有一定的推广、概括能力。预测某水库的年径流量和因子特征值</td><td>多层前向BP网络学习速度较慢，训练失败的可能性较大。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 预测模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理</title>
      <link href="2020/07/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
      <url>2020/07/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机系统概论"><a href="#计算机系统概论" class="headerlink" title="计算机系统概论"></a>计算机系统概论</h1><p>计算机的基本组成：</p><ul><li>存储器——存放程序(指令)和数据</li><li>运算器——算术和逻辑运算</li><li>控制器——从内存中取出解题步骤加以分析，然后执行某种操作</li><li>输入输出设备——实现计算程序和原始数据的输入输出</li></ul><p><img src="Basic-composition.png" alt="计算机的基本组成"></p><h1 id="运算方法和运算器"><a href="#运算方法和运算器" class="headerlink" title="运算方法和运算器"></a>运算方法和运算器</h1><ol><li><p>原码</p><p>原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值。</p><p>[+1]原 = 0000 0001</p><p>[-1]原 = 1000 0001</p></li><li><p>反码</p><p>正数的反码是其本身；负数的反码是在其原码的基础上, 符号位不变，其余各个位取反。</p><p>[+1] = [00000001]原 = [00000001]反</p><p>[-1] = [10000001]原 = [11111110]反</p></li><li><p>补码</p><p>正数的补码就是其本身；负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1(即在反码的基础上+1)</p><p>[+1] = [00000001]原 = [00000001]反 = [00000001]补</p><p>[-1] = [10000001]原 = [11111110]反 = [11111111]补</p></li></ol><h1 id="多层次的存储器"><a href="#多层次的存储器" class="headerlink" title="多层次的存储器"></a>多层次的存储器</h1><p>多级存储器体系结构：高速缓冲存储器、主存储器和外存储器</p><p><img src="Hierarchical-structure.png" alt="存储器的分级结构"></p><p><strong>Cache</strong> 是一种高速缓冲存储器，缓存地址(虚拟地址或者物理地址)和数据，解决CPU和主存之间速度不匹配。</p><p>三种<strong>地址映象</strong>：</p><ul><li>全相联方式——Cache 利用率高，块冲突率低。地址变换复杂，需要较多的硬件（适用于小容量的Cache）</li><li>直接相连——地址变换速度快。Cache 利用率低，块冲突率高（适用于大容量的Cache）</li><li>组相联——折中方式</li></ul><h1 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h1><p>指令系统：又称指令集（Instruction Set）是计算机体系结构设计的核心，是计算机软、硬件接口，是用机器语言、汇编语言编写程序的用户所能看到的计算机的基本属性（CISC 和 RISC）</p><p>指令的一般<strong>结构形式</strong>：操作码字段 | 地址码字段</p><ul><li>操作码字段：表示指令的操作特性与功能</li><li>地址码字段：通常用于指定参与操作的操作数地址</li></ul><p>操作数<strong>寻址方式</strong></p><ol><li>隐含寻址</li><li>立即寻址</li><li>直接寻址</li><li>间接寻址</li><li>寄存器寻址和寄存器间接寻址</li><li>偏移寻址（相对寻址、基址寻址、变址寻址）</li><li>段寻址方式</li><li>堆栈寻址方式</li></ol><h1 id="中央处理器"><a href="#中央处理器" class="headerlink" title="中央处理器"></a>中央处理器</h1><p><strong>五级流水CPU</strong>：将计算机指令处理过程拆分为多个步骤，并通过多个硬件处理单元并行执行来加快指令执行速度。</p><ol><li>取指令（IF）</li><li>指令译码（ID）</li><li>执行运算（EX）</li><li>数据内存访问（MEM）</li><li>结果写回（WB）</li></ol><p><strong>相关冲突</strong>：资源相关、数据相关、控制相关</p><p><strong>多核 CPU</strong> 是一枚处理器中集成多个完整的计算引擎(内核)。多核 cpu 和单核 cpu 对于进程来说都是并发，并不是并行。但多核 cpu 每一个核心都可以独立执行一个线程，所以多核 cpu 可以真正实现多线程的并行。</p><p><strong>乱序执行</strong>是指CPU采用了将多条指令不按程序规定的顺序分发给各相应电路单元处理的技术。</p><p><strong>多发射</strong>是一个时钟周期内，从存储器内取出多条指令。</p><p><strong>超标量</strong>是每个时钟周期内能启动多条指令。</p><h1 id="总线系统"><a href="#总线系统" class="headerlink" title="总线系统"></a>总线系统</h1><ol><li>内部总线——CPU 内部连接各寄存器及运算部件之间的总线</li><li>系统总线——CPU 同计算机系统的其他高速功能部件(存储器、通道等)间互相连接的总线</li><li>I/O总线——中、低速 I/0 设备间互相连接的总线</li></ol><p>按照信号类型可分为数据总线、控制总线和地址总线。数据线和地址线常采用多路复用方式。</p><p><strong>仲裁方式</strong>分为集中式仲裁和分布式仲裁</p><ul><li>集中式仲裁<ol><li>链式查询方式</li><li>计数器定时查询方式</li><li>独立请求方式</li></ol></li><li>分布式仲裁</li></ul><h1 id="输入输出系统"><a href="#输入输出系统" class="headerlink" title="输入输出系统"></a>输入输出系统</h1><p>信息交换方式：</p><ul><li>程序查询方式</li><li>程序中断方式</li><li>直接内存访问（DMA）方式</li><li>通道方式</li></ul><p><strong>中断</strong>是指计算机在执行程序过程中，当出现异常或特殊请求时，计算机停止现行程序的运行，转去处理这些异常或特殊请求，处理结束后，再返回现行程序的间断处，继续执行原程序。</p><p>中断服务程序的基本流程：</p><ol><li>保护现场</li><li>中断服务</li><li>恢复现场</li><li>中断返回</li></ol>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="2020/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>2020/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="互联网结构"><a href="#互联网结构" class="headerlink" title="互联网结构"></a>互联网结构</h2><p>从互联网的工作方式上看，网络拓扑结构可以划分为两大块：<strong>边缘部分和核心部分</strong></p><ul><li>边缘部分：由所有连接在互联网上的主机组成，这部分是用户直接使用的。</li><li>核心部分：由大量网络和连接这些网络的路由器组成，这部分是为边缘部分提供服务的。</li></ul><p>在网络端系统之间的通信方式可划分为：<strong>客户-服务器方式（C/S方式）和对等方式（P2P）</strong></p><h2 id="电路、分组和报文交换"><a href="#电路、分组和报文交换" class="headerlink" title="电路、分组和报文交换"></a>电路、分组和报文交换</h2><p>电路交换分为三个阶段：<strong>建立连接、通话、释放连接</strong>。电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。</p><p>分组交换的主要特点：</p><ul><li>采用存储转发技术</li><li>在发送端，先把较长的报文划分成较短的、固定长度的数据段</li><li>一个数据段前面添加上首部构成分组</li></ul><p>报文交换：基于存储转发原理，时延较长，从几分钟到几小时不等。现在报文交换已经很少有人使用了。 </p><p><img src="Three-exchanges.png" alt="三种交换的比较"></p><p><strong>总结：</strong>若要连续传送大量的数据，且其传送时间远大于连接建立时间，则<strong>电路交换</strong>的传输速率较快。<strong>报文交换和分组交换</strong>不需要预先分配传输带宽，在传送突发数据时可提高整个网络的信道利用率。由于一个分组的长度往往远小于整个报文的长度，因此<strong>分组交换</strong>比报文交换的时延小，同时也具有更好的灵活性。</p><h2 id="计算机网络的性能"><a href="#计算机网络的性能" class="headerlink" title="计算机网络的性能"></a>计算机网络的性能</h2><p>计算机网络的性能指标：</p><ul><li><strong>速率</strong>：数据的传送速率，它也称为数据率或比特率</li><li><strong>带宽</strong>：在单位时间内网络中的某信道所能通过的“最高数据率”</li><li><strong>吞吐量</strong>：在单位时间内通过某个网络（或信道、接口）的实际数据量</li><li><strong>时延</strong>：指数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间，由发送时延、传播时延、处理时延和排队时延组成</li><li><strong>时延带宽积</strong>：以比特为单位的链路长度即传播时延 *带宽</li><li><strong>往返时间 RTT</strong>：从发送方发送数据开始，到发送方收到来自接收方的确认，总共经历的时间</li><li><strong>利用率</strong>：分为信道利用率和网络利用率，信道利用率指出某信道有百分之几的时间是被利用的；网络利用率则是全网络的信道利用率的加权平均值</li></ul><p>网络中的<strong>时延</strong>由以下几个不同的部分组成：</p><p>(1) 发送时延：传输时延，发送数据时，数据帧从结点进入到传输媒体所需要的时间。</p><p>(2) 传播时延：电磁波在信道中需要传播一定的距离而花费的时间。</p><p>(3) 处理时延：主机或路由器在收到分组时，为处理分组（例如分析首部、提取数据、差错检验或查找路由）所花费的时间。 </p><p>(4) 排队时延：分组在路由器输入输出队列中排队等待处理所经历的时延。排队时延的长短往往取决于网络中当时的通信量。</p><p><strong>注意：</strong>信道利用率并非越高越好。当某信道的利用率增大时，该信道引起的时延也就迅速增加。</p><h2 id="网络协议三要素"><a href="#网络协议三要素" class="headerlink" title="网络协议三要素"></a>网络协议三要素</h2><p>语法：数据与控制信息的结构或格式</p><p>语义：需要发出任何控制信息，完成何种动作以及做出何种响应</p><p>同步：事件实现顺序的详细说明</p><h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><p><img src="Five-layer-agreement.png" alt="计算机网络体系结构"></p><h3 id="五层协议"><a href="#五层协议" class="headerlink" title="五层协议"></a>五层协议</h3><ul><li>应用层：交互的数据单元为报文，任务是通过应用进程间的交互来完成特定网络应用，如 HTTP、DNS 等协议。</li><li>运输层：负责向两台主机进程之间的通信提供通用的数据传输服务，主要使用 TCP 和 UDP 协议。</li><li>网络层：负责为分组交换网上的不同主机提供通信服务，使用 IP 协议，把运输层传递下来的报文段或者用户数据报封装成分组（IP数据报）。</li><li>数据链路层：为同一链路的主机提供数据传输服务，将网络层交下来的 IP 数据报封装成帧，在两个相邻结点间的链路上传送帧。</li><li>物理层：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</li></ul><h3 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h3><p>它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。</p><p>TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</p><h3 id="OSI协议"><a href="#OSI协议" class="headerlink" title="OSI协议"></a>OSI协议</h3><p>其中表示层和会话层用途如下：</p><ul><li><p>表示层 ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。</p></li><li><p>会话层 ：建立及管理会话，查木马(netstat -n)。</p></li></ul><p>五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。</p><h3 id="数据在层间传递过程"><a href="#数据在层间传递过程" class="headerlink" title="数据在层间传递过程"></a>数据在层间传递过程</h3><p>在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。</p><p>路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。</p><h3 id="协议和服务"><a href="#协议和服务" class="headerlink" title="协议和服务"></a>协议和服务</h3><p>本层的服务用户只能看见服务而无法看见下面的协议。即下面的协议对上面的服务用户是透明的。</p><p><strong>协议是“水平的”</strong>，即协议是控制对等实体之间通信的规则。</p><p><strong>服务是“垂直的”</strong>，即服务是由下层向上层通过层间接口提供的。</p><p>上层使用服务原语获得下层所提供的服务。</p><h3 id="分层的优缺点"><a href="#分层的优缺点" class="headerlink" title="分层的优缺点"></a>分层的优缺点</h3><p><strong>好处如下：</strong></p><ol><li>各层之间相互独立：高层是不需要知道底层的功能是采取何种硬件技术实现的，它只需要知道通过与底层的接口就可以获得所需要的服务。</li><li>灵活性好：各层都可以采用最适当的技术来实现，例如某一层的实现技术发生了变化，只要这一层的功能与接口保持不变，实现技术的变化都并不会对其他各层以及整个系统的工作产生影响。</li><li>易于实现和标准化：采取了规范的层次结构去组织网络功能与协议，可以将计算机网络复杂的通信过程划分为有序的连续动作与有序的交互过程，有利于将网络复杂的通信工作过程化解为一系列可以控制和实现的功能模块，使得复杂的计算机网络系统变得易于设计，实现和标准化。</li></ol><p><strong>缺点如下：</strong></p><ol><li>降低效率。</li><li>有些功能会在不同的层次中重复出现，因而产生了额外开销。</li></ol><h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>物理层考虑的是怎样才能在连接各种计算机的传输媒体上<em>传输数据比特流</em>，而不是指具体的<em>传输媒体</em>，尽可能地屏蔽掉不同传输媒体和通信手段的差异。</p><ul><li>机械特性</li><li>电气特性</li><li>功能特性</li><li>过程特性</li></ul><h2 id="数据通信的基础知识"><a href="#数据通信的基础知识" class="headerlink" title="数据通信的基础知识"></a>数据通信的基础知识</h2><p>一个数据通信系统包括三大部分：<strong>源系统（或发送端、发送方）、传输系统（或传输网络）和目的系统（或接收端、接收方）</strong></p><ul><li>单向通信（单工）——只能有一个方向的通信而没有反方向的交互</li><li>双向交替通信（半双工）——通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)</li><li>双向同时通信（全双工）——通信的双方可以同时发送和接收信息</li></ul><p>基带信号（即基本频带信号）—— 来自信源的信号</p><p>调制分为两大类：</p><ul><li>基带调制——仅对基带信号的波形进行变换，使它能够与信道特性相适应。变换后的信号仍然是基带信号，这种过程也称为编码 (coding)</li><li>带通调制——使用载波进行调制，把基带信号的频率范围搬移到较高的频段，并转换为模拟信号经过载波调制后的信号称为<em>带通信号</em> </li></ul><p>常用编码方式</p><ul><li>不归零制：正电平代表 1，负电平代表 0</li><li>归零制：正脉冲代表 1，负脉冲代表 0</li><li>曼彻斯特编码：位周期中心的向上跳变代表 0，位周期中心的向下跳变代表 1。也可反过来定义</li><li>差分曼彻斯特编码：在每一位的中心处始终都有跳变。位开始边界有跳变代表 0，而位开始边界没有跳变代表 1</li></ul><p><img src="Encoding.png" alt="数字信号常用的编码方式"></p><p>限制码元在信道上的传输速率的因素有两个：</p><ul><li><strong>信道能够通过的频率范围</strong><br>在任何信道中，码元传输的速率是有上限的，否则就会出现码间串扰的问题，使接收端对码元的判决（即识别）成为不可能。</li><li><strong>信噪比</strong><br>信噪比就是信号的平均功率和噪声的平均功率之比。常记为 S/N，并用分贝 (dB) 作为度量单位。即：信噪比(dB) = 10 log10(S/N)    (dB)<br>信道的极限信息传输速率 C 可表达为：C = W log2(1+S/N)    (bit/s)<br>其中：W 为信道的带宽（以 Hz 为单位）；S 为信道内所传信号的平均功率；N 为信道内部的高斯噪声功率。  </li></ul><p><strong>香农公式</strong>表明：信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高；只要信息传输速率低于信道的极限信息传输速率，就一定可以找到某种办法来实现无差错的传输。 </p><h2 id="物理层下面的传输媒体"><a href="#物理层下面的传输媒体" class="headerlink" title="物理层下面的传输媒体"></a>物理层下面的传输媒体</h2><p>导引型传输媒体：</p><ol><li>双绞线</li><li>同轴电缆</li><li>光缆</li></ol><p>非导引型传输媒体——自由空间</p><h2 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h2><p>将一条物理信道分割成多条逻辑信道，即使用一个共享信道进行通信。</p><p><strong>1.频分复用</strong></p><p>频分复用的所有用户在同样的时间占用不同的带宽资源<img src="FDM.png" alt="频分复用"></p><p><strong>2.时分复用</strong></p><p>时分复用的所有用户在不同的时间占用同样的频带宽度<img src="TDM.png" alt="时分复用"></p><p><img src="TDM1.png"></p><p><strong>3.统计时分复用</strong> </p><p>统计时分复用是一种改良的时分复用<img src="STDM.png" alt="统计时分复用"></p><p><strong>4.波分复用</strong></p><p>波分复用就是光的频分复用。使用一根光纤来同时传输多个光载波信号。</p><p><strong>5.码分复用</strong></p><p>每一个比特时间划分为 m 个短的间隔，称为<em>码片</em></p><p>每个站被指派一个唯一的 m bit 码片序列：</p><ul><li>如发送比特 1，则发送自己的 m bit 码片序列</li><li>如发送比特 0，则发送该码片序列的二进制反码</li></ul><p>每个站分配的码片序列不仅必须各不相同，并且还必须<em>互相正交</em> <img src="Normalized-inner-product.png"></p><p><img src="CDMA.png" alt="CDMA 的工作原理 "></p><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><h2 id="点对点信道的数据链路层"><a href="#点对点信道的数据链路层" class="headerlink" title="点对点信道的数据链路层"></a>点对点信道的数据链路层</h2><h3 id="数据链路和帧"><a href="#数据链路和帧" class="headerlink" title="数据链路和帧"></a>数据链路和帧</h3><p>链路 (link) 是一条无源的点到点的物理线路段，中间没有任何其他的交换结点。</p><p>数据链路 (data link) 除了物理线路外，还必须有通信协议来控制这些数据的传输。</p><p>数据链路层的协议数据单元——<strong>帧</strong></p><h3 id="三个基本问题"><a href="#三个基本问题" class="headerlink" title="三个基本问题"></a>三个基本问题</h3><ul><li>封装成帧</li><li>透明传输</li><li>差错检测</li></ul><p><strong>1.封装成帧</strong></p><p>在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。确定帧的界限（帧定界）<img src="Encapsulation.png" alt="用帧首部和帧尾部封装成帧"></p><p>控制字符 SOH (Start Of Header) 表示帧的首部开始；</p><p>控制字符 EOT (End Of Transmission) 表示帧的结束；</p><p><strong>2.透明传输</strong></p><p>无论什么样的比特组合的数据，都能够按照原样没有差错地通过数据链路层。</p><p>如果数据中的某个字节的二进制代码恰好和 SOH 或 EOT 一样，数据链路层就会错误地“找到帧的边界”。</p><p>解决方法：字节填充或字符填充——插入一个转义字符 <strong>“ESC”</strong> <img src="Byte-padding.png" alt="用字节填充法解决透明传输的问题"></p><p><strong>3.差错检测</strong></p><p>在传输过程中可能会产生比特差错：1 可能会变成 0 而 0 也可能变成 1。在一段时间内，传输错误的比特占所传输比特总数的比率称为误码率 BER。</p><p><code>循环冗余检验 CRC</code> </p><ol><li>假设待传送的一组数据 M = 101001（现在 k = 6）</li><li>用二进制的模 2 运算进行 2^n 乘 M 的运算，这相当于在 M 后面添加 n 个 0</li><li>得到的 (k + n) 位的数除以事先选定好的长度为 (n + 1) 位的除数 P，得出商是 Q 而余数是 R，余数 R 比除数 P 少 1 位，即 R 是 n 位</li><li>将余数 R 作为冗余码拼接在数据 M 后面发送出去<img src="CRC.png" alt="循环冗余检验例子"></li></ol><p><strong>无差错接受是指：</strong>凡是接受的帧（即不包括丢弃的帧），我们都能以非常接近于 1 的概率认为这些帧在传输过程中没有产生差错。</p><h2 id="点对点协议-PPP"><a href="#点对点协议-PPP" class="headerlink" title="点对点协议 PPP"></a>点对点协议 PPP</h2><p>PPP 协议有三个组成部分：</p><ul><li>一个将 IP 数据报封装到串行链路的方法。</li><li>一个建立、配置和测试数据链路连接的链路控制协议 LCP。</li><li>一套支持不同的网络层协议的网络控制协议 NCP。   </li></ul><p>PPP 帧的首部和尾部分别为 4 个字段和 2 个字段；标志字段 F = 0x7E；</p><p>PPP 是面向字节的，所有的 PPP 帧的长度都是整数字节<img src="PPP.png" alt="PPP 帧格式"></p><p>透明传输问题——字节填充和零比特填充 </p><h2 id="广播信道的数据链路层"><a href="#广播信道的数据链路层" class="headerlink" title="广播信道的数据链路层"></a>广播信道的数据链路层</h2><h3 id="CSMA-CD-协议"><a href="#CSMA-CD-协议" class="headerlink" title="CSMA/CD 协议"></a>CSMA/CD 协议</h3><p>CSMA/CD 含义：载波监听多点接入 / 碰撞检测 </p><ul><li>“多点接入”表示许多计算机以多点接入的方式连接在一根总线上</li><li>“载波监听”是指每一个站在发送数据之前，用电子技术不停地检测总线上有没有其他计算机发送的数据信号，如果有，则暂时不要发送数据，以免发生碰撞。 </li><li>“碰撞检测”就是计算机边发送数据边检测信道上的信号电压大小。每一个正在发送数据的站，一旦发现总线上出现了碰撞，就要立即停止发送，然后等待一段随机时间后再次发送。<img src="CSMACD.png"></li></ul><p>使用 CSMA/CD 协议的以太网不能进行全双工通信而只能进行<strong>双向交替通信</strong>（半双工通信）</p><p><img src="Contention-period.png" alt="争用期"></p><p>二进制指数类型退避算法：</p><ol><li>基本退避时间取为争用期 51.2 us（最短帧长64 B = 512 bit）</li><li>从整数集合[0,1,…, (2^k - 1)]中随机地取出一个数，记为 r。重传所需的时延就是 r 倍的基本退避时间，其中 k = Min[重传次数, 10]</li><li>当 k &lt;= 10 时，参数 k 等于重传次数，当重传达 16 次仍不能成功时即丢弃该帧，并向高层报告</li></ol><p><strong>强化碰撞</strong>——当发送数据的站一旦发现发生了碰撞时：</p><ul><li>立即停止发送数据</li><li>继续发送若干比特的人为干扰信号，以便让所有用户都知道现在已经发生了碰撞。  </li></ul><p><strong>CSMA/CD 协议的要点</strong></p><ol><li>准备发送。在发送之前，必须先检测信道</li><li>检测信道。若检测到信道忙，则应不停地检测，一直等待信道转为空闲。若检测到信道空闲，并在 96 比特时间（帧间最小间隔）内信道保持空闲，就发送这个帧</li><li>检查碰撞。在发送过程中仍不停地检测信道，即网络适配器要边发送边监听。这里只有两种可能性：<ul><li>发送成功：在争用期内一直未检测到碰撞。这个帧肯定能够发送成功。发送完毕后，其他什么也不做。然后回到 1</li><li>发送失败：在争用期内检测到碰撞。这时立即停止发送数据，并按规定发送人为干扰信号。适配器接着就执行指数退避算法，等待 r 倍 512 比特时间后，返回到步骤 2，继续检测信道。但若重传达 16 次仍不能成功，则停止重传而向上报错</li></ul></li></ol><h3 id="使用集线器的星形拓扑"><a href="#使用集线器的星形拓扑" class="headerlink" title="使用集线器的星形拓扑"></a>使用集线器的星形拓扑</h3><p>集线器的一些特点：</p><ul><li>使用集线器的以太网在逻辑上仍是一个总线网，各工作站使用的还是 CSMA/CD 协议，并共享逻辑上的总线</li><li>集线器很像一个多接口的转发器，工作在<em>物理层</em></li></ul><h3 id="以太网的-MAC-层"><a href="#以太网的-MAC-层" class="headerlink" title="以太网的 MAC 层"></a>以太网的 MAC 层</h3><p>硬件地址又称为物理地址或 MAC 地址。类型字段用来标志上一层使用的是什么协议。</p><p>MAC 地址是链路层地址，<strong>长度为 6 字节（48 位）</strong>，用于唯一标识网络适配器（网卡）。</p><p>一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址</p><p><strong>MAC 帧的格式</strong> <img src="MAC.png" alt="以太网 V 2的 MAC 帧格式"></p><p>无效的 MAC 帧:</p><ul><li>帧的长度不是整数个字节</li><li>用收到的帧检验序列 FCS 查出有差错</li><li>数据字段的长度不在 46 ~ 1500 字节之间，有效的 MAC 帧长度为 64 ~ 1518 字节之间</li></ul><h2 id="扩展的以太网"><a href="#扩展的以太网" class="headerlink" title="扩展的以太网"></a>扩展的以太网</h2><p><strong>1.网桥</strong></p><ul><li>它根据 MAC 帧的目的地址对收到的帧进行转发和过滤 </li><li>工作在数据链路层</li><li>当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的 MAC 地址，然后再确定将该帧转发到哪一个接口，或把它丢弃</li></ul><p><strong>2.交换机</strong></p><ul><li>以太网交换机实质上就是一个多接口的网桥</li><li>根据 MAC 地址转发，有<em>存储转发</em> 方式和<em>直通</em> 方式</li><li>全双工方式工作在数据链路层</li><li>以太网交换机具有并行性，用户独享带宽</li><li><em>自学习功能</em></li></ul><p><strong>3.集线器</strong></p><ul><li>多个端口的转发器</li><li>半双工方式工作在物理层</li><li>工作原理广播形式</li><li>用户共享带宽</li></ul><p><strong>虚拟局域网</strong>——VLAN 是由一些局域网网段构成的与物理位置无关的逻辑组，而这些网段具有某些共同的需求。</p><p><img src="VLAN.png" alt="三个虚拟局域网"></p><p>虚拟局域网协议允许在以太网的帧格式中插入一个4字节的标识符，称为 VLAN 标记 (tag)，用来指明发送该帧的计算机属于哪一个虚拟局域网。</p><p><img src="VLAN-8021Q.png"></p><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="网际协议-IP"><a href="#网际协议-IP" class="headerlink" title="网际协议 IP"></a>网际协议 IP</h2><p>网际协议 IP 是 TCP/IP 体系中两个最主要的协议之一</p><p>与 IP 协议配套使用的还有三个协议：</p><ul><li>地址解析协议 ARP</li><li>网际控制报文协议 ICMP</li><li>网际组管理协议 IGMP</li></ul><h3 id="分类的-IP-地址"><a href="#分类的-IP-地址" class="headerlink" title="分类的 IP 地址"></a>分类的 IP 地址</h3><p><img src="IP.png" alt="IP地址结构"></p><p><img src="IP-classification.png" alt="各类 IP 地址"></p><h3 id="地址解析协议-ARP"><a href="#地址解析协议-ARP" class="headerlink" title="地址解析协议 ARP"></a>地址解析协议 ARP</h3><p><strong>IP 地址与硬件地址：</strong></p><ul><li>硬件地址是数据链路层和物理层使用的地址</li><li>IP 地址是网络层和以上各层使用的地址，是一种逻辑地址（IP 地址是用软件实现的）</li></ul><p> 网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。</p><p>ARP从网络层使用的 IP 地址，解析出在数据链路层使用的硬件地址</p><p><img src="ARP.png"></p><p>每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。</p><p>ARP 是解决同一个局域网上的主机或路由器的 IP 地址和硬件地址的映射问题。</p><h3 id="IP-数据报"><a href="#IP-数据报" class="headerlink" title="IP 数据报"></a>IP 数据报</h3><p>一个 IP 数据报由首部和数据两部分组成，首部的前一部分是固定长度，共 20 字节。</p><p><img src="IP-composition.png" alt="IP数据报组成"></p><ul><li><strong>版本</strong> : 有 4（IPv4）和 6（IPv6）两个值；</li><li><strong>首部长度</strong> : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。首部长度的最大值是 60 字节，如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</li><li><strong>区分服务</strong> : 用来获得更好的服务，一般情况下不使用。</li><li><strong>总长度</strong> : 包括首部长度和数据部分长度。数据报的最大长度为 65535 字节。</li><li><strong>标识</strong> : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</li><li><strong>标志</strong>：目前只有两位有意义，最低位是 MF ，MF = 1 表示后面“还有分片”。MF = 0 表示最后一个分片。标志字段中间的一位是 DF ，只有当 DF =0 时才允许分片。</li><li> <strong>片偏移</strong> : 和标识符一起，用于发生分片的情况，较长的分组在分片后某片在原分组中的相对位置。片偏移的单位为 8 字节。</li><li><strong>生存时间</strong> ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</li><li><strong>协议</strong> ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</li><li><strong>首部检验和</strong> ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。</li></ul><p><img src="IP-Fragmentation.png"></p><h2 id="划分子网和无分类编址"><a href="#划分子网和无分类编址" class="headerlink" title="划分子网和无分类编址"></a>划分子网和无分类编址</h2><p>通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。</p><p>要使用子网，必须配置子网掩码。</p><p>子网掩码——将 IP 地址的主机号进行子网划分。把子网掩码和 IP 地址进行逐位的与运算，就立即得出网络地址。</p><p>一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。</p><p><img src="Subnetting.png" alt="划分子网"></p><p>无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。</p><p>无分类编制<strong>CIDR</strong> 使用“斜线记法”，它又称为 CIDR 记法，即在 IP 地址面加上一个斜线“/”，然后写上网络前缀所占的位数。例如： 220.78.168.0 / 24</p><p>一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 <strong>构成超网</strong> 。</p><h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><p>为了更有效地转发 IP 数据报和提高交付成功的机会，在网际层使用了网际控制报文协议 ICMP。ICMP 封装在 IP 数据报中，不是高层协议，而是 IP 层的协议。</p><p>ICMP 差错报告报文共有 4 种 </p><ol><li>终点不可达 </li><li>时间超过 </li><li>参数问题 </li><li>改变路由（重定向）</li></ol><h3 id="PING"><a href="#PING" class="headerlink" title="PING"></a>PING</h3><p>Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。</p><p>Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。</p><h3 id="Traceroute"><a href="#Traceroute" class="headerlink" title="Traceroute"></a>Traceroute</h3><p>Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。</p><p>Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。</p><ul><li>源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；</li><li>源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 <strong>ICMP 时间超过</strong>差错报文。</li><li>不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 <strong>ICMP 终点不可达</strong>差错报告报文。</li><li>之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</li></ul><h2 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h2><h3 id="内部网关协议-RIP"><a href="#内部网关协议-RIP" class="headerlink" title="内部网关协议 RIP"></a>内部网关协议 RIP</h3><p>RIP 是一种分布式的基于距离向量的路由选择协议。</p><p>RIP 协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录。 </p><p>RIP 协议中的“距离”也称为“跳数”：</p><ul><li>从一个路由器到直接连接的网络的距离定义为 1</li><li>从一个路由器到非直接连接的网络的距离定义为所经过的路由器数加 1</li></ul><p>RIP 允许一条路径最多只能包含 15 个路由器。“距离”的最大值为 16 时即相当于不可达。</p><p>距离向量算法：</p><ol><li>对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1；</li><li>对修改后的 RIP 报文中的每一个项目，进行以下步骤：<ul><li>若原来的路由表中没有目的网络 N，则把该项目添加到路由表中；</li><li>否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。</li></ul></li><li>若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。</li><li>返回。</li></ol><p><strong>RIP协议特点：好消息传播得快，坏消息传播得慢</strong></p><ul><li>仅和相邻路由器交换信息</li><li>交换的信息是当前本路由器所知道的全部信息 </li><li>按固定的时间间隔交换路由信息</li></ul><p>RIP 协议实现简单，开销较小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器，使更新过程的收敛时间过长。</p><h3 id="内部网关协议-OSPF"><a href="#内部网关协议-OSPF" class="headerlink" title="内部网关协议 OSPF"></a>内部网关协议 OSPF</h3><p>OSPF 的原理很简单，但实现起来却较复杂。最短路径优先”是因为使用了 Dijkstra 提出的最短路径算法 SPF。</p><p>OSPF 最主要的特征就是使用分布式的链路状态协议：</p><ul><li>向本自治系统中所有路由器发送信息（洪泛法）</li><li>发送的信息就是与本路由器相邻的所有路由器的链路状态</li><li>只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息</li></ul><p>各路由器之间频繁地交换链路状态信息，因此所有的路由器最终都能建立一个链路状态数据库。实际上就是全网的拓扑结构图，它在全网范围内是一致的。</p><p>OSPF 的更新过程收敛得快是其重要优点。OSPF 不用 UDP 而是直接用 IP 数据报传送，构成的数据报很短，减少路由信息的通信量；可以不必将长的数据报分片传送。</p><h3 id="外部网关协议-BGP"><a href="#外部网关协议-BGP" class="headerlink" title="外部网关协议 BGP"></a>外部网关协议 BGP</h3><p>BGP 是不同自治系统的路由器之间交换路由信息的协议。 </p><p>BGP 只能是力求寻找一条能够到达目的网络且比较好的路由（不能兜圈子），而并非要寻找一条最佳路由。  </p><p>每一个自治系统的管理员要选择至少一个路由器作为该自治系统的“ BGP 发言人”。</p><p>一个 BGP 发言人与其他自治系统中的 BGP 发言人要交换路由信息，就要先<strong>建立 TCP 连接</strong>，然后在此连接上交换 BGP 报文以建立 BGP 会话，利用 BGP 会话交换路由信息。</p><p>在BGP 刚刚运行时，BGP 的邻站是交换整个的 BGP 路由表。但以后只需要在发生变化时更新有变化的部分。节省网络带宽和减少路由器的处理开销。 </p><h3 id="三种协议辨析"><a href="#三种协议辨析" class="headerlink" title="三种协议辨析"></a>三种协议辨析</h3><p><strong>RIP使用UDP，OSPF使用IP，而BGP使用TCP的原因？</strong></p><ul><li>RIP协议采用UDP是因为RIP每周期需全网组播路由信息，路由信息数目较大，UDP虽不保证可靠交付，但开销小可以提高效率。</li><li>OSPF本身提供主从协商机制，可以保证可靠的传输，另外全网路由器保持着同样的一个LSDB（链路状态数据库），当拓扑发生变化时，需要携带的变更信息较少，通过IP协议即可完成。</li><li>BGP为边界网关协议，因携带的路由信息较多，且可能跨不同网络传送路由信息，为保证可靠性，需使用TCP协议，可兼顾容量和可靠性</li></ul><p><strong>为什么RIP周期性地和邻站交换路由信息而BGP却不这样做？</strong></p><p>内部网关协议主要是设法使数据报在一个自治系统中尽可能有效的从源站传送到目的站，在一个自治系统内部并不需要考虑其他方面的策略，然而BGP使用的环境却不同。</p><p>主要有以下三个原因：</p><p>第一，因特网规模太大，使得自治系统之间的路由选择非常困难；</p><p>第二，对于自治系统之间的路由选择，要寻找最佳路径并不现实；</p><p>第三，自治系统之间的路由选择必要考虑有关策略。</p><p>由于上述情况，BGP只能是力求寻找一条能够到达目的网络且比较好的路由，而并非要寻找一条最佳路径，所以BGP不需要像RIP那样周期性地和邻站交换路由信息。</p><h2 id="虚拟专用网-VPN"><a href="#虚拟专用网-VPN" class="headerlink" title="虚拟专用网 VPN"></a>虚拟专用网 VPN</h2><p>由于 IP 地址的紧缺，一个机构能够申请到的IP地址数往往远小于本机构所拥有的主机数。考虑到互联网并不很安全，一个机构内也并不需要把所有的主机接入到外部的互联网。</p><p>利用公用的互联网作为本机构各专用网之间的通信载体，这样的专用网又称为<strong>虚拟专用网VPN</strong>。</p><p>有三个专用地址块：</p><ul><li>10.0.0.0 ~ 10.255.255.255（A类，或记为10.0.0.0/8，它又称为24位块）</li><li>172.16.0.0 ~ 172.31.255.255（B类，或记为172.16.0.0/12，它又称为20位块）</li><li>192.168.0.0 ~ 192.168.255.255（C类，或记为192.168.0.0/16，它又称为16位块）</li></ul><h2 id="网络地址转换-NAT"><a href="#网络地址转换-NAT" class="headerlink" title="网络地址转换 NAT"></a>网络地址转换 NAT</h2><p>在专用网连接到互联网的路由器上安装 NAT 软件。装有 NAT 软件的路由器叫作 NAT路由器，它至少有一个有效的外部全球IP地址。</p><p>所有使用本地地址的主机在和外界通信时，都要在 NAT 路由器上将其本地地址转换成全球 IP 地址，才能和互联网连接。  </p><h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h1><p> 运输层向它上面的应用曾提供通信服务。它属于面向通信部分的最高层，同时也是用户功能中的最低层。</p><p>通信的真正的端点并不是主机而是主机中的进程。运输层提供了进程间的逻辑通信，向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个运输层实体之间有一条端到端的逻辑通信信道。</p><p>运输层的两个主要协议：<strong>用户数据报协议 UDP 和 传输控制协议 TCP</strong> </p><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>用户数据报协议 UDP 特点：</p><ul><li>UDP 是无连接的</li><li>UDP 使用尽最大努力交付</li><li>UDP 是面向报文的（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部，就向下交付 IP 层，一次发送一个报文）</li><li>UDP 没有拥塞控制</li><li>UDP 支持一对一、一对多、多对一和多对多的交互通信</li><li>UDP 的首部开销小</li></ul><p><img src="UDP.png" alt="UDP 的首部格式 "></p><p>首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。</p><p>虽然在 UDP 之间的通信要用到其端口号，但由于 UDP 的通信是无连接的，因此不需要使用套接字。</p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="TCP-特点"><a href="#TCP-特点" class="headerlink" title="TCP 特点"></a>TCP 特点</h3><ul><li>TCP 是面向连接的运输层协议</li><li>每一条 TCP连接只能是点对点的</li><li>TCP 提供可靠的交付服务</li><li>TCP 提供全双工通信</li><li>面向字节流<ul><li>TCP 中的“流”指的是流入或流出进程的字节序列。</li><li>“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个大小不等的数据块，但 TCP 把应用程序交下来的数据看成仅仅是一连串无结构的字节流。</li><li>TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP也可以等待积累有足够多的字节后再构成报文段发送出去。</li></ul></li></ul><h3 id="TCP-的连接"><a href="#TCP-的连接" class="headerlink" title="TCP 的连接"></a>TCP 的连接</h3><p>TCP 把连接作为最基本的抽象，每一条 TCP 连接有两个端点。</p><p>TCP 连接的端点叫做<strong>套接字 (socket) 或插口</strong>。套接字 socket = (IP地址 : 端口号)      </p><p>同一个 IP 地址可以有多个不同的 TCP 连接。同一个端口号也可以出现在多个不同的 TCP 连接中。         </p><h3 id="可靠传输原理"><a href="#可靠传输原理" class="headerlink" title="可靠传输原理"></a>可靠传输原理</h3><p>理想的传输条件有以下两个特点：</p><ul><li>传输信道不产生差错。</li><li>不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据</li></ul><p>然而实际的网络都不具备以上两个理想条件。必须使用一些可靠传输协议，在不可靠的传输信道实现可靠传输。下文介绍<strong>停止等待协议和连续 ARQ 协议</strong>。</p><h4 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h4><p>“停止等待”就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。停止等待协议的优点是简单，缺点是信道利用率太低。</p><ol><li><p><strong>无差错情况</strong></p><p>A 发送分组 M1，发完就暂停发送，等待 B 的确认 (ACK)。B 收到了 M1 向 A 发送  ACK。A 在收到了对 M1 的确认后，就再发送下一个分组  M2。</p></li><li><p><strong>出现差错</strong></p><p>在接收方 B 会出现两种情况：（1）B 接收 M1 时检测出了差错，就丢弃 M1。（2）M1 在传输过程中丢失了。</p><p>在这两种情况下，B 都不会发送任何信息。解法方法：超时重传</p><ul><li>A 为每一个已发送的分组都设置了一个超时计时器</li><li>A 只要在超时计时器到期之前收到了相应的确认，就撤销该超时计时器，继续发送下一个分组 M2 </li></ul></li><li><p><strong>确认丢失和确认迟到</strong></p><p>B 所发送的对 M1 的确认丢失了，那么 A 在设定的超时重传时间内不能收到确认。因此 A 在超时计时器到期后就要重传 M1。</p><p>假定 B 又收到了重传的分组 M1。这时 B 应采取两个行动：</p><ul><li>第一，丢弃这个重复的分组 M1，不向上层交付。</li><li>第二，向 A 发送确认。</li></ul><p>传输过程中没有出现差错，但 B 对分组 M1 的确认迟到了。A 会收到重复的确认。对重复的确认的处理很简单：收下后就丢弃。B 仍然会收到重复的 M1，并且同样要丢弃重复的 M1，并重传确认分组。</p></li></ol><p>应注意以下三点：</p><ul><li>在发送完一个分组后，必须暂时保留已发送的分组的副本，以备重发。</li><li>分组和确认分组都必须进行编号。</li><li>超时计时器的重传时间应当比数据在分组传输的平均往返时间更长一些。 </li></ul><p>使用上述的确认和重传机制，我们就可以在不可靠的传输网络上实现可靠的通信。像上述的这种可靠传输协议常称为<strong>自动重传请求 ARQ</strong> 。意思是重传的请求是自动进行的，接收方不需要请求发送方重传某个出错的分组。</p><h4 id="连续-ARQ-协议"><a href="#连续-ARQ-协议" class="headerlink" title="连续 ARQ 协议"></a>连续 ARQ 协议</h4><p>发送方维持的发送窗口，位于发送窗口内的分组都可连续发送出去，而不需要等待对方的确认。</p><p>连续 ARQ 协议规定，发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。</p><p>接收方一般采用累积确认的方式。即不必对收到的分组逐个发送确认，而是对按序到达的最后一个分组发送确认，这样就表示：到这个分组为止的所有分组都已正确收到了。</p><ul><li>优点：容易实现，即使确认丢失也不必重传。</li><li>缺点：不能向发送方反映出接收方已经正确收到的所有分组的信息。（存在未按序到达的）</li></ul><h3 id="TCP首部格式"><a href="#TCP首部格式" class="headerlink" title="TCP首部格式"></a>TCP首部格式</h3><p><img src="TCP.png" alt="TCP 的首部格式 "></p><ul><li><strong>源端口和目的端口</strong>：端口是运输层与应用层的服务接口，运输层的复用和分用功能都要通过端口才能实现</li><li><strong>序号</strong>：指的是本报文段所发送的数据的第一个字节的序号</li><li><strong>确认号</strong>：期望收到 对方的下一个报文段的数据的第一个字节的序号</li><li><strong>数据偏移</strong>： TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远</li><li><strong>保留</strong>字：保留为今后使用，但目前应置为 0</li><li><strong>紧急 URG</strong> = 1 时，表明紧急指针字段有效，告诉系统此报文段中有紧急数据，应尽快传送</li><li><strong>确认 ACK =</strong> 1 时，确认号字段才有效，TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1</li><li><strong>推送 PSH</strong> = 1 时，尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付</li><li><strong>复位 RST</strong> = 1 时，TCP 连接中出现严重差错，必须释放连接，然后再重新建立运输连接</li><li><strong>同步 SYN</strong> = 1 时，这是一个连接请求或连接接受报文</li><li><strong>终止 FIN</strong> = 1 时，此报文段的发送端的数据已发送完毕，并要求释放运输连接</li><li><strong>窗口</strong>：用来让对方设置发送窗口，因为接收方的数据缓存空间是有限</li><li><strong>检验和</strong>：检验的范围包括首部和数据这两部分</li><li><strong>紧急指针</strong>：指出在本报文段中紧急数据共有多少个字节</li><li><strong>选项</strong>：最大报文段长度 MSS、窗口扩大选项、时间戳选项、选择确认选项</li><li><strong>填充</strong>：使整个首部长度是 4 字节的整数倍</li></ul><h2 id="TCP-可靠传输实现"><a href="#TCP-可靠传输实现" class="headerlink" title="TCP 可靠传输实现"></a>TCP 可靠传输实现</h2><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>TCP 的滑动窗口是以字节为单位。</p><p>假定 A 收到了 B 发来的确认报文段，其中窗口是 20 字节，而确认号是 31。根据这两个数据，A 就构造出自己的发送窗口。</p><p><strong>发送窗口表示</strong>：在没有收到 B 的确认的情况下，A 可以连续把窗口内的数据都发送出去。 发送窗口里面的序号表示允许发送的序号。</p><p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p><p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p><p><strong>发送缓存用来暂时存放：</strong></p><ul><li>发送应用程序传送给发送方 TCP 准备发送的数据</li><li>TCP 已发送出但尚未收到确认的数据</li></ul><p><strong>接收缓存用来暂时存放：</strong></p><ul><li>按序到达的、但尚未被接收应用程序读取的数据</li><li>不按序到达的数据。</li></ul><h3 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h3><p>TCP 采用了一种自适应算法，它记录一个报文段发出的时间，以及收到相应的确认的时间。这两个时间之差就是报文段的往<strong>返时间 RTT</strong>。</p><p>TCP 保留了 RTT 的一个加权平均往返时间 RTTs（这又称为平滑的往返时间）。</p><p>第一次测量到 RTT 样本时，RTTs 值就取为所测量到的 RTT 样本值。以后每测量到一个新的 RTT 样本，就按下式重新计算一次 RTTs：</p><ul><li>RTTs = (1-a) * RTTs + a * RTT</li></ul><p>式中，0 &lt;=a&lt;= 1。若 a 很接近于零，表示 RTT 值更新较慢。若选择 a 接近于 1，则表示 RTT 值更新较快。RFC 2988 推荐的 a 值为 1/8。</p><p><strong>超时重传时间 RTO</strong> 应略大于上面得出的加权平均往返时间 RTTS。</p><ul><li>RTO = RTTs + 4 * RTTd</li></ul><p> RTTd 是 RTT 的偏差的加权平均值。第一次测量时，RTTd 值取为测量到的 RTT 样本值的一半。在以后的测量中，则使用下式计算加权平均的 RTTd：</p><ul><li>RTTd = (1-b) * RTTd + b * |RTTs-RTT|</li></ul><p>b 是个小于 1 的系数，其推荐值是 1/4。</p><p><strong>Karn 算法</strong>：在计算平均往返时间 RTT 时，只要报文段重传了，就不采用其往返时间样本。                     </p><p>但是，这又引起新的问题。当报文段的时延突然增大了很多时，在原来得出的重传时间内，不会收到确认报文段。于是就重传报文段。但根据 Karn 算法，不考虑重传的报文段的往返时间样本。这样，超时重传时间就无法更新。</p><p><strong>修正的 Karn 算法</strong>：报文段每重传一次，就把 RTO 增大一些，典型值是 2 倍。</p><p>当不再发生报文段的重传时，才根据报文段的往返时延更新平均往返时延 RTT 和超时重传时间 RTO 的数值。</p><h3 id="选择确认"><a href="#选择确认" class="headerlink" title="选择确认"></a>选择确认</h3><p>若收到的报文段无差错，只是未按序号，中间还缺少一些序号的数据，那么能否设法只传送缺少的数据而不重传已经正确到达接收方的数据？</p><p>选择确认 SACK就是一种可行的处理方法。</p><p>接收方收到了和前面的字节流不连续的两个字节块，如果这些字节的序号都在接收窗口之内，那么接收方就先收下这些数据，但要把这些信息准确地告诉发送方，使发送方不要再重复发送这些已收到的数据。</p><h2 id="TCP-的流量控制"><a href="#TCP-的流量控制" class="headerlink" title="TCP 的流量控制"></a>TCP 的流量控制</h2><p>流量控制就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。</p><p>发送方的发送窗口不能超过接收方给出的接收窗口的数值。</p><p>TCP 的窗口单位是字节，不是报文段。</p><h2 id="TCP-的拥塞控制"><a href="#TCP-的拥塞控制" class="headerlink" title="TCP 的拥塞控制"></a>TCP 的拥塞控制</h2><p>拥塞——在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。</p><p>网络拥塞往往是由许多因素引起的。例如：</p><ul><li>存储空间限制；</li><li>带宽容量的限制；</li><li>处理器性能限制；</li><li>复杂的网络结构；</li><li>不合理的路由原则。</li></ul><p><strong>拥塞控制与流量控制的区别：</strong></p><ul><li>拥塞控制就是防止过多的数据注入到网络中，使网络中的路由器或链路不致过载。</li><li>拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。</li><li>拥塞控制是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。 </li><li>流量控制往往指点对点通信量的控制，是个端到端的问题。</li><li>流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。 </li></ul><p>TCP 采用基于窗口的方法进行拥塞控制。该方法属于闭环控制方法。</p><p>TCP发送方维持一个拥塞窗口 cwnd，设置慢开始门限 ssthresh：</p><ul><li>慢开始（cwnd &lt; ssthresh、超时 ）</li><li>拥塞避免（cwnd &gt;= ssthresh ）</li><li>快重传和快恢复（3-ACK）</li></ul><p><img src="Congestion-control.png" alt="TCP 的拥塞控制"></p><ol><li><p><strong>慢开始与拥塞避免</strong></p><p>发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</p><p>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</p><p>如果出现了超时，则令 <strong>ssthresh = cwnd / 2， cwnd = 1</strong>，然后重新执行慢开始。</p></li><li><p><strong>快重传与快恢复</strong></p><p>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。</p><p>在发送方，如果收到3个重复确认（3-ACK），那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。</p><p>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 <strong>ssthresh = cwnd / 2 ，cwnd = ssthresh</strong>，注意到此时直接进入拥塞避免。</p><p>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</p></li></ol><h2 id="TCP-的运输连接"><a href="#TCP-的运输连接" class="headerlink" title="TCP 的运输连接"></a>TCP 的运输连接</h2><p>TCP 是面向连接的协议。运输连接有三个阶段：连接建立、数据传送、连接释放</p><p>TCP 连接建立过程中要解决的三个问题</p><ul><li>要使每一方能够确知对方的存在</li><li>要允许双方协商一些参数（如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等）</li><li>能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配</li></ul><h3 id="TCP-的连接建立"><a href="#TCP-的连接建立" class="headerlink" title="TCP 的连接建立"></a>TCP 的连接建立</h3><p>握手需要在客户和服务器之间交换三个 TCP 报文段，称之为<strong>三报文握手</strong>。</p><p><img src="TCP-connection-establishment.png" alt="三报文握手"></p><ol><li>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求</li><li>A 向 B 发出连接请求报文段，其首部中的同步位 SYN = 1，并选择序号 seq = x</li><li>B 收到连接请求报文段后，如同意，B 在确认报文段中应使 SYN = 1，使 ACK = 1，其确认号 ack = x + 1，自己选择的序号 seq = y</li><li>A 收到此报文段后向 B 给出确认，其 ACK = 1，确认号 ack = y + 1，seq = x + 1</li><li>B 收到 A 的确认后，连接建立</li></ol><p><strong>三次握手的原因：</strong></p><p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p><p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p><h3 id="TCP-的连接释放"><a href="#TCP-的连接释放" class="headerlink" title="TCP 的连接释放"></a>TCP 的连接释放</h3><p><img src="TCP-connection-release.png" alt="TCP 的连接释放"></p><ul><li>A 发送连接释放报文，FIN = 1，其序号 seq = u</li><li>B 收到之后发出确认，ack = u + 1，自己的序号 seq = v。此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</li><li>若 B 已经没有要向 A 发送的数据，发送连接释放报文，FIN=1，seq = w, ack = u + 1。</li><li>A 收到连接释放报文段后，必须发出确认，ACK = 1，确认号 ack = w+ 1，序号 seq = u + 1。 进入 TIME-WAIT 状态，等待 2 MSL（最大报文段寿命）后释放连接。</li><li>B 收到 A 的确认后释放连接</li></ul><p><strong>四次挥手的原因：</strong></p><p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p><p><strong>A 必须等待 2MSL 的时间的原因：</strong></p><ul><li>保证 A 发送的最后一个 ACK 报文段能够到达 B</li><li>让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文</li></ul><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><p>应用层就是规定应用进程在通信时所遵循的协议。应用层的许多协议都是基于客户服务器方式。客户(client)和服务器(server)都是指通信中所涉及的两个应用进程。</p><h2 id="域名系统-DNS"><a href="#域名系统-DNS" class="headerlink" title="域名系统 DNS"></a>域名系统 DNS</h2><p>DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。</p><p>域名只是个逻辑概念，并不代表计算机所在的物理地点。</p><p><strong>域名的解析过程：</strong></p><ul><li><p><strong>主机向本地域名服务器的查询一般都是采用递归查询</strong></p><p>如果主机所询问的域名本地域名服务器不知道其IP 地址，那么本地域名服务器就以 DNS 客户的身份，向其他根域名服务器继续发出查询请求报文。</p></li><li><p><strong>本地域名服务器向根域名服务器的查询通常是采用迭代查询</strong></p><p>当根域名服务器收到本地域名服务器的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地域名服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地域名服务器进行后续的查询。</p></li></ul><p>DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 <strong>53</strong>。大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。在两种情况下会使用 TCP 进行传输：</p><ul><li>如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）</li><li>区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）</li></ul><h2 id="文件传送协议"><a href="#文件传送协议" class="headerlink" title="文件传送协议"></a>文件传送协议</h2>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="2020/06/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>2020/06/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h1><h2 id="操作系统的定义"><a href="#操作系统的定义" class="headerlink" title="操作系统的定义"></a>操作系统的定义</h2><p>操作系统（OS ）是管理计算机硬件与软件资源的计算机程序。</p><h2 id="操作系统的功能"><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a>操作系统的功能</h2><ol><li>进程管理——进程线程的状态、控制、同步互斥、通信调度等</li><li>内存管理——分配/回收、地址转换、存储保护等</li><li>设备管理——设备驱动、分配回收、缓冲技术等</li><li>文件管理——文件目录、文件操作、磁盘空间、文件存取控制</li></ol><h2 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h2><ol><li><strong>并发性</strong><br>并发性是两个或多个事件在同一时间间隔内发生的、同时处于活动状态的特性。</li><li><strong>共享性</strong><br>指系统中的资源可以被多个并发进程共同使用，内存中并发执行的多个程序可以共享计算机的硬件和软件资源。有两种共享方式：互斥共享和同时共享。</li><li><strong>虚拟性</strong><br>虚拟性是指将一个物理实体映射为一个或多个逻辑对象。主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。</li><li><strong>异步性</strong><br>随机性也叫异步性，指的是每道程序在何时执行、各个程序执行的顺序以及每道程序所需的时间都是不确定的，也是不可预知的。</li></ol><h2 id="操作系统的分类"><a href="#操作系统的分类" class="headerlink" title="操作系统的分类"></a>操作系统的分类</h2><ol><li>批处理操作系统</li><li>分时操作系统</li><li>实时操作系统</li><li>嵌入式操作系统</li><li>个人操作系统</li><li>网络操作系统</li><li>分布式操作系统</li></ol><h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程是正在运行的程序及其占用的系统资源，是系统进行资源分配、保护和调度的基本单位。</p><p>进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程是独立调度的基本单位。</p><p>一个进程中可以有多个线程，它们共享进程资源。</p><p>QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol><li>拥有资源。进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。</li><li>调度。线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</li><li>系统开销。由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</li><li>通信方面。线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。</li></ol><h2 id="程序的执行"><a href="#程序的执行" class="headerlink" title="程序的执行"></a>程序的执行</h2><p><strong>程序的顺序执行</strong></p><p>一个具有独立功能的程序独占处理器直至最终结束的过程称为程序的顺序执行。</p><p>顺序执行有如下三个特点：顺序性、封闭性、可在现性</p><p>并发执行的特性有以下三点：间断性、开放/交互性、不可再现性</p><p><strong>程序的并发执行与并行执行：</strong></p><ul><li><p>并行是指多个事件在同一时刻发生，而并发是指多个事件在同一时期内发生。</p></li><li><p>并行是并发的特例，程序并行执行的硬件前提是系统中有多个 CPU。</p></li><li><p>并发的本质是一个 CPU 在多个程序运行过程中的时分复用。</p></li></ul><h2 id="进程的特征与控制"><a href="#进程的特征与控制" class="headerlink" title="进程的特征与控制"></a>进程的特征与控制</h2><p>进程有以下特性：结构性、动态性、独立性、并发性</p><p>进程通常分为两类：系统进程和用户进程</p><p><strong><code>进程上下文</code>：</strong>进程的生命周期中，进程实体和支持进程运行的环境</p><h3 id="进程状态及转换"><a href="#进程状态及转换" class="headerlink" title="进程状态及转换"></a>进程状态及转换</h3><p><img src="Process-tristate.png" alt="进程三态模型"></p><p><strong>就绪状态</strong>——进程在内存中已经具备执行的条件，等待分配 CPU。<em>就绪队列</em></p><p><strong>运行状态</strong>——进程占用 CPU 并正在执行。</p><p><strong>阻塞状态</strong>——等待资源，也称为等待状态。<em>阻塞队列</em></p><p>应该注意以下内容：</p><p>（1）只有就绪态和运行态可以相互转换，其它的都是单向转换。</p><p>（2）就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</p><p>（3）阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。</p><p><img src="Process-five-states.png" alt="进程五态模型"></p><p><strong>新建状态</strong>——进程被创建时所处的状态。</p><p><strong>终止状态</strong>——进程正常结束或出现严重错误时，会被操作系统终止或被其它有终止权的进程终止。</p><p><img src="Process-seven-states.png" alt="进程七态模型"></p><p><strong>挂起就绪</strong>——进程具备运行条件，但目前不在内存中，需要被系统调入内存才能运行。</p><p><strong>挂起阻塞</strong>——进程在等待某一事件或条件并且该进程目前不在内存中。</p><h3 id="进程控制块-PCB"><a href="#进程控制块-PCB" class="headerlink" title="进程控制块 PCB"></a>进程控制块 PCB</h3><p>描述和控制进程运行的数据结构，PCB 是进程存在的<code>唯一标志</code>。</p><ol><li>进程标识信息——内部标识符和外部标识符 </li><li>现场信息——进程运行时 CPU 的即时状态即各寄存器的值</li><li>控制信息——操作系统控制进程需要的信息</li></ol><h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p>核心态（内核态）和用户态，也称为管态和目态</p><p><strong>进程控制</strong>——系统对进程生命周期的各个环节进行控制</p><p>进程控制通常由原语完成。<strong>原语</strong>是由若干条指令所组成，用来实现某个特定功能，在执行过程中不可被中断的程序段。</p><p>原语是不可分割的执行单位，原语的执行不可能是并发的。</p><ol><li>创建进程</li><li>撤消与终止进程</li><li>阻塞与唤醒进程</li><li>挂起与激活进程</li></ol><h2 id="进程的互斥与同步"><a href="#进程的互斥与同步" class="headerlink" title="进程的互斥与同步"></a>进程的互斥与同步</h2><p>并发运行的多个进程之间存在两种基本关系——竞争（互斥）和协作（同步）</p><ul><li>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</li><li>互斥：多个进程在同一时刻只有一个进程能进入临界区。</li></ul><p>竞争，会引起一下两种极端情况：</p><ul><li>死锁：一组进程均只占有部分所需资源而无法继续运行，陷入阻塞</li><li>饥饿：进程被调度程序长期忽视而分配不到 CPU 执行</li></ul><h3 id="临界资源与临界区"><a href="#临界资源与临界区" class="headerlink" title="临界资源与临界区"></a>临界资源与临界区</h3><p><strong>临界资源</strong>：在某段时间内只能允许一个进程使用的资源<br><strong>临界区</strong>：访问临界资源的代码段</p><p>临界区调度原则：</p><ol><li>一次至多一个进程能够进入临界区内执行；</li><li>如果已有进程在临界区，其它试图进入的进程应等待；</li><li>进入临界区内的进程应在有限时间内退出，以便让等待进程中的一个进入；</li></ol><h3 id="进程同步机制"><a href="#进程同步机制" class="headerlink" title="进程同步机制"></a>进程同步机制</h3><ol><li><p>信号量机制</p><p><strong>P(s)：</strong>将信号量 s 的值减 1，若结果小于 0，则调用 P(s) 的进程被阻塞，并进入信号量 s 的阻塞队列中；若结果不小于 0，则调用 P(s) 的进程继续运行。</p><p><strong>V(s)：</strong>将信号量 s 的值加 1，若结果不大于 0，则调用 V(s) 的进程从该信号量阻塞队列中释放、唤醒一个处于等待状态的进程，将其转换为就绪状态，调用 V(s) 的进程继续运行；若结果大于0，则调用V(s)的进程继续运行。</p><ul><li>P 操作意味进程申请一个资源，求而不得则阻塞进程，V 操作意味着释放一个资源，若此时还有进程在等待获取该资源，则被唤醒。</li><li>若信号量的值为正数，该正数表示可对信号量可进行的 P 操作的次数，即可用的资源数。信号量的初值一般设为系统中相关资源的总数，对于互斥信号量，初值一般设为 1。</li><li>若信号量的值为负，其绝对值表示有多个进程申请该资源而又不能得到，在阻塞队列等待，即在信号量阻塞队列中等待该资源的进程个数。</li></ul></li><li><p>管程同步机制</p><p>把临界区集中并封装成抽象数据类型，其中包括与临界资源相关、仅限管程内部访问的公共变量，供管程外的进程调用以访问这些公共变量的接口过程，并提供互斥机制确保进程互斥地使用管程 。</p><p><strong>管程具有以下特点：</strong>模块化、隐蔽性、互斥性</p><p>管程有一个重要特性：<strong>在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。</strong></p><p>管程引入了<strong>条件变量</strong>同步机制：</p><ul><li>让进入管程却因资源不足而阻塞的进程暂时放弃管程控制权（开放管程），进入该条件变量的等待队列 </li><li>条件变量只能在管程中通过两个原语操作——wait 原语和 signal 原语 </li><li>一个进程已进入管程但无法继续执行，便在相应的条件变量 x 上调用 x.wait( )，将自己阻塞并移入 x 的等待队列中，放弃管程控制权（开放管程），另一进程可以通过对同一个条件变量执行 x.signal( ) 来唤醒之前在 x 上等待的进程  </li></ul></li></ol><p><strong>管程与进程的区别：</strong></p><ul><li>管程把共享变量上的同步操作集中起来，而临界区却分散在每个进程中；</li><li>管程是为管理共享资源而建立的，进程主要是为实现系统并发性而引入的；</li><li>管程被进程调用，管程和调用它的进程不能并行工作，而进程之间能并行工作，并发性是其固有特性；</li><li>管程是语言或操作系统的组成部分，随操作系统启动而装入内存，不必创建或撤销，而进程有生命周期；</li></ul><h3 id="进程同步经典问题"><a href="#进程同步经典问题" class="headerlink" title="进程同步经典问题"></a>进程同步经典问题</h3><ol><li><p><strong>生产者-消费者问题</strong></p><p>在并发环境下生产者、消费者进程访问缓冲区的速度不协调、不匹配——不同步，或者没有做到互不影响地使用、更新缓冲区——互斥，所以会出现运行错误甚至是死锁。<img src="Producer-consumer.png" alt="生产者-消费者问题"></p><p>方案：因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。</p><p>为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。</p></li><li><p><strong>读者-写者问题</strong></p><ul><li>允许多个读者进程同时读文件</li><li>只允许一个写者进程写文件</li><li>任何一个写者进程在完成写操作之前不允许其它读者或写者工作</li><li>写者执行写操作前，应让已有的写者和读者全部退出</li></ul><p>方案：一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore count_mutex = <span class="number">1</span>;</span><br><span class="line">semaphore data_mutex = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        <span class="built_in">p</span>(&amp;count_mutex);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">1</span>) <span class="built_in">p</span>(&amp;data_mutex); <span class="comment">// 第一个读者需要对数据进行加锁，防止写进程访问</span></span><br><span class="line">        <span class="built_in">v</span>(&amp;count_mutex);</span><br><span class="line">        <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">p</span>(&amp;count_mutex);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>) <span class="built_in">v</span>(&amp;data_mutex);</span><br><span class="line">        <span class="built_in">v</span>(&amp;count_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        <span class="built_in">p</span>(&amp;data_mutex);</span><br><span class="line">        <span class="built_in">write</span>();</span><br><span class="line">        <span class="built_in">v</span>(&amp;data_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>哲学家就餐问题</strong></p><p>五个哲学家围坐在一圆桌旁，桌中央有一盘通心面，每人面前有一只空盘子，每两人之间放一只筷子。每个哲学家的行为是思考，感到饥饿，然后吃通心面。为了吃面，每个哲学家必须拿到两只筷子，并且每个人只能直接从自己的左手边和右手边去取筷子。<img src="Philosopher-dining.png" alt="哲学家就餐问题"></p><p>为了防止死锁的发生，可以设置两个条件：</p><ul><li>必须同时拿起左右两根筷子；</li><li>只有在两个邻居都没有进餐的情况下才允许进餐。</li></ul></li><li><p><strong>睡眠理发师</strong></p><p>理发店里有一个理发师，一把理发椅，N 个供等候顾客休息的椅子。若无顾客，理发师躺在理发椅上睡觉。顾客到来时唤醒理发师，若理发师正在理发，新来的顾客坐在空闲的休息椅上等候，如果没有空椅子，顾客离开。</p></li></ol><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>进程同步与进程通信很容易混淆，它们的区别在于：</p><ul><li>进程同步：控制多个进程按一定顺序执行；</li><li>进程通信：进程间传输信息。</li></ul><p>进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。进程间通信的7种方式：<strong>管道（匿名管道）、有名管道、消息队列、信号、信号量、共享内存和套接字</strong>。</p><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>管道/匿名管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。</p><p>它具有以下限制：</p><ul><li>只支持半双工通信（单向交替传输）</li><li>只能在父子进程或者兄弟进程中使用。</li><li>管道的缓冲区是有限的</li></ul><p><img src="pipe.png"></p><p>管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据。</p><p>该缓冲区可以看做是一个循环队列，读和写的位置都是自动增长的，不能随意改变，一个数据只能被读一次，读出来以后在缓冲区就不复存在了。</p><p>当缓冲区读空或者写满时，有一定的规则控制相应的读进程或者写进程进入等待队列，当空的缓冲区有新数据写入或者满的缓冲区有数据读出来时，就唤醒等待队列中的进程继续读写。</p><h3 id="有名管道（FIFO）"><a href="#有名管道（FIFO）" class="headerlink" title="有名管道（FIFO）"></a>有名管道（FIFO）</h3><p>FIFO克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。有名管道的名字存在于文件系统中，内容存放在内存中。</p><p>FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。</p><p><img src="YFIFO.png"></p><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。消息队列允许一个或多个进程向它写入与读取消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p><p>相比于 FIFO，消息队列具有以下优点：</p><ul><li>消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；</li><li>避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；</li><li>读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。</li></ul><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。如果该进程当前并未处于执行状态，则该信号就有内核保存起来，直到该进程回复执行并传递给它为止。如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。</p><p><img src="signal.png"></p><p>Linux系统中常用信号：</p><ul><li>SIGINT：程序终止信号。程序运行过程中，按Ctrl+C键将产生该信号。</li><li>SIGQUIT：程序退出信号。程序运行过程中，按Ctrl+\\键将产生该信号。</li><li>SIGKILL：用户终止进程执行信号。shell下执行kill -9发送该信号。</li></ul><p>信号是软件层次上对中断机制的一种模拟，是一种异步通信方式，信号可以在用户空间进程和内核之间直接交互，内核可以利用信号来通知用户空间的进程发生了哪些系统事件。</p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。</p><p><strong>信号量与普通整型变量的区别：</strong></p><ul><li>信号量是非负整型变量，除了初始化之外，它只能通过两个标准原子操作：wait(semap) , signal(semap) 来进行访问；</li><li>操作也被成为PV原语，普通整型变量则可以在任何语句块中被访问；</li></ul><p><strong>信号量与互斥量之间的区别：</strong></p><ul><li>互斥量用于线程的互斥，信号量用于线程的同步（根本区别）</li><li>互斥量值只能为0/1，信号量值可以为非负整数。</li><li>互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。</li></ul><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。</p><p>为在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。</p><p>由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。</p><p><img src="share-memory.png"></p><h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><p>套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。</p><p><img src="socket.png"></p><h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><p>两种基本的进程调度方式，抢占方式和非抢占方式，也称剥夺式（preemptive）和非剥夺式（non_preemptive）调度</p><h3 id="进程调度模型"><a href="#进程调度模型" class="headerlink" title="进程调度模型"></a>进程调度模型</h3><ul><li>高级调度（High-Level Scheduling)，又称为作业调度，它决定把后备作业调入内存运行； </li><li>中级调度（Intermediate-Level Scheduling)，又称为平衡调度，在虚拟存储器中引入，在内、外存对换区进行进程对换；</li><li>低级调度 (Low-Level Scheduling)：又称为进程调度，它决定就绪队列的某进程获得CPU； <img src="Three-level-scheduling.png" alt="三级调度模型"></li></ul><h3 id="调度算法选择-评价准则"><a href="#调度算法选择-评价准则" class="headerlink" title="调度算法选择/评价准则"></a>调度算法选择/评价准则</h3><ul><li>处理器利用率（CPU utilization）= CPU有效工作时间 / CPU总的运行时间 </li><li>响应时间（response time）：交互环境下用户从键盘提交请求开始，到系统首次产生响应为止的时间</li><li>周转时间（turnaround time）Ti =  Tf – Ts，即：周转时间 = 完成时刻 - 提交时刻 </li><li>带权周转时间—— Wi = 作业的周转时间 Ti / 系统为作业提供的服务时间 Tsi，显然带权周转时间总大于 1 </li><li>平均作业周转时间 T = (ΣTi) / n</li><li>平均作业带权周转时间W = (ΣWi) / n</li></ul><h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><ul><li><p>非抢占方式：先来先服务、短作业优先、高响应比优先</p></li><li><p>抢占方式：最短剩余时间优先、优先权、时间片轮转、多级反馈队列</p></li></ul><ol><li><strong>先来先服务</strong>(First-Come First-Served，FCFS)——按进程就绪的先后顺序来调度，到达得越早，就越先执行。特点如下：获得CPU的进程，未遇到其它情况时，一直运行下去；是一种非抢占式算法；没有考虑执行时间长短、运行特性和资源的要求。</li><li><strong>短作业优先</strong>(Shortest-Job-First，SJF)——以进入系统的作业所要求的CPU服务时间为标准，总选取估计所需CPU时间最短的作业优先投入运行。</li><li><strong>最短剩余时间优先</strong>(Shortest Remaining Time First，SRTF)——若一就绪状态的新作业所需的CPU时间比当前正在执行的作业剩余任务所需CPU时间还短，SRTF将打断正在执行作业，将执行权分配给新作业。</li><li><strong>高响应比优先</strong>(Highest Response Ratio First，HRRF)——是 FCFS 与 SJF 两种算法的折衷——既考虑作业等待时间，又考虑作业的运行时间，既照顾短作业又不使长作业等待过久，改善了调度性能，仍属于非抢占式算法。响应比为作业的响应时间与作业所需运行时间之比，简化为：响应比 ＝1 +（已等待的时间 / 估计运行时间）。</li><li><strong>优先权</strong>(Highest-Priority-First，HPF)——根据进程的优先权进行进程调度，每次总是选取优先权高的进程调度，也称优先级调度算法，一般是抢占式调度。</li><li><strong>时间片轮转</strong>(Round-Ribon，RR)——调度程序把CPU分配给进程使用一个规定的时段，称为一个时间片（如100ms），就绪队列中的进程轮流获得CPU的一个时间片。当一个时间片结束时，系统剥夺该进程执行权，等候下一轮调度，属于抢占式调度。</li><li><strong>多级反馈队列</strong>(MFQS)——将时间片轮转与优先级调度相结合，把进程按优先级分成不同的队列，先按优先级调度，优先级相同的，按时间片轮转。优点是兼顾长短作业，有较好的响应时间，可行性强，适用于各种作业环境。</li></ol><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p> 死锁产生的原因主要有两个：<strong>并发进程对临界资源的竞争；并发进程推进顺序不当</strong>。</p><h3 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h3><ol><li><strong>互斥条件</strong>：每个资源要么已经分配给了一个进程，要么就是可用的</li><li><strong>请求与保持条件</strong>：已经得到了某个资源的进程可以再请求新的资源</li><li><strong>不剥夺条件</strong>：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放</li><li><strong>环路等待条件</strong>：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源</li></ol><h3 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h3><p>主要有以下四种方法：</p><ul><li>鸵鸟策略</li><li>死锁检测与死锁恢复</li><li>死锁预防</li><li>死锁避免</li></ul><h4 id="鸵鸟策略"><a href="#鸵鸟策略" class="headerlink" title="鸵鸟策略"></a>鸵鸟策略</h4><p>把头埋在沙子里，假装根本没发生问题。</p><p>因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。</p><p>当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。</p><p>大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。</p><h4 id="死锁检测与死锁恢复"><a href="#死锁检测与死锁恢复" class="headerlink" title="死锁检测与死锁恢复"></a>死锁检测与死锁恢复</h4><p>不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。</p><p>每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。</p><p>死锁恢复：</p><ul><li>利用抢占恢复</li><li>利用回滚恢复</li><li>通过杀死进程恢复</li></ul><h4 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h4><p>在程序运行之前预防发生死锁。</p><ul><li><p>破坏互斥条件<br>例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。</p></li><li><p>破坏请求与保持条件<br>一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。</p></li><li><p>破坏不可剥夺条件</p></li><li><p>破坏环路等待</p><p>给资源统一编号，进程只能按编号顺序来请求资源。</p></li></ul><h4 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h4><p><strong>银行家算法</strong>的思路：</p><ol><li>在某一时刻，各进程已获得所需的部分资源。有一进程提出新的资源请求，系统将剩余资源试探性地分配给该进程。</li><li>如果此时剩余资源能够满足余下的某些进程的需求，则将剩余资源分配给能充分满足的、资源需求缺口最大的进程，运行结束后释放的资源再并入系统的剩余资源集合。</li><li>反复执行第 2 步，直到所有的进程都能够获得所需而运行结束。说明第1步的进程请求是可行的，系统处于安全状态，相应的进程执行序列称为系统的安全序列。如果所有的进程都试探过而不能将资源分配给进程，即不存在安全序列，则系统是不安全的。</li></ol><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p><strong>MMU</strong> 内存管理单元，也称作分页内存管理单元，把虚拟地址转换成物理地址。<strong>TLB</strong> 是一块高速缓存，缓存虚拟地址和其映射的物理地址，减少CPU访问物理内存的次数，用于改进虚拟地址到物理地址转换速度。</p><h2 id="程序执行过程"><a href="#程序执行过程" class="headerlink" title="程序执行过程"></a>程序执行过程</h2><p>创建进程首先要将程序和数据装入内存。将用户源程序变为可在内存中执行的程序，通常需要以下几个步骤：</p><ol><li><strong>编译</strong>：由编译程序将用户源代码编译成若干个目标模块。</li><li><strong>链接</strong>：由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块。</li><li><strong>装入</strong>：由装入程序将装入模块装入内存运行。</li></ol><p><strong>程序链接的三种方式：</strong></p><ul><li>静态链接：在程序运行之前，就将所有模块和库函数的连在一起不再分开。</li><li>装入时动态链接：将用户编译后的一组模块在装入内存的时候，边链接边装入。</li><li>运行时动态链接：在运行程序执行中需要哪些模块才将其连接装入，便于修改与更新。</li></ul><p><strong>装入的三种方式：</strong></p><ul><li>绝对装入：程序编译的时候如果已经知道要将目标模块放在内存中的哪一个位置，由于程序的逻辑地址与物理地址相同，所以直接装入</li><li>可重定位装入：在多道程序环境下，多个目标模块逻辑地址的起始地址都是从0开始的，装入是对程序中的逻辑地址进行修改从而得到物理地址。比如：一个模块分配的地址在内存中是从100开始的，此时它里面标号为69的逻辑地址实际上是169。</li><li>动态运行时装入：装入程序版装入模块装入内存后，并不立即把装入模块中的地址转换为绝对地址，而是推迟到程序要执行的时候才进行转换，一次装入内存后都为相对地址。</li></ul><h2 id="内存管理概述"><a href="#内存管理概述" class="headerlink" title="内存管理概述"></a>内存管理概述</h2><p>计算机的存储系统主要包括内存储器（内存或主存）和外存储器（辅助存储器）。</p><h3 id="计算机存储系统的结构"><a href="#计算机存储系统的结构" class="headerlink" title="计算机存储系统的结构"></a>计算机存储系统的结构</h3><p><img src="Structure-of-storage-system.jpg" alt="计算机系统的结构与使用关系"></p><h3 id="内存管理的功能"><a href="#内存管理的功能" class="headerlink" title="内存管理的功能"></a>内存管理的功能</h3><ol><li><p><strong>内存的分配和回收</strong></p><p>当作业或进程创建后系统会为它们分配内存空间，当结束后内存空间也会被回收。使程序员摆脱存储分配的麻烦，提高编程效率。</p></li><li><p><strong>地址转换</strong></p></li><li><p><strong>内存空间的扩充</strong></p></li><li><p><strong>存储保护</strong></p></li></ol><h3 id="地址的表示与地址转换"><a href="#地址的表示与地址转换" class="headerlink" title="地址的表示与地址转换"></a>地址的表示与地址转换</h3><p>编译后，每个目标模块都是从0号单元开始编址，称为该目标模块的相对地址（<strong>逻辑地址</strong>)。当链接程序将各个模块链接成一个完整的可执行目标程序时，链接程序顺序依次按各个模块的相对地址构成统一的从0号单元开始编址的逻辑地址空间。<strong>物理地址</strong>空间是指内存中物理单元的集合，它是地址转换的最终地址，进程在运行时执行指令和访问数据最后都要通过物理地址从主存中存取。</p><p>只有把程序和数据的逻辑地址转换为物理地址，程序才能正确运行，该过程称为<strong>地址转换或地址重定位</strong>。地址转换有静态重定位和动态重定位两种方式。</p><ul><li>静态重定位：这种方式是在用户作业装入内存时由装入程序(装配程序)实现从逻辑地址到物理地址的转换，地址转换在作业执行前一次完成</li><li>动态重定位：程序执行过程中，CPU在访问程序和数据之前才实现地址转换。动态重定位必须借助于硬件地址转换机构来实现，硬件系统中设置了一个<strong>定位寄存器</strong>，当操作系统为某程序分配了一块内存区域后，装入程序把程序装入到所分配的区域中，然后把该内存区域的起始地址置入定位寄存器中。在程序执行过程中需要进行地址转换时，只需将逻辑地址与定位寄存器中的值相加就可得到物理地址。这种地址转换方式是在指令过程中进行的，所以称动态重定位。</li></ul><h3 id="覆盖与交换技术"><a href="#覆盖与交换技术" class="headerlink" title="覆盖与交换技术"></a>覆盖与交换技术</h3><p>覆盖与交换技术是在多道程序环境下用来扩充内存的两种方法。</p><ol><li><p>覆盖技术：按照程序自身的逻辑结构，让不同时执行的程序段先后共享同一块内存区域</p><p>例如：某程序由A、B、C、D、E、F等六个程序段组成，它们之间的调用关系如图3.3左图所示。其中，程序段A只调用B和C，程序段B只调用F，而程序段C只调用D和E。由于B和C之间没有相互调用，所以它们可以共享同一覆盖区。覆盖区的大小以能装入所有共享的程序段为准。本例中，与B、C对应的覆盖区的大小为50K。类似地，D、E、F也可以共享一大小为40K的覆盖区，如下图所示。<img src="Coverage-technology.png" alt="覆盖技术"></p></li><li><p>交换技术：由操作系统根据需要，将某些暂时不运行的进程或程序段从内存移到外存的交换区中；当内存空间富余时再给被移出的进程或程序段重新分配内存，让其进入内存</p></li></ol><p><strong>区别与联系：</strong>覆盖是在同一个程序或者进程之间的，交换是在不同进程和程序之间的，所以覆盖技术与交换技术可以一起使用。</p><h3 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h3><p>内存分配前，需要保护操作系统不受用户进程的影响，同时保护用户进程不受其他用户进程的影响。</p><p>方法如下：</p><ul><li>在CPU中设置一堆上下限寄存器，存放用户作业在主存中的上限地址与下限地址。当CPU要访问内存的时候，分别用这两个地址和要访问的地址做比较。</li><li>重定位寄存器（基址寄存器）和界地址寄存器（限长寄存器）。重定位寄存器存储改作业的物理地址最小值；界地址寄存器存储改作业逻辑地址最大值。当CPU要访问内存的时候，分别用这两个地址数值之和与要访问的地址做比较。</li></ul><h2 id="分区内存管理"><a href="#分区内存管理" class="headerlink" title="分区内存管理"></a>分区内存管理</h2><p><strong>连续分配</strong>为用户分配一个连续的内存空间。</p><ul><li>内部碎片：给一个进程分配一块空间，这块空间没有用完的部分叫做内部碎片。</li><li>外部碎片：给每个进程分配空间以后，内存中会存在一些区域由于太小而无法利用的空间，叫做外部碎片。</li></ul><ol><li><p>单一连续分配</p><p>分配方法：将内存去划分为系统区域用户区，系统区为操作系统使用，剩下的用户区给一个进程或作业使用。</p><p>特点：操作简单、没有外部碎片，适合单用户、单任务的操作系统。但是会有大量的内部碎片浪费资源，存储效率极低。</p></li><li><p>固定分区分配</p><p>分配方法：(1)分区大小相等：将内存的用户区分成大小相等的区域，每个进程只能申请一块区域；</p><p>(2)分区大小不等：将内存的用户区分成大小不等的区域，分配原则是多个较小的区域、适量中等大小区域、少量的最大分区。每个进程根据大小只能申请一块区域。</p><p>特点：固定分区分配虽然没有外部碎片，但是会造成大量的内部碎片。分区大小相等缺乏灵活性，大的进程可能放不进去；分区大小不等可能会造成大量的内部碎片，利用率极低。</p></li><li><p>可变分区内存管理</p><ul><li><strong>首次适应分配算法：</strong>进程进入内存之后从头开始查找第一个适合自己大小的分区。空间分区就是按照地址递增的顺序排列。算法开销小，回收后放到原位置就好。综合看这个算法性能最好。</li><li><strong>循环首次适应分配算法：</strong>空间分区按照地址递增的顺序进行排列，是由首次适应演变而来，进程每次寻找空间，从上一次查找的地址以后开始查找(不同于首次适应，首次适应每次从开头查找)。算法开销小，大的分区也会很快被用完。</li><li><strong>最佳适应分配算法：</strong>将分区从从小到大排列(容量递增)，找到最适合自己的分区，这样会有更大的分区被保留下来，满足别的进程需要。但是算法开销大，每次进程消亡产生新的区域后要重新排序。并且当使用多次后会产生很多外部碎片。</li><li><strong>最坏适应分配算法</strong>：将分区从从大到小排列(容量递减)，进程每次都找最大的区域来使用。可以减少难以利用的外部碎片。但是大分区很快就被用完了，大的进程可能会有饥饿的现象。算法开销也比较大。</li><li><strong>快速适应算法：</strong>该算法将空闲分区按照大小进行分类，对每一类具有相同容量的所有空闲分区，单独设置一个空闲分区链表。分类通常常用空间大小进行划分，比如2KB,4KB,8KB等。仅需要根据进程的长度检索，找到能容纳它的最小空闲区链表，进行分配。<br>该算法优点是查找效率高，能够保留大的分区，满足用户对大空间的需求。缺点在于分区归还主存时算法复杂，系统开销较大，而且存在一定的空间浪费，是典型空间换时间的做法。</li></ul></li></ol><h2 id="页式存储管理"><a href="#页式存储管理" class="headerlink" title="页式存储管理"></a>页式存储管理</h2><p>可以将一个进程分散的装入内存分区。根据分区的大小是否固定可以分成分<strong>页存储管理</strong>(固定)与<strong>分段存储管理</strong>(不固定)，为了避免两者的缺点，还可以二者混用成<strong>段页式存储管理</strong>。再根据进程运行作业时是否将作业的的全部代码装入内存，又分为<strong>基本分页存储管理</strong>(全部装入内存)和<strong>请求分页存储管理</strong>(非一次全装入内存)。</p><ul><li><p>页：将用户进程的逻辑地址空间划分为大小相等的区，每一个区称为一页或一个页面，并对各页从 0 开始编号，如第 0 页、第 1 页等。</p></li><li><p>物理块：将物理内存也划分成与页大小相等的区，每一个区称为一个物理块(block)，或称为块、页框，也同样对它们加以编号，如 0 号块、1 号块等。</p></li></ul><p>内存分配的<strong>基本单位</strong>是页，进程的最后一页经常装不满一块，所以会在最后一块内形成不可利用的碎片，称之为“<strong>页内碎片</strong>”。</p><p>32 位操作系统其逻辑地址是 32 位，采用页式内存管理，如果每页大小 4096 B，那么页内偏移要占用其逻辑地址的低 12 位，从 0 位开始到 11 位结束。逻辑地址剩余的高 20 位用来表示页号，从 12 位开始到 31 位结束，这样最多允许有 220（1M）个页面。页面的编号从 0 开始，分别为 0，1，2，3 …，220−1，如图所示。</p><p><img src="Page-storage.jpg" alt="页式存储的逻辑地址"></p><h3 id="快表-TLB"><a href="#快表-TLB" class="headerlink" title="快表(TLB)"></a>快表(TLB)</h3><p>为了提高程序的运行速度，可以将最近访问过的页表项信息存放在高速缓存中，以加速地址的变换过程。高速缓存也称为“联想存储器”，其中的页表称为“快表”。</p><h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p>为了能够快速查找页表页在内存中的物理块号，为这些页表页再设计一个地址索引表，即页目录表。二级页表的逻辑地址被划分为三部分： 页目录、页表页、页内偏移。</p><p><img src="Secondary-page-table.jpg" alt="二级页表结构"></p><p><strong>缺页中断</strong>指的是在进程运行过程中，发现所访问的页不在内存中时，CPU的内存管理单元发出的中断。与一般中断：CPU 检测中断时间不同，CPU 可多次处理。</p><p><strong>缺页中断处理流程</strong>是：先查看内存是否有空闲块，若有则按该页在外存中的地址将该页找出并装入内存，在页表中填上它占用的块号且修改标志位。若内存已没有空闲块，则必须先淘汰已在内存中的某一页，再将所需的页装入，对页表和内存分配表作相应的修改。淘汰某页时，要查看该页的修改位来判断该页是否修改过，若该页在执行过程中没有被修改过，那么不必重新写回到存储器中，而已修改过的页调出时必须再将该页写回到外存中。</p><h2 id="段式存储管理"><a href="#段式存储管理" class="headerlink" title="段式存储管理"></a>段式存储管理</h2><p>分段式存储管理是以段为单位进行内存分配，逻辑地址空间是一个二维空间，分为段号和段内偏移两部分。</p><p>分页存储是从计算机的角度设计的，目的是为了提高内存的利用率，提升计算机的性能。分段存储的提出是考虑到程序员和用户，以满足方编程、数据共享、信息保护、动态增长、动态链接的需要。</p><p><img src="Segment-storage.png" alt="段式存储的逻辑地址"></p><p><strong>分段和分页的比较</strong></p><ul><li>页是信息的物理单位，分页的主要目的是为了实现离散分配，提高内存的利用率。分页仅仅是系统管理上的需求，安全是系统行为对用户是不可见的。段是信息的逻辑单位，分段的主要目的是更好地满足用户需求，一个段通常包含一组数语一个逻辑板块的信息。分段是用户可见的，用户编程时需要显示的给出段名。</li><li>页的大小是固定的，系统绝决定；段的大小是不固定的，取决于系统程序。</li><li>分页的用户地址空间是一维的，程序员只需要给出一个记忆符就可以表示一个地址；分段存储管理的地址空间是二维的，程序员需要在标识一个地址的时候，既要给出段名，也要给出段内地址。</li><li>分段比分页更容易实现信息的共享和保护 。</li><li>分页内存空间利用率高，不会产生外部碎片，只有少量的内部碎片。不方便按照逻辑模块实现信息的共享与保护 ；分段方便按照逻辑模块实现信息的共享与保护。如果段太长，为其分配很大的存储空间很不方便，容易产生外部碎片。</li></ul><p>在分段式存储管理的基础上实现分页式存储管理，这就是<strong>段页式存储管理</strong>，是目前应用最多的一种存储管理方式。</p><p><img src="Segment-page-storage.png" alt="段页式存储的逻辑地址"></p><p>逻辑地址分 3 个部分：段号、段内页号和页内位移，其形式为：对于用户来说，虚拟地址应该由段号 s 和段内位移 d’ 组成，用户看不到如何分页。而是由操作系统自动把 d’解释成两部分：段内页号 p 和页内位移 d，也就是说，d’ = p × 块长+ d。 </p><h2 id="虚拟存储技术"><a href="#虚拟存储技术" class="headerlink" title="虚拟存储技术"></a>虚拟存储技术</h2><p>将作业不执行的部分暂时存放在外存，待到进程需要时，再将其从外存调入内存。将外存作为内存的补充，从逻辑上扩充内存。</p><p>虚拟存储技术的<strong>实现基础</strong>是内存的分页或分段管理，采用的是进程的分页或分段在内存与外存之间对换。</p><h2 id="请求分页虚拟存储管理"><a href="#请求分页虚拟存储管理" class="headerlink" title="请求分页虚拟存储管理"></a>请求分页虚拟存储管理</h2><h3 id="硬件支持"><a href="#硬件支持" class="headerlink" title="硬件支持"></a>硬件支持</h3><ul><li>请求分页的页表机制</li><li>缺页中断机构</li><li>地址转换机构 </li></ul><h3 id="页面分配策略"><a href="#页面分配策略" class="headerlink" title="页面分配策略"></a>页面分配策略</h3><p>通常分为<strong>固定分配和可变分配</strong>两种不同的方式：</p><ol><li>固定分配方式：<ul><li>进程平均分配法</li><li>进程按比例分配法</li><li>进程优先权分配法</li></ul></li><li>可变分配方式</li></ol><h3 id="页面调度算法"><a href="#页面调度算法" class="headerlink" title="页面调度算法"></a>页面调度算法</h3><p><strong>页面调入策略：</strong></p><ul><li>请求页（demand paging）调入</li><li>预先页（prepaging）调入 </li></ul><p><strong>页面置换策略：</strong></p><ul><li><p>全局置换</p></li><li><p>局部置换</p></li></ul><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p><strong>先进先出、最佳页面、最近最久未使用、时钟置换算法</strong></p><ol><li><p><strong>先进先出（FIFO）页面置换算法</strong></p><p>总是选择最先进入内存的页面或驻留时间最长的页面先淘汰<img src="FIFO.png" alt="FIFO 页面置换算法"></p></li><li><p><strong>最佳（OPT）页面置换算法</strong></p><p>在选择页面置换时应该考虑该页面将来使用的情况，将来最长时间不用的页面被淘汰。在进程采用固定页面分配的情况下，最佳页面置换算法具有最低的缺页率<img src="OPT.png" alt="OPT 页面置换算法"></p></li><li><p><strong>最近最久未使用（LRU） 页面置换算法</strong></p><p>系统须维护一个页面淘汰队列，该队列中存放当前在内存中的页号，每当访问一页时就调整一次，使队尾总指向最近访问的页，而队列头部就是最近最少用的页，发生缺页中断时总淘汰队列头所指示的页；而执行一次页面访问后，需要从队列中把该页调整到队列尾<img src="LRU.png" alt="LRU 页面置换算法"></p></li><li><p><strong>时钟（clock）置换算法</strong></p><p>让一个指针循环扫描缓冲区，像时钟转动一样。会给每一页面增加一个附加位，称为使用位。当页面被调入内存的时候和页面被使用后将他的使用位置为1。页面需要替换的时候，指针会扫描每一页的使用位，如果为1，扫描过后置成0；如果为0，就将该页置换出去。如果所有的页面都为1的话，会继续扫描第二遍。（和LRU类似）</p></li></ol><h1 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h1><h2 id="设备管理概述"><a href="#设备管理概述" class="headerlink" title="设备管理概述"></a>设备管理概述</h2><p>设备管理目标：</p><ul><li>提高使用效率</li><li>提供便捷的界面</li></ul><p>设备管理功能：</p><ul><li>设备的分配与回收</li><li>缓冲区管理</li><li>设备控制和中断处理</li><li>实现虚拟设备</li></ul><h2 id="设备控制方法"><a href="#设备控制方法" class="headerlink" title="设备控制方法"></a>设备控制方法</h2><ol><li><p>程序循环查询方式</p></li><li><p>中断驱动方式</p></li><li><p>直接内存访问方式（DMA）</p><ul><li>数据传输的基本单位是数据块</li><li>所传送的数据是从设备直接送入内存，或者直接读出内存的</li><li>在传输时CPU参与更少，仅在传送一个或多个数据块的开始和结束时，才需CPU干预，整块数据的传送是在控制器的控制下完成的</li></ul></li><li><p>通道方式</p><p>I/O 通道方式是 DMA 方式的发展，它可进一步减少 CPU 的干预，即把对一个数据块的读(或写)为单位的干预，减少为对一组数据块的读(或写)及有关的控制和管理为单位的干预</p></li></ol><h2 id="缓冲技术"><a href="#缓冲技术" class="headerlink" title="缓冲技术"></a>缓冲技术</h2><p>缓冲技术主要有以下作用：</p><ul><li>改善中央处理器与外围设备之间速度不匹配的矛盾，提高 CPU 和 I/O 设备的并行性</li><li>减少 I/O 对 CPU 的中断次数和放宽对 CPU 中断响应时间的要求</li><li>协调逻辑记录大小与物理记录大小不一致的问题</li></ul><h2 id="输入输出软件"><a href="#输入输出软件" class="headerlink" title="输入输出软件"></a>输入输出软件</h2><p><strong>设备独立性</strong>，也称为设备无关性，是指在用户程序中不直接使用物理设备名（或设备的物理地址），而只能使用逻辑设备名。</p><ul><li>使得设备分配更加灵活，提高了设备的利用率</li><li>可以实现 I/O 重定向</li></ul><h2 id="设备分配与回收"><a href="#设备分配与回收" class="headerlink" title="设备分配与回收"></a>设备分配与回收</h2><h3 id="设备信息描述"><a href="#设备信息描述" class="headerlink" title="设备信息描述"></a>设备信息描述</h3><ol><li>系统设备表 SDT</li><li>设备控制表 DCT</li><li>控制器控制表 COCT</li><li>通道控制表 CHCT</li></ol><h3 id="设备分配策略"><a href="#设备分配策略" class="headerlink" title="设备分配策略"></a>设备分配策略</h3><ol><li>独占方式</li><li>共享方式</li><li>虚拟方式</li></ol><h3 id="SPOOLing-技术-假脱机"><a href="#SPOOLing-技术-假脱机" class="headerlink" title="SPOOLing 技术(假脱机)"></a>SPOOLing 技术(假脱机)</h3><p>当系统中引入了多道程序技术后，可以利用其中的一道程序，来模拟脱机输入输出时的外围控制机功能，把低速 I/O 设备上的数据传送到高速磁盘上；或者把数据从磁盘传送到低速输出设备上。这样，便可在主机的直接控制下，实现脱机输入输出功能。</p><ul><li>提高了 I/O 的速度，缓和了高速的处理器与低速输入输出设备之间的矛盾</li><li>将独占设备改造为共享设备，提高了设备的利用率</li><li>实现了虚拟设备功能，将物理的单个设备变换为多个对应的逻辑设备</li></ul><h3 id="设备分配算法"><a href="#设备分配算法" class="headerlink" title="设备分配算法"></a>设备分配算法</h3><ul><li>先来先服务算法</li><li>优先级高者优先算法</li></ul><h2 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h2><p>读写一个磁盘块的时间的影响因素有：</p><ul><li>旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）</li><li>寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）</li><li>实际的数据传输时间</li></ul><p>其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。</p><h3 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h3><p>按照磁盘请求的顺序进行调度。</p><p>优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。</p><h3 id="最短寻道时间优先"><a href="#最短寻道时间优先" class="headerlink" title="最短寻道时间优先"></a>最短寻道时间优先</h3><p>优先调度与当前磁头所在磁道距离最近的磁道。</p><p>虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。</p><h3 id="电梯算法"><a href="#电梯算法" class="headerlink" title="电梯算法"></a>电梯算法</h3><p>电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</p><p>电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。</p><p>为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。</p><h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>文件分类方法有很多，下面是常用的几种文件分类方法： </p><ul><li>按照文件的逻辑结构的不同，可以把文件分成流式文件和纪录式文件</li><li>按照用途将文件分为系统文件、库文件和用户文件</li><li>按照性质可以把文件分为普通文件、目录文件和特殊文件按照性质可以把文件分为普通文件、目录文件和特殊文件</li></ul><h2 id="文件的组织"><a href="#文件的组织" class="headerlink" title="文件的组织"></a>文件的组织</h2><h3 id="逻辑结构组织"><a href="#逻辑结构组织" class="headerlink" title="逻辑结构组织"></a>逻辑结构组织</h3><p><strong>1.流式文件</strong></p><p>流式文件指文件内的数据不组成记录，只是依次的一串信息集合，如字节流或字符流。流式文件本身可以没有结构。</p><p><strong>2.纪录式文件</strong></p><p>记录式文件是一种有结构的文件，它是指文件中的数据由若干条定长或不定长的记录构成，每条记录又由若干数据项构成。记录是记录式文件进行存取的基本单位。</p><p>按照组织方式的不同，记录式文件可进一步分为：</p><ul><li>顺序文件</li><li>索引文件</li><li>索引顺序文件</li></ul><h3 id="物理结构组织"><a href="#物理结构组织" class="headerlink" title="物理结构组织"></a>物理结构组织</h3><ol><li><p>连续文件</p></li><li><p>链接文件</p></li><li><p>索引文件<img src="Tertiary-index-eg.png" alt="3 级索引"></p></li><li><p>直接文件</p></li></ol><h3 id="文件的存取方法"><a href="#文件的存取方法" class="headerlink" title="文件的存取方法"></a>文件的存取方法</h3><ol><li>顺序存取</li><li>直接存取</li><li>按键存取</li></ol><h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><h3 id="文件目录的基本概念"><a href="#文件目录的基本概念" class="headerlink" title="文件目录的基本概念"></a>文件目录的基本概念</h3><p>文件控制块——用于描述和控制文件的数据结构，称之为文件控制块（File Control Block，FCB）</p><ul><li>为了加快文件的查找速度，通常把 FCB 集中起来进行管理，文件控制块的有序集合称为<strong>文件目录</strong></li><li>文件目录也是以文件的形式保存在外存上的，这就形成了<strong>目录文件</strong></li></ul><h3 id="目录文件的组织"><a href="#目录文件的组织" class="headerlink" title="目录文件的组织"></a>目录文件的组织</h3><p>常用的组织方法主要有三种：</p><ul><li>FCB 线性表</li><li>索引节点</li><li>哈希表组织</li></ul><h3 id="目录的结构"><a href="#目录的结构" class="headerlink" title="目录的结构"></a>目录的结构</h3><p>目录结构都是采用层次结构，主要分为：</p><ul><li>单级目录</li><li>二级目录</li><li>多级层次目录结构（最常用）</li><li>图状目录结构</li></ul>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDL复习</title>
      <link href="2020/05/05/HDL%E5%A4%8D%E4%B9%A0/"/>
      <url>2020/05/05/HDL%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="2019-2020-第一学期中国矿业大学-HDL-语言应用与设计-A卷"><a href="#2019-2020-第一学期中国矿业大学-HDL-语言应用与设计-A卷" class="headerlink" title="2019-2020 第一学期中国矿业大学 HDL 语言应用与设计 A卷"></a>2019-2020 第一学期中国矿业大学 HDL 语言应用与设计 A卷</h1><p>一、选择题</p><ol><li>右移操作</li><li>EDA 设计官方语言（不就是 VHDL 和 Verilog 嘛）</li><li>端口两种关联方式</li><li>面积、功耗优化方法</li><li>CPLD、FPGA 基本原理（乘积项和查找表）</li></ol><p>二、简答题</p><ol><li>always 和 initial 主要区别？能否嵌套？</li><li>给一段程序，写出他们的数据类型</li><li>VHDL 和 Verilog 程序区别</li></ol><p>三、程序分析注解</p><ul><li>给了一个函数，好像是奇偶校验</li></ul><p>四、程序设计题</p><ol><li>硬件消抖电路</li><li>写个函数求一个 4 位二进制数含 1 的个数，书上原题</li><li>给了个仿真图，计数从 0 - 9 再从 9  - 0 实现它</li><li>仿真 100 个时间单位，高电平 60 ，低电平 40</li><li>4 位 D 触发器，元件例化语句</li></ol><h1 id="直接上干货，三套试卷"><a href="#直接上干货，三套试卷" class="headerlink" title="直接上干货，三套试卷"></a>直接上干货，三套试卷</h1><p><img src="2020A.jpg" alt="2020A"></p><p><img src="2020B.jpg" alt="2020B"></p><p><img src="2020C.jpg" alt="2020C"></p>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HDL </tag>
            
            <tag> FPGA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uCOS-II知识点</title>
      <link href="2020/05/04/uCOS-II%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>2020/05/04/uCOS-II%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-嵌入式实时操作系统的基本概念"><a href="#第一章-嵌入式实时操作系统的基本概念" class="headerlink" title="第一章 嵌入式实时操作系统的基本概念"></a>第一章 嵌入式实时操作系统的基本概念</h1><p>第一章都是些基本概念知识，比如：什么是嵌入式操作系统，嵌入式操作系统是支持嵌入式系统工作的操作系统，一般用于比较复杂的嵌入式系统软件开发中；什么又是嵌入式实时操作系统，大多嵌入式系统应用在实时环境中，因此嵌入式操作系统跟实时（Real-Time）操作系统密切联系在一起；典型嵌入式操作系统有哪些，主要有VxWorks、Windows CE、Palm OS、QNX、Linux 和 μC/OS 等。这些东西了解即可，不用死记硬背，换句话说——不考。</p><h1 id="第二章-uC-OS-II-中的任务（重点）"><a href="#第二章-uC-OS-II-中的任务（重点）" class="headerlink" title="第二章 uC/OS-II 中的任务（重点）"></a>第二章 uC/OS-II 中的任务（重点）</h1><h2 id="任务的基本概念"><a href="#任务的基本概念" class="headerlink" title="任务的基本概念"></a>任务的基本概念</h2><p>从应用程序设计的角度，uC/OS-II 的任务就是一个<em>线程</em></p><p>uC/OS-II 任务的组成：</p><ul><li>任务代码：任务的执行部分 </li><li>任务堆栈：保存任务工作环境 </li><li>任务控制块：保存任务的属性</li></ul><p>uC/OS-II 的任务有两种：</p><ul><li>用户任务：由应用程序设计者编写的任务</li><li>系统任务：系统提供的任务 </li></ul><p>预定义了两个系统任务：<em>空闲任务</em>和<em>统计任务</em>。系统在某个时间内无用户任务可运行而处于空闲状态，为使 CPU 在没有用户任务可执行时有事可做，uC/OS-II 提供了空闲任务。统计任务每秒计算一次 CPU 在单位时间内被使用的时间，并把计算结果以百分比的形式存放在变量 OSCPUsage 中，以便应用程序通过访问它来了解 CPU 的利用率。</p><p>任务的5种状态：睡眠状态、就绪状态、运行状态、等待状态、中断服务状态</p><p><img src="task_state_transition.png" alt="任务状态转换图"></p><p>uC/OS-II 最多可以对 <em>64</em> 个任务进行管理，其中系统任务（预留）8 个，用户任务 56 个</p><p>每个任务都必须具有一个唯一的优先级别，0～63 共 64 个优先级别，数字越小，优先级别越高</p><p>在文件 OS_CFG.H 中常数 OS_LOWEST_PRIO 表示最低优先级 </p><p>任务个数：OS_LOWEST_PRIO + 1，其中 OS_LOWEST_PRIO 自动赋给空闲任务，OS_LOWEST_PRIO－1 自动赋给统计任务（存在的话）</p><p><img src="%E4%BE%8B2-3.png" alt="例2-3"></p><p>任务的优先级别为 28 个即 0～27，则最低优先级别的常数 OS_LOWEST_PRIO 值为 27，应用程序中使用了系统提供的空闲任务和统计任务，则应用程序最多可以安排 28-2 = 26 个任务。</p><h2 id="任务堆栈"><a href="#任务堆栈" class="headerlink" title="任务堆栈"></a>任务堆栈</h2><p>任务的重要组成部分；每个任务都配有自己的堆栈；满足任务切换和响应中断时保护CPU寄存器中的内容及存储任务私有数据的需要；</p><p>在文件 OS_CPU.H 中的数据类型 OS_STK </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> OS_STK;        <span class="comment">//该类型长度为16位 </span></span><br></pre></td></tr></table></figure><p>在应用程序中定义 OS_STK 类型的一个数组 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> TASK_STK_SIZE 512     <span class="comment">//定义堆栈长度 </span></span></span><br><span class="line">OS_STK TaskStk[TASK_STK_SIZE];       <span class="comment">//定义数组</span></span><br></pre></td></tr></table></figure><p><img src="OSTaskCreate.png" alt="OSTaskCreate()原型"></p><p><img src="%E4%BE%8B2-4.png" alt="例 2-4"></p><p>堆栈的增长方向是随系统所使用的处理器不同而不同,例 2-4 是假设使用了支持堆栈向下增长方式的处理器，如果使用堆栈增长方向向上的形式则如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OSTaskCreat(MyTask, &amp;MyTaskAgu, &amp;MyTaskStk[<span class="number">0</span>], <span class="number">20</span>);</span><br></pre></td></tr></table></figure><h2 id="任务控制块及其链表"><a href="#任务控制块及其链表" class="headerlink" title="任务控制块及其链表"></a>任务控制块及其链表</h2><p>任务控制块（OS_TCB）：用来记录任务的堆栈指针、任务的当前状态、任务的优先级别等一系列与任务管理有关的属性的表 </p><p>用两条链表来管理任务控制块：</p><ul><li>空任务控制块链表：应用程序调用函数 OSInit() 对 uC/OS-II 系统进行初始化时建立的单向链表 </li><li>任务控制块链表：应用程序调用 OSTaskCreate() 创建任务时建立的双向链表</li></ul><p>OSTCBInit() 的主要任务如下：</p><ul><li>为被创建任务从空任务控制块链表获取一个任务控制块；</li><li>用任务的属性对任务控制块各个成员进行赋值；</li><li>把这个任务控制块链入到任务控制块链表；</li></ul><p>**OSTCBPrioTbl[ ]**：以任务优先级为下标，保存任务控制块指针的数组。</p><p>为什么要对TCB进行初始化？ </p><ul><li>获得任务控制块 </li><li>保存任务属性</li></ul><h2 id="任务就绪表及任务调度"><a href="#任务就绪表及任务调度" class="headerlink" title="任务就绪表及任务调度"></a>任务就绪表及任务调度</h2><p>uC/OS-II进行调度的思想 </p><ul><li>每时每刻总是让优先级最高的就绪任务处于运行状态 </li><li>在系统或用户任务调用系统函数及执行中断服务程序 结束时，调用调度器来确定应该运行的任务并运行它</li></ul><p><em>任务就绪表</em>：OSRdyTbl[ ]数组，无符号8位数，一个元素可表达8个任务的就绪状态（1/0）</p><p>变量 <em>OSRdyGrp</em> 位数对应 OSRdyTbl[ ] 的下标，即组号；状态表示该组有无任务就绪</p><p>把优先级看成一个 6 位二进制数，表示范围为 0 ~ 63 共 64 个任务</p><ul><li>用高 3 位表示 OSRyGrp 的具体数据位（组号），即任务就绪表数组元素的下标</li><li>低 3 位表示数组元素的具体数据位（位置号）</li></ul><p><img src="%E4%BE%8B2-5.png" alt="例 2-5"></p><p><em>简单点的方法</em>：不需要把 49 化成二进制再分别取高低三位，直接用 49 / 8 = 6…1 可知应该在 OSRdyTbl[6] 的 D1 位上置 1，同时要把变量 OSRdyGrp 的 D6 位置 1。又如书 P74 例 3-5 给的优先级别 prio = 30 ,用同样方法 30 / 8 = 3…6 可知应该在 OSRdyTbl[3] 的 D6 位上置 1，同时要把变量 OSRdyGrp 的 D3 位置 1。 </p><p>OSMapTbl[ ] 是为加快运算速度定义的一个数组，它的各元素值为： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OSMapTbl[<span class="number">0</span>] = <span class="number">00000001B</span>;</span><br><span class="line">OSMapTbl[<span class="number">1</span>] = <span class="number">00000010B</span>; </span><br><span class="line">OSMapTbl[<span class="number">2</span>] = <span class="number">00000100B</span>; </span><br><span class="line">OSMapTbl[<span class="number">3</span>] = <span class="number">00001000B</span>; </span><br><span class="line">OSMapTbl[<span class="number">4</span>] = <span class="number">00010000B</span>; </span><br><span class="line">OSMapTbl[<span class="number">5</span>] = <span class="number">00100000B</span>; </span><br><span class="line">OSMapTbl[<span class="number">6</span>] = <span class="number">01000000B</span>; </span><br><span class="line">OSMapTbl[<span class="number">7</span>] = <span class="number">10000000B</span>;</span><br></pre></td></tr></table></figure><p><strong>登记</strong>：在程序中，用下面的代码把优先级别为prio的任务置为就绪状态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OSRdyGrp |= OSMapTbl[prio&gt;&gt;<span class="number">3</span>];   </span><br><span class="line">OSRdyTbl[prio&gt;&gt;<span class="number">3</span>] |= OSMapTbl[prio&amp;<span class="number">0x07</span>]; </span><br></pre></td></tr></table></figure><blockquote><p>举例 prio = 30 = 011 110<br>OSRdyGrp 的 D3 位置 1<br>OSRdyGrp = OSRdyGrp | OSMapTbl[3] = OSRdyGrp | 00001000<br>OSRdyTbl[3] 的 D6 位置 1<br>OSRdyTbl[3] = OSRdyTbl[3] | OSMapTbl[6] = OSRdyTbl[3] | 01000000</p></blockquote><p><strong>注销</strong>：使一个优先级别为prio的任务脱离就绪状态 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((OSRdyTbl[prio&gt;&gt;<span class="number">3</span>] &amp;= -OSMapTbl[prio&amp;<span class="number">0x07</span>])==<span class="number">0</span>) </span><br><span class="line">  OSRdyGrp &amp;= -OSMapTbl[prio&gt;&gt;<span class="number">3</span>]; </span><br></pre></td></tr></table></figure><blockquote><p>举例 prio = 30 = 011 110<br>if(OSRdyTbl[3] &amp;= 10111111 == 0) 将 OSRdyTbl[3] 的 D6 位置 0，如果 OSRdyTbl[3] == 0 即所有任务都处于非就绪状态<br>OSRdyGrp = OSRdyGrp &amp; 11110111   OSRdyGrp 的 D3 位置 0 ，其它位不变 </p></blockquote><p><strong>查找最高优先级</strong>： 从任务就绪表中获得优先级别最高的就绪任务 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Y = OSUnMapTbl[OSRdyGrp]; <span class="comment">//获得优先级别高3位 </span></span><br><span class="line">X = OSUnMapTbl[OSRdyTbl[y]];    <span class="comment">//获得优先级别低3位 </span></span><br><span class="line">Prio = (y&lt;&lt;<span class="number">3</span>) + x; <span class="comment">//获得就绪任务的优先级别 </span></span><br><span class="line">或 </span><br><span class="line">Y = OSUnMapTbl[OSRdyGrp]; </span><br><span class="line">Prio = (INT8U)((y&lt;&lt;<span class="number">3</span>) + OSUnMapTbl[OSRdyTbl[y]]); </span><br><span class="line"></span><br><span class="line">INT8U <span class="keyword">const</span> OSUnMapTbl[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, </span><br><span class="line">    <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, </span><br><span class="line">    <span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, </span><br><span class="line">    <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, </span><br><span class="line">    <span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, </span><br><span class="line">    <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, </span><br><span class="line">    <span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, </span><br><span class="line">    <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, </span><br><span class="line">    <span class="number">7</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, </span><br><span class="line">    <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, </span><br><span class="line">    <span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, </span><br><span class="line">    <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, </span><br><span class="line">    <span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, </span><br><span class="line">    <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, </span><br><span class="line">    <span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, </span><br><span class="line">    <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>辅助数组 OSUnMapTbl[ ] 的赋值过程（分析较长，可跳过）<br>变量 OSRdyGrp 格式如下：</p><table><thead><tr><th align="center">D7</th><th align="center">D6</th><th align="center">D5</th><th align="center">D4</th><th align="center">D3</th><th align="center">D2</th><th align="center">D1</th><th align="center">D0</th></tr></thead><tbody><tr><td align="center">1/0</td><td align="center">1/0</td><td align="center">1/0</td><td align="center">1/0</td><td align="center">1/0</td><td align="center">1/0</td><td align="center">1/0</td><td align="center">1/0</td></tr></tbody></table><p>分析 y = OSUnMapTbI[OSRdyGrp]; //优先级高三位</p><p>① D0=1时<br>表明OSRdyTbl[0]中有任务就绪，OSRdyTbl[0]中的任务优先级为0-7，则y应该为0，OSRdyGrp为奇数，故数组OSUnMapTbl中以奇数为下标的数组元素都应该为0；<br>② D1=1,D0=0时<br>表明OSRdyTbl[1]中有任务就绪，OSRdyTbl[1]中的任务优先级为8-15，则y应该为1，OSRdyGrp取值为2、6、10、14、18…，故数组 OSUnMapTbl中下标能被2整除且不能被4整除的数组元素值都应该为1；</p><p>③ D2=1,D1=0,D0=0时<br>表明OSRdyTbl[2]中有任务就绪，OSRdyTbl[2]中的任务优先级为16-23，则y应该为2，OSRdyGrp取值为4、12、20、28…，故数组 OSUnMapTbl中下标能被4整除且不能被8整除的数组元素值都应该为2；</p><p>④ D3=1,D2=0,D1=0,D0=0时<br>表明OSRdyTbl[3]中有任务就绪，OSRdyTbl[3]中的任务优先级为24-31，则y应该为3，OSRdyGrp取值为8、24、40、56…，故数组 OSUnMapTbl中下标能被8整除且不能被16整除的数组元素值都应该为3；</p><p>⑤ D4=1,D3=0,D2=0,D1=0,D0=0时<br>表明OSRdyTbl[4]中有任务就绪，OSRdyTbl[4]中的任务优先级为32-39，则y应该为4，OSRdyGrp取值为16、48、64、80…，故数组 OSUnMapTbl中下标能被16整除且不能被32整除的数组元素值都应该为4；</p><p>⑥ D5=1,D4=0,D3=0,D2=0,D1=0,D0=0时<br>表明OSRdyTbl[5]中有任务就绪，OSRdyTbl[5]中的任务优先级为40-47，则y应该为5，OSRdyGrp取值为32、96、160、224，故数组 OSUnMapTbl中下标能被32整除且不能被64整除的数组元素值都应该为5；</p><p>⑦ D6=1,D5=0,D4=0,D3=0,D2=0,D1=0,D0=0时<br>表明OSRdyTbl[6]中有任务就绪，OSRdyTbl[6]中的任务优先级为48-55，则y应该为6，OSRdyGrp取值为64、192，故数组 OSUnMapTbl中下标能被64整除且不能被128整除的数组元素值都应该为6；</p><p>⑧ D7=1,D6=0,D5=0,D4=0,D3=0,D2=0,D1=0,D0=0时<br>表明OSRdyTbl[7]中有任务就绪，OSRdyTbl[7]中的任务优先级为56-63，则y应该为7，OSRdyGrp取值为128，故数组OSUnMapTbl中下标为128的数组元素值应该为7；</p><p>调度器有两种：</p><ul><li>任务级调度器：OSSched() 函数 </li><li>中断级调度器：OSIntExit() 函数 </li></ul><p>任务调度主要工作有两项： </p><ul><li>在任务就绪表中查找具有最高优先级别的就绪任务 </li><li>实现任务切换 <ul><li>获得待运行任务的 TCB 指针 </li><li>进行断点数据的切换</li></ul></li></ul><p><img src="OSSched.png" alt="OSSched 源代码"></p><p>任务切换宏 OS_TASK_SW() 实际工作主要由 OSCtxSw 来完成，OSCtxSw() 依次完成的工作</p><ol><li>把被中止任务的断点指针保存到任务堆栈中</li><li>把 CPU 通用寄存器的内容保存到被中止任务的堆栈中 </li><li>把被中止任务的任务堆栈指针当前值保存到该任务的任务控制块的 OSTCBStkPtr 中 </li><li>获得待运行任务的任务控制块 </li><li>使 CPU 通过任务控制块获得待运行任务的任务堆栈指针 </li><li>把待运行任务堆栈中通用寄存器的内容恢复到 CPU 的通用寄存器中 </li><li>使 CPU 获得待运行任务的断点指针PC </li></ol><h2 id="任务的创建"><a href="#任务的创建" class="headerlink" title="任务的创建"></a>任务的创建</h2><p>有两个用来创建任务的函数： </p><ul><li>OSTaskCreate() </li><li>OSTaskCreateExt() </li></ul><p>调用函数OSStart()之前先创建一个任务，并赋予它最高的优先级别，从而使它成为起始任务；然后在这个任务中，再创建其它各任务。</p><p><img src="%E4%BE%8B2-7.png" alt="例 2-7"></p><p><img src="%E4%BE%8B2-71.jpg" alt="运行结果"></p><p>多任务程序分析方法：<em>时间轴法</em><br><img src="%E4%BE%8B2-72.png" alt="程序分析"></p><h2 id="任务的挂起和恢复"><a href="#任务的挂起和恢复" class="headerlink" title="任务的挂起和恢复"></a>任务的挂起和恢复</h2><p><img src="OSTaskSuspendResume.png" alt="任务的挂起和恢复"></p><p><em>挂起任务</em>函数 OSTaskSuspend() 和<em>恢复任务</em>函数 OSTaskResume() 的原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INT8U <span class="title">OSTaskSuspend</span> <span class="params">(INT8U prio)</span></span>;</span><br><span class="line"><span class="function">INT8U <span class="title">OSTaskResume</span> <span class="params">(INT8U prio)</span></span>;</span><br></pre></td></tr></table></figure><p>挂起任务自身时,函数参数为：OS_PRIO_SELF（<em>0xFF</em>） </p><h2 id="其他任务管理函数"><a href="#其他任务管理函数" class="headerlink" title="其他任务管理函数"></a>其他任务管理函数</h2><p>任务优先级别的修改 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INT8U <span class="title">OSTaskChangePrio</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">      INT8U oldprio, <span class="comment">//任务现在的优先级别 </span></span></span></span><br><span class="line"><span class="function"><span class="params">      INT8U newprio <span class="comment">//要修改的优先级别 </span></span></span></span><br><span class="line"><span class="function"><span class="params">      )</span></span>;</span><br></pre></td></tr></table></figure><p>任务的删除</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INT8U <span class="title">OSTaskDel</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">INT8U prio <span class="comment">//要删除任务的优先级别 </span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; </span><br></pre></td></tr></table></figure><ul><li>把被删除任务的任务控制块从任务控制块链表中删除，并归还给空任务控制块链表，然后在任务就绪表中把该任务的就绪状态置为0，于是该任务就不能再被调度了 </li><li>可以通过调用 OSTaskDel() 来删除任务自身或除了空闲任务之外的其它任务 </li><li>删除任务自己时，函数参数为：OS_PRIO_SELF</li><li>被动删除的任务，往往存在<em>动态分配资源丢失!!</em></li></ul><p>一般删除任务的方法</p><ul><li>提出删除任务请求的任务 A 只负责提出删除任务请求，而删除工作则由被删除任务 B 自己来完成</li><li>联络信号：OSTCBDelReq（ B 的任务控制块成员） </li><li>A 调用<strong>请求删除任务函数</strong>：OSTaskDelReq() </li><li>函数原型：INT8U OSTaskDelReq( INT8U prio ) //待删除任务的优先级别 </li><li>提出删除任务请求的调用参数：prio</li></ul><p>查询任务信息 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INT8U <span class="title">OSTaskQuery</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">INT8U prio, <span class="comment">//待查任务的优先级别 </span></span></span></span><br><span class="line"><span class="function"><span class="params">OS_TCB *pdata <span class="comment">//存储任务信息的结构 </span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="uC-OS-II的初始化和任务的启动"><a href="#uC-OS-II的初始化和任务的启动" class="headerlink" title="uC/OS-II的初始化和任务的启动"></a>uC/OS-II的初始化和任务的启动</h2><p>uC/OS-II的初始化（ OSInit() ） </p><ul><li>对所有的全局变量和数据结构进行初始化</li><li>创建空闲任务OSTaskIdle，并赋之以最低优先级和永远的就绪状态</li><li>如果常数 OS_TASK_STAT_EN = 1，则以优先级别为 OS_LOWEST_PRIO - 1 来创建统计任务 </li><li>OSInit() 对数据结构初始化 <ul><li>主要是创建包括空任务控制快链表在内的 5 个空数据缓冲区 <ul><li>空任务控制块链表</li><li>空队列控制块链表</li><li>空事件控制块链表</li><li>空标志组链表</li><li>空内存控制块链表</li></ul></li><li>创建数组 OSTCBPrioTbl[OS_LOWEST_PRIO+1]</li></ul></li></ul><h1 id="第三章-uC-OS-II的中断和时钟"><a href="#第三章-uC-OS-II的中断和时钟" class="headerlink" title="第三章 uC/OS-II的中断和时钟"></a>第三章 uC/OS-II的中断和时钟</h1><p><strong>中断响应过程</strong></p><ul><li>系统接收到中断请求后，这时如果CPU处于中断允许状态（即中断是开放的），系统就会中止正在运行的当前任务，而按照中断向量的指向转而去运行中断服务子程序；</li><li>当中断服务子程序的运行结束后，系统将会根据情况返回到被中止的任务继续运行或者转向运行另一个具有更高优先级别的就绪任务。</li></ul><p><strong>临界段</strong><br>在应用程序中经常有些代码段必须不受任何干扰地连续运行，这样的代码段叫做临界段</p><p><strong>时钟中断</strong></p><ul><li>uC/OS-II 用硬件定时器产生周期为毫秒级的周期性中断来实现时钟，最小时钟单位叫<em>时钟节拍</em></li><li>时钟节拍中断服务程序 OSTickISR（）</li><li>调用时钟节拍服务函数 OSTimeTick（）完成：<ul><li>给计数器 OSTime 加 1</li><li>遍历所有 TCB，将它们的 OSTCBDly 减 1</li><li>若 OSTCBDly 为 0，且任务未被挂起，将其置为就绪态并相应的修改就绪表</li></ul></li></ul><p><strong>延时函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">OSTimeDly(INT16U ticks);   <span class="comment">//参数 ticks 以时钟节拍数为单位的延时时间</span></span><br><span class="line"></span><br><span class="line">OSTimeDlyHMSM( </span><br><span class="line">INT8U hours,    <span class="comment">//时</span></span><br><span class="line">INT8U minutes,  <span class="comment">//分</span></span><br><span class="line">INT8U seconds,  <span class="comment">//秒</span></span><br><span class="line">INT8U milli,    <span class="comment">//毫秒</span></span><br><span class="line">)；</span><br><span class="line"></span><br><span class="line">INT8U OSTimeDlyResume（INT8U prio）;  <span class="comment">//取消任务延时</span></span><br></pre></td></tr></table></figure><h1 id="第四章-任务的同步与通信"><a href="#第四章-任务的同步与通信" class="headerlink" title="第四章 任务的同步与通信"></a>第四章 任务的同步与通信</h1><p><strong>任务同步</strong><br>为实现任务间的合作和无冲突运行，各任务间需建立制约关系。有两种制约关系：</p><ul><li>直接制约关系：源于任务间的合作</li><li>间接制约关系：源于对资源的共享/竞争</li></ul><p>任务间这种制约性的合作运行机制叫做任务间的<em>同步</em>，系统中的同步是依靠任务间互发消息来保证的！</p><p><strong>事件</strong><br>在 uC/OS-II 中，使用信号量、邮箱（消息邮箱）和消息队列这些被称为<strong>事件</strong>的中间环节来实现任务之间的通信。</p><ul><li><em>信号量</em> 是一类事件，使用它是为了建立一个标志来表示某共享资源被占用的情况</li><li>用来传递消息缓冲区指针的数据结构叫做<em>消息邮箱</em></li><li>可传递多个消息的数据结构叫做<em>消息队列</em></li></ul><p><strong>事件控制块</strong><br>uC/OS-II 使用 <em>事件控制块</em> ECB 的数据结构来描述诸如信号量、邮箱（消息邮箱）和消息队列这类事件</p><p><img src="ECB.png" alt="事件控制块 ECB"></p><p>采用类似于任务就绪表的 <em>任务等待表</em> 来完成对等待事件的任务的记录与排序</p><ul><li>等待时限记录在 TCB 成员 OSTCBDly 中；</li><li>当有任务的时限已到时，将其从任务等待表中删除，并设置任务就续表，使其进入就绪状态；</li></ul><p><em>空事件控制块链表</em>：uC/OS-II 初始化时，函数 OSInit() 创建 OS_MAX_EVENTS 个空事件控制块并借用成员 OSEventPtr 将它们链接成一个单向链表</p><ul><li>当新创建一个事件时，从该空事件控制块链表取下一个空 ECB 并对其初始化</li><li>当删除一个事件时，将事件的 ECB 归还给空事件控制块链表</li></ul><p><strong>信号量及其操作</strong><br>信号量两部分组成：</p><ul><li>信号量计数器</li><li>任务等待表</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建信号量 </span></span><br><span class="line"><span class="function">OS_EVENT * <span class="title">OSSemCreate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">       INT16U cnt <span class="comment">// 信号量计数器初值</span></span></span></span><br><span class="line"><span class="function"><span class="params">       )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求信号量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OSSemPend</span> <span class="params">(OS_EVENT *pevent,  <span class="comment">//信号量的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                INT16U timeout,   <span class="comment">//等待时限</span></span></span></span><br><span class="line"><span class="function"><span class="params">                INT8U *err  <span class="comment">//错误信息</span></span></span></span><br><span class="line"><span class="function"><span class="params">               )</span></span>;    </span><br><span class="line"><span class="comment">// 信号量请求函数 OSSemAccept() 允许任务在信号量无效时不进入等待状态而继续运行</span></span><br><span class="line"><span class="function">INT16U <span class="title">OSSemAccept</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">   OS_EVENT * pevent <span class="comment">//信号量的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">   )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送信号量</span></span><br><span class="line"><span class="function">INT8U <span class="title">OSSemPost</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">OS_EVENT * pevent <span class="comment">//信号量的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>优先级反转</strong></p><ul><li>定义：在可剥夺型内核中，当某任务以独占方式共享资源时，会出现低优先级任务先于高优先级任务而被运行的现 象，这叫做优先级反转</li><li>产生优先级反转的原因：一个低优先级的任务在获得了信号量使用共享资源时，被具有较高优先级的任务打断而不能释放信号量，从而使正在等待这个信号量的更高优先级的任务因得不到信号量而被迫处于等待状态。在这个等待期间，就让优先级别低于它而高于占据信号量的任务的任务先运行</li><li>对系统的影响：优先级反转极大的恶化了高优先级任务的运行环境，是实时系统所无法容忍的</li></ul><p><img src="priority_inversion.png"></p><ul><li>根本原因：使用信号量的任务能否运行受到 <em>任务的优先级别</em> 和 <em>是否占有信号量</em> 两个条件的约束</li><li><strong>互斥型信号量</strong>是一个二值信号量，解决任务在使用独占式资源出现的优先级反转问题</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建互斥信号量</span></span><br><span class="line"><span class="function">OS_EVENT *<span class="title">OSMutexCreate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                        INT8U prio, <span class="comment">// 优先级别</span></span></span></span><br><span class="line"><span class="function"><span class="params">                        INT8U * err <span class="comment">// 错误信息</span></span></span></span><br><span class="line"><span class="function"><span class="params">                        )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求互斥型信号量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OSMutexPend</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                OS_EVENT * pevent, <span class="comment">//互斥型信号量指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                INT16U timeout, <span class="comment">//等待时限</span></span></span></span><br><span class="line"><span class="function"><span class="params">                INT8U * err <span class="comment">//错误信息</span></span></span></span><br><span class="line"><span class="function"><span class="params">                )</span></span>;</span><br><span class="line"><span class="comment">// 也可调用 OSMutexAccept() 无等待的请求信号量</span></span><br><span class="line"><span class="function">INT8U <span class="title">OSMutexAccept</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                    OS_EVENT * pevent, <span class="comment">//互斥型信号量指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    INT8U * err <span class="comment">//错误信息</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    )</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送互斥型信号量</span></span><br><span class="line"><span class="function">INT8U <span class="title">OSMutexPost</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                    OS_EVENT * pevent <span class="comment">//互斥型信号量指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    )</span></span>;</span><br></pre></td></tr></table></figure><p><strong>消息邮箱及其操作</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建消息邮箱</span></span><br><span class="line"><span class="function">OS_EVENT * <span class="title">OSMboxCreate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">void</span> * msg <span class="comment">// 消息指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                        )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向邮箱发送消息</span></span><br><span class="line"><span class="function">INT8U <span class="title">OSMboxPost</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                OS_EVENT * pevent, <span class="comment">//消息邮箱指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">void</span> * msg <span class="comment">//消息指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求消息邮箱</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">OSMboxPend</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                OS_EVENT * pevent, <span class="comment">//请求消息邮箱指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                INT16U timeout, <span class="comment">//等待时限</span></span></span></span><br><span class="line"><span class="function"><span class="params">                INT8U * err <span class="comment">//错误信息</span></span></span></span><br><span class="line"><span class="function"><span class="params">                )</span></span>; </span><br><span class="line"><span class="comment">// 也可调用 OSMboxAccept() 无等待请求邮箱</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">OSMboxAccept</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                    OS_EVENT * pevent <span class="comment">//消息邮箱指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    )</span></span>; </span><br></pre></td></tr></table></figure><p><strong>消息队列及其操作</strong></p><ul><li>消息队列包含：事件控制块、消息队列、消息</li><li>消息队列的核心是<em>消息指针数组</em></li><li>向指针数组插入消息指针有两种方式：FIFO 和  LIFO</li><li>uC/OS-II 初始化时，创建由 OS_MAX_QS 个队列控制块组成的 <em>空队列控制块链表</em></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建消息队列</span></span><br><span class="line"><span class="function">OS_EVENT <span class="title">OSQCreate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">void</span> * * start, <span class="comment">//指针数组的地址</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    INT16U size <span class="comment">//数组长度</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求消息队列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">OSQPend</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                OS_EVENT * pevent, <span class="comment">//所请求的消息队列的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                INT16U timeout, <span class="comment">//等待时限</span></span></span></span><br><span class="line"><span class="function"><span class="params">                INT8U * err <span class="comment">//错误信息</span></span></span></span><br><span class="line"><span class="function"><span class="params">                )</span></span>;</span><br><span class="line"><span class="comment">// 调用函数 OSQAccept() 可以无等待的请求队列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">OSQAccept</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                OS_EVENT * pevent <span class="comment">//所请求的消息队列的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向消息队列发送消息</span></span><br><span class="line"><span class="comment">// 以 FIFO 方式组织消息队列</span></span><br><span class="line"><span class="function">INT8U <span class="title">OSQPost</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                OS_EVENT * pevent, <span class="comment">//消息队列的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">void</span> * msg <span class="comment">//消息指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                )</span></span>;</span><br><span class="line"><span class="comment">// 以LIFO方式组织消息队列</span></span><br><span class="line"><span class="function">INT8U <span class="title">OSQPostFront</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                    OS_EVENT * pevent, <span class="comment">//消息队列的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">void</span> * msg <span class="comment">//消息指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    )</span></span>;</span><br></pre></td></tr></table></figure><p><strong>例  4 -9 （ P180 ）</strong></p><p><img src="%E4%BE%8B4-9.png" alt="例 4 - 9"></p><p>任务优先级：S&gt;M&gt;Y，后进先出方式发送消息<br>0 秒开始 S 依次发送了s0、s100、s1，延时 1 秒，M 请求消息队列输出 s1，延时 1 秒，Y 请求消息，输出 s100，延时 1 秒，1 秒时，S又发送了 s100 和 s1，同样 M Y 依次请求消息队列，输出 s1 s100，2 秒时，S 没有发送，延时 1 秒，M请求消息队列，输出 s0，Y 没有请求到等待，N 秒时，三个任务都就绪，S发送 s500延时 1 秒，M 请求消息队列，输出 s500，延时1 秒，N+1 秒时，Y 请求消息队列输出 s500，M 等待，N+2 秒时，M 请求消息队列输出 s500，Y 等待。。。</p><h1 id="第五章-信号量集"><a href="#第五章-信号量集" class="headerlink" title="第五章 信号量集"></a>第五章 信号量集</h1><p><strong>信号量集由两部分组成：</strong></p><ul><li>标志组：存放了信号量集中的所有信号</li><li>等待任务链表：每个节点都对应一个正在等待信号量集的等待任务</li></ul><p>uC/OS-II 初始化时，系统创建 OS_MAX_FLAGS 个标志组，并将其连接成一个<em>空标志组链表</em></p><p><strong>信号量集的操作</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建信号量集</span></span><br><span class="line"><span class="function">OS_FLAG_GRP * <span class="title">OSFlagCreate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                            OS_FLAGS flags; <span class="comment">// 信号量的初始值</span></span></span></span><br><span class="line"><span class="function"><span class="params">                            INT8U * err     <span class="comment">// 错误信息</span></span></span></span><br><span class="line"><span class="function"><span class="params">                            )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求信号量集</span></span><br><span class="line"><span class="function">OS_FLAGS <span class="title">OSFlagPend</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                    OS_FLAG_GRP * pgrp, <span class="comment">// 所请求的信号量集的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    OS_FLAGS flags, <span class="comment">// 滤波器</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    INT8U wait_type, <span class="comment">// 逻辑运算类型</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    INT16U timeout, <span class="comment">// 等待时限</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    INT8U *err         <span class="comment">// 错误信息</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    )</span></span>;</span><br><span class="line"><span class="comment">// 无等待请求信号量集</span></span><br><span class="line"><span class="function">OS_FLAGS <span class="title">OSFlagAccept</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                    OS_FLAG_GRP * pgrp, <span class="comment">// 所请求的信号量集的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    OS_FLAGS flags, <span class="comment">// 滤波器</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    INT8U wait_type, <span class="comment">// 逻辑运算类型</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    INT8U *err         <span class="comment">// 错误信息</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向信号量集发信号</span></span><br><span class="line"><span class="function">OS_FLAGS <span class="title">OSFlagPost</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                    OS_FLAG_GRP * pgrp, <span class="comment">//信号量集的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    OS_FLAGS flags, <span class="comment">//选择要发送的信号</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    INT8U opt, <span class="comment">//信号有效的选项</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    INT8U *err <span class="comment">//错误信息</span></span></span></span><br><span class="line"><span class="function"><span class="params">                )</span></span>;</span><br></pre></td></tr></table></figure><p><strong>例 5 - 1 （ P195 ）</strong><a href="https://github.com/gzwangu/uCOS-II-semaphore-set">源代码</a></p><p><img src="%E4%BE%8B5-1.png"></p><p><img src="%E4%BE%8B5-11.jpg" alt="例 5 - 1"></p><p>任务优先级 MyTask &gt; YouTask &gt; HerTask</p><p>任务开始 MyTask 优先级最高请求不到信号量集处于等待状态，YouTask 开始运行，输出 S2，延时 8 秒，接着 HerTask 连续运行，输出 8 个 S3，第 8 秒时，YouTask 运行发送信号量集，这时两个任务都发送了信号，发送完被高优先级 MyTask 打断，MyTask 输出 S1 延时 2 秒，接着 YouTask 继续运行，延时两秒，HerTask 输出 S3 延时 1 秒，到第 9 秒后，HerTask 输出 S3 延时 1 秒，第10 秒，MyTask 输出 S1 延时 2 秒，YouTask 输出 S2，延时 8 秒，HerTask 输出 S3 延时 1 秒…</p><p>把 MyTask 修改为无等待请求信号量集 OSFlagAccept()<br><img src="%E4%BE%8B5-2.png" alt="例 5 - 2"></p><h1 id="第六章-内存的动态分配"><a href="#第六章-内存的动态分配" class="headerlink" title="第六章 内存的动态分配"></a>第六章 内存的动态分配</h1><p><strong>内存的两级管理</strong><br>把一个连续的内存空间分成若干个分区，每个分区又分成了若干大小相等的内存块来管理</p><p><strong>动态内存的管理</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建动态内存分区</span></span><br><span class="line"><span class="function">OS_MEM * <span class="title">OSMemCreate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">void</span> * addr, <span class="comment">//内存分区的起始地址</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    INT32U nblks, <span class="comment">//分区中内存块的数目</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    INT32U blksize, <span class="comment">//每个内存块的字节数</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    INT8U * err <span class="comment">//错误信息</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求获得一个内存块</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">OSMemGet</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                OS_MEM * pmem, <span class="comment">//内存分区的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                INT8U * err <span class="comment">//错误信息</span></span></span></span><br><span class="line"><span class="function"><span class="params">                )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放一个内存块</span></span><br><span class="line"><span class="function">INT8U <span class="title">OSMemPut</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                OS_MEM * pmem, <span class="comment">//内存块所属内存分区的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">void</span> * pblk <span class="comment">//待释放内存块的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                )</span></span>;</span><br></pre></td></tr></table></figure><p><img src="%E4%BE%8B6-1.png" alt="例 6 - 1"></p><h1 id="第七章-在51单片机上移植-uCOS-II"><a href="#第七章-在51单片机上移植-uCOS-II" class="headerlink" title="第七章 在51单片机上移植 uCOS-II"></a>第七章 在51单片机上移植 uCOS-II</h1><p><strong>可重入函数</strong><br>在多任务操作系统中，系统提供的函数应该能允许同时被多个任务所调用，而不会通过函数中变量的耦合引起任务之间的互相干扰。</p><p><strong>系统堆栈</strong><br>片内RAM中的公用堆栈，只存放运行的任务堆栈</p><p><strong>任务堆栈映象</strong><br>片外RAM中用来存放任务堆栈内容的区域</p><p><strong>系统堆栈与任务堆栈映象的关系</strong></p><ul><li>51 单片机要求堆栈必须设置在片内RAM中，51单片机的片内 RAM 极其有限，不可能把应用程序中所有任务的任务堆栈都设置在片内RAM中</li><li>解决办法：把应用程序中各个任务堆栈的内容存放在片外RAM中的任务堆栈映象中，而只在片内 RAM 中设置一个公用的系统堆栈</li></ul><h1 id="第八章-在ARM7上移植uCOS-II"><a href="#第八章-在ARM7上移植uCOS-II" class="headerlink" title="第八章 在ARM7上移植uCOS-II"></a>第八章 在ARM7上移植uCOS-II</h1><p><strong>工作模式的选择映像</strong></p><p>系统模式和用户模式</p><p><strong>处理器相关的移植文件</strong></p><ul><li>OS_CPU.H</li><li>OS_CPU_C.C</li><li>OS_CPU_A.S</li></ul><p>如果你看到这，恭喜这本书的主要内容已经掌握了，考试肯定不是问题，下面分享下干货！</p><h1 id="干货"><a href="#干货" class="headerlink" title="干货"></a>干货</h1><p><strong>这是老师给的知识点总结：</strong></p><p>第2章 uC/OS-II中的任务<br>1、任务的基本概念<br>2、任务堆栈<br>3、任务控制块<br>4、任务就续表及其操作<br>5、任务调度、任务切换<br>6、任务调度器函数OSSched()<br>7、任务创建<br>8、任务的挂起和恢复<br>9、请求删除任务函数<br>10、任务初始化</p><p>第3章 uC/OS-II的中断和时钟<br>1、中断响应过程<br>2、临界段的概念<br>3、时钟中断<br>4、延时函数</p><p>第4章 任务的同步与通信<br>1、任务同步<br>2、事件<br>3、事件控制块<br>4、事件的操作（创建、发送、请求）<br>5、优先级反转<br>6、相关例题（例8、例9）</p><p>第5章 信号量集<br>1、信号量集<br>2、信号量集的操作（创建、请求和发送）<br>3、相关例题（例1）</p><p>第6章 内存的动态分配<br>1、内存的管理<br>2、内存分区的组织<br>3、动态内存的管理（创建、请求、释放）（例1、例2）</p><p>第7章 在51单片机上移植uCOS-II<br>1、可重入函数<br>2、系统堆栈和任务堆栈</p><p>第8章 在ARM7上移植uCOS-II<br>1、工作模式的选择映像<br>2、与处理器相关的移植文件</p><p><strong>在此基础上本人详细的罗列了一些考点：</strong></p><p>任务组成<br>两种系统任务<br>64个任务<br>任务5中状态<br>OS_LOWEST_PRIO<br>堆栈增长方向，影响 OSTaskCreate 函数任务堆栈栈顶指针参数  P66<br>OSTCBPrioTbl 数组：以任务的优先级为下标，保存任务的任务控制块指针的数组<br>任务就绪表操作：登记、注销、最高优先级就绪任务查找  会写<br>为什么管理64个任务：OSRdyTbl[ ] 有8个数组元素，每个元素都是8位二进制数，可表示8个任务的就绪状态，所以系统最多可以管理8x8=64个任务<br>OSSched() 函数代码加黑部分要会写 P77<br>任务切换7个步 P79<br>挂起自身  OXFF<br>删除任务过程：提出删除任务请求的任务调用请求删除任务函数，改变联络信号值，当被删除任务查到信号值改变，会在适当的时候删除自身。<br>初始化5个链表：空任务控制块链表、空事件控制块链表、空队列控制块链表、空标志组链表、空内存控制块链表</p><p>中断响应过程<br>OSTimeTick 做的三件事  PPT上有，书上说了 2 件，其实也是 3 件<br>OSTimeTick 代码懂且能写出来<br>两个延时函数  OSTimeDly 和 OSTimeDlyHMSM</p><p>事件（信号量、消息邮箱、消息队列）的操作（创建、请求、发送）  能看懂代码<br>优先级反转：定义、过程、解决方法（使用互斥信号量）<br>例8  例9   会分析解释  时间轴法</p><p>信号量集的操作<br>例1  会分析解释</p><p>内存二级管理<br>例1、2  看懂会写吧</p><p>可重入函数定义<br>系统/任务堆栈</p><p>用户模式/系统模式<br>3个移植文件：OS_CPU.H、OS_CPU_C.C、OS_CPU_A.S</p><p><strong>最后个干货，中国矿业大学2019-2020 第一学期嵌入式操作系统 A 卷：</strong></p><p>一、简答题（50分）</p><ol><li>任务的分类</li><li>可以管理多少任务？从 OSRdyTbl[ ] 解释之</li><li>给一个 prio = 29，注销操作，哪一位置 0</li><li>中断响应过程</li><li>能否使用全局变量来实现任务间的通信? 如果可以，有什么缺点?</li></ol><p>二、程序填空（20分，会给注释）</p><ol><li>任务的创建源代码</li><li>OSSched() 函数</li><li>OSTimeTick() 函数</li><li>写信号量集的请求的例子</li></ol><p>三、综合（30分，都是书上的例子）</p><ol><li>任务挂起与恢复</li><li>消息队列</li></ol>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> uCOS-II </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于树莓派的人脸识别门禁系统</title>
      <link href="2020/04/25/%E5%9F%BA%E4%BA%8E%E6%A0%91%E8%8E%93%E6%B4%BE%E7%9A%84%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E9%97%A8%E7%A6%81%E7%B3%BB%E7%BB%9F/"/>
      <url>2020/04/25/%E5%9F%BA%E4%BA%8E%E6%A0%91%E8%8E%93%E6%B4%BE%E7%9A%84%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E9%97%A8%E7%A6%81%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>本文介绍了家庭门禁管理系统的一种设计方案，基于旷视云平台的人脸识别技术实现了一款智能门禁系统，使用Face++人脸识别进行实时人脸分析，不仅使用便利，而且保证了识别数据的有效性和准确性，系统分为硬件和软件两个部分，硬件以树莓派4B为控制核心，外接摄像头、步进电机、蜂鸣器、触摸开关等模块；软件部分基于旷视云平台，构建了在不同操作环境下信息管理与控制系统，通过应用场景模拟对系统进行试验，结果表明：该系统运行可靠，外接模块以及系统电路运行良好，识别准确率高，电机响应平均时间为0.5s，消息远程收发功能、信息管理与控制系统的相关功能均可正常执行。</p><h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="课题背景"><a href="#课题背景" class="headerlink" title="课题背景"></a>课题背景</h2><p>随着计算机网络技术的发展成熟，在给我们带来便捷的同时，也带来了运用高新技术手段进性偷盗、抢劫等违法犯罪问题，家庭安全问题越来越受到人们的重视，现代人工智能的安防领域也有了极大的突破和进展，出现了各种身份识别方法。其中最热门的、被关注最多的就是人脸识别，而人脸识别算法也从过去单一的模式识别到如今的多算法提取，从二维平面图像到多维建模生物识别。人脸识别技术凭借其自身的实用性及可靠性得到了广泛的认可，对采用人脸识别方式作为门禁管理系统的小区而言，不仅可以将社区管理提高一个档次、同时节省许多管理成本，而且能够有效地保障社区安全。此外近年来，基于Linux的单片机计算机也已逐渐发展成熟，并以其低价、自由的特点被广泛使用。因此本文将人脸识别与嵌入式、树莓派等相融合，设计出一套高安全级别的门禁管理系统。</p><h2 id="设计任务与要求"><a href="#设计任务与要求" class="headerlink" title="设计任务与要求"></a>设计任务与要求</h2><p>（1）以家庭智能门禁系统为背景，通过调研、分析现有的门禁系统，建立系统模型；完成软硬件结构设计和数据库设计；</p><p>（2）系统要实现智能开关门、记录门禁信息、远程控制和人员管理等功能；</p><p>（3）系统要实现满足多种条件的统计分析功能，有些统计数据要采用图表的格式呈现；</p><p>（4）系统要具有安全性、准确性和高效率，能够改善传统安防领域的方便性、直观性；</p><h1 id="系统设计需求分析"><a href="#系统设计需求分析" class="headerlink" title="系统设计需求分析"></a>系统设计需求分析</h1><h2 id="开发环境及开发平台"><a href="#开发环境及开发平台" class="headerlink" title="开发环境及开发平台"></a>开发环境及开发平台</h2><p>Windows10操作系统、Visual Studio Code编译器（Python 3.8）、FinalShell SSH工具、windows远程桌面连接；</p><p>Raspbian操作系统、Thonny 编译器（Python 3.6）；</p><h2 id="系统的组成及工作原理"><a href="#系统的组成及工作原理" class="headerlink" title="系统的组成及工作原理"></a>系统的组成及工作原理</h2><p>系统主要有两大部分组成：硬件部分和软件部分。硬件主要包括树莓派主控设备、触摸开关、图像采集设备、警报设备和步进电机模块。软件主要有基于Flask框架的web可视化界面。</p><p>当有人触摸开关时，触发人脸识别主函数进行实时拍照并将此照片发送至Face++云服务中心进行分析，云服务得出上传图像的人脸参数，并把参数跟已经预存在人脸数据库中的面部信息进行比对，将比对结果传回到树莓派．确认识别成功后控制步进电机转动，若人脸不匹配则触发警报，同时记录下本次的识别数据。</p><p><img src="raspberrypi.png" alt="系统组成实物图"> </p><h2 id="设计的重点与难点"><a href="#设计的重点与难点" class="headerlink" title="设计的重点与难点"></a>设计的重点与难点</h2><p>本系统设计重点在于人脸检测分析及人脸比对、系统整体软硬件架构；</p><p>难点有硬件设备的安装与调试、前端网页的设计与代码编写，frp 可用于内网穿透的高性能的反向代理应用，使用frp实现内网穿透远程实时监控。Face++的人脸库数据操作有两种方式，一种直接在Face++云的控制中心上传，另一种是通过代码的方式进行操作．第一种方式虽然可以直接使用，但对于用户来说，整个操作过程还是较为繁琐．为方便对云平台人脸数据库进行管理，需要建立一个用户管理系统界面。</p><h1 id="系统的总体设计"><a href="#系统的总体设计" class="headerlink" title="系统的总体设计"></a>系统的总体设计</h1><h2 id="系统功能层次图"><a href="#系统功能层次图" class="headerlink" title="系统功能层次图"></a>系统功能层次图</h2><p><img src="systemoverall.png" alt="系统功能层次图"> </p><h2 id="系统功能描述"><a href="#系统功能描述" class="headerlink" title="系统功能描述"></a>系统功能描述</h2><p>基于树莓派的人脸识别门禁系统硬件主要包括树莓派主控设备、图像采集设备、触摸模块、步进电机模块和警报模块。本文的智能门禁系统设计具有半自动的特点，系统运行时树莓派会将采集到的面部图像发送至云端服务中心进行分析，云端服务中心得出上传图像的人脸参数，并把参数跟已经预存在人脸数据库中的面部信息进行比对，得到相似度结果，然后再将得到的数据从云端反馈回下位机主控设备。触摸传感器触发人脸识别主函数进行实时拍照并将此照片发送至云服务中心处理并将比对结果传回到树莓派。确认识别成功后控制步进电机转动，并将结果显示在树莓派终端，否则触发警报模块，同时记录下本次的识别数据。Web客户端可远程查看实时监控画面、人员管理（增加和删除人脸）、查看门禁记录和开关门操作等功能</p><h1 id="系统的模块设计"><a href="#系统的模块设计" class="headerlink" title="系统的模块设计"></a>系统的模块设计</h1><h2 id="界面（UI）设计"><a href="#界面（UI）设计" class="headerlink" title="界面（UI）设计"></a>界面（UI）设计</h2><h3 id="界面布局示意图"><a href="#界面布局示意图" class="headerlink" title="界面布局示意图"></a>界面布局示意图</h3><p><img src="login.png" alt="登录界面"> </p><p><img src="main.png" alt="主界面"> </p><p><img src="record.png" alt="门禁记录界面"> </p><p><img src="family.png" alt="家庭成员界面"> </p><h3 id="界面控件（或部件）设计"><a href="#界面控件（或部件）设计" class="headerlink" title="界面控件（或部件）设计"></a>界面控件（或部件）设计</h3><p>主要设计四个界面：登录界面、主界面、门禁记录界面和人员管理界面。</p><p>登录界面主要包括用户名及密码输入，登录按钮；</p><p>主界面有显示实时监控画面、退出登录按钮、开关门按钮、人员管理按钮和门禁记录按钮；</p><p>人员管理界面主要有家庭成员列表，增加或删除家庭人员等控件；</p><p>门禁记录界面显示刷门禁的时间日期、人脸相似度、人脸名和姓名；</p><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><h3 id="E-R图"><a href="#E-R图" class="headerlink" title="E-R图"></a>E-R图</h3><p><img src="E-R.png" alt="E-R 图"> </p><h3 id="数据库表结构"><a href="#数据库表结构" class="headerlink" title="数据库表结构"></a>数据库表结构</h3><p><img src="datebase.png" alt="数据库结构表"> </p><p>此系统的数据库设计比较简单，采用腾讯云的 MySQL 数据库，仅需要一个数据库表来记录门禁信息，门禁信息包括时间日期、人脸符记、相似度、人脸名和姓名，其中时间日期是主键。人脸信息的保存并不在此数据库中，Face++ 提供的 API 接口可直接增加和删除人脸，预存人脸也是在 Face++ 的云服务器上，极大的便利了人脸信息的存储，同时也更利于人脸搜索，减少系统响应时间。</p><h2 id="主控模块设计"><a href="#主控模块设计" class="headerlink" title="主控模块设计"></a>主控模块设计</h2><h3 id="程序流程图"><a href="#程序流程图" class="headerlink" title="程序流程图"></a>程序流程图</h3><p><img src="main-contorl.png" alt="主控程序流程图"> </p><h3 id="系统功能描述-1"><a href="#系统功能描述-1" class="headerlink" title="系统功能描述"></a>系统功能描述</h3><p>循环检测触摸开关有无产生高电平，若有则拍照并保存本地，接着调用人脸检测程序将原始的图片以二进制形式上传至Face++云服务，待上传完成之后，若检测到人脸，接着调用人脸搜索API云服务会返回人脸的相似度[7]，主控模块将对返回的结果进行比对判断。如果对比成功，则驱动步进电机开始旋转，否则触发警报模块。最终识别记录信息会上传到腾讯云端数据库，方便获取和查看。</p><h2 id="触发模块设计"><a href="#触发模块设计" class="headerlink" title="触发模块设计"></a>触发模块设计</h2><p>触发模块是一个基于触摸检测 IC (TTP223B) 的电容式点动型触摸开关模块。默认状态输出低电平，模式为低功耗模式；当用手指触摸相应位置时，模块会输出高电平，再次触摸又恢复低电平。模式切换为快速模式；当持续12秒没有触摸时,模式又切换为低功耗模式。</p><h3 id="程序流程图-1"><a href="#程序流程图-1" class="headerlink" title="程序流程图"></a>程序流程图</h3><p><img src="trigger.png" alt="触发模块程序流程图"> </p><h3 id="系统功能描述-2"><a href="#系统功能描述-2" class="headerlink" title="系统功能描述"></a>系统功能描述</h3><p>为了将电平信号传递给主控模块，在每次调用触发模块之前，需要将代码中连接触摸开关 OUT 引脚的 GPIO 设置为 INPUT 模式。程序启动后触摸模块循环检测，当检测到手指触摸时输出高电平给树莓派，如果没有检测到触摸则循环检测直到程序退出。</p><h2 id="拍照模块设计"><a href="#拍照模块设计" class="headerlink" title="拍照模块设计"></a>拍照模块设计</h2><p>本文采用树莓派专用 500W 像素摄像头(含 CSI 接口排线)作为拍照模块,该拍照模块由 OmniVision 公司生产(基于 0V5647 图像处理传感模块)为树莓派 4B 开发板生产的专用拍照模块，兼容性更加优良。</p><p>该拍照模块的核心元件是一个 500w 像素的 CMOS 传感器,支持最大分辨率为 2592X1944 的图片拍摄,同样支持每秒30帧的 1080p 视频拍摄(同时兼容每秒 60 帧的 720P 视频拍摄)。拍照模块与主控模块通过一条 15 芯的排线( CSI 接口)进行连接。具体连接过程如下：先将主控模块上 CSI 接口两端的卡扣拉起，然后将排线插入座中，最后垂直按下两端的卡扣。</p><p>该拍照模块内部提供三个应用程序,分别为：raspistill、raspivid、raspisillyuv，其中 raspivid 用来捕捉视频，raspistill 及 raspistillyuv 则用来捕捉图像。</p><p>应用程序使用了四个 OpenMAX（mmal）组件：camera (摄像)、preview(预览)、encoder (编码)、null_sink。 以上三个应用程序均使用摄像组件, raspivid 使用视频编码组件，raspistill 使用图像编码组件，由于 raspistillyuv 是直接将 YUV 或 RGB 从摄像组件输出到文件，所以不需要编码组件。使用 OpenMAX 的 mmal API 为所有程序进行编写且通过命令行的方式进行调用。本文的设计将通过调用 OpenCV 内部函数的方式进行拍照。</p><h3 id="程序流程图-2"><a href="#程序流程图-2" class="headerlink" title="程序流程图"></a>程序流程图</h3><p><img src="picamera.png" alt="拍照模块程序流程图"> </p><h3 id="系统功能描述-3"><a href="#系统功能描述-3" class="headerlink" title="系统功能描述"></a>系统功能描述</h3><p>初次进入系统将拍照模块功能设置为 enabled (打开)，以便程序调用。在本次的设计中，程序调用 OpenCV 进行拍照处理。当拍照模块的拍照服务启动时将采集的图片保存为 jpg 格式，然后等待下次调用。</p><h2 id="驱动模块设计"><a href="#驱动模块设计" class="headerlink" title="驱动模块设计"></a>驱动模块设计</h2><p>主控模块的 GPIO 口驱动能力相对较弱，驱动电平仅为 3.3V,所以高电平驱动比低电平驱动能力稍弱些。当主控模块直接将输入信号传递给步进电机时，步进电机无法正常工作，所以在本次设计中需要添加一个驱动模块。驱动模块具有放大功率的作用,可以满足在输入信号比较微弱、输出功率比较高的情况下工作。</p><p>步进电机对输入电流需求较高，主控模块的供电能力有限，同时考虑到硬件设计的兼容性，以往的设计常常采用专用接口及驱动电路的方式来解决。驱动电路部分可以采用功率比较高的复合管，例如常见的 ULN2003、L298N 等。驱动模块的工作状态是由主控模块提供的控制信号决定的。在本文驱动模块的电路设计时需要满足以下的要求：</p><p>(1)驱动电路提供的电流波形尽可能的接近矩形波，需要电流的快速上升及快速下降。</p><p>(2)驱动电路输出的功率及运行的效率要求较高，使系统提高运行经济效率。</p><p>经过简单的比对，本文的设计采用 ULN2003 类的驱动 IC (集成电路芯片),该芯片可为步进电机提供小于 0.5A 的电流。</p><p>考虑到门禁系统的实际使用情况，运动过程中不需要加速、减速过程，同.时对转速的要求也比较低，所以将步进电机设置为自启动运行方式。自启动运行方式是指通过控制脉冲速度,从而控制电机的启动和停止的运行方式，该种运行方式不会产生加速或者减速阶段。由于在门禁系统的开启、闭合时需要速度的突然变化，所以需要较大的转矩。同时在实际使用过程中电机有一定的负载，会产生较大的工作噪音,根据常见步进电机的工作特性，只有四相五线式步进电机的满足工作需求。另外考虑到静转矩、步距角、电流、安装难度等多种因素,本文的设计选取 28BYJ4 四相五线式步进电机对门禁系统进行控制。</p><h3 id="程序流程图-3"><a href="#程序流程图-3" class="headerlink" title="程序流程图"></a>程序流程图</h3><p><img src="drive.png" alt="驱动模块程序流程图"> </p><h3 id="系统功能描述-4"><a href="#系统功能描述-4" class="headerlink" title="系统功能描述"></a>系统功能描述</h3><p>驱动步进电机首先设置主控模块相应的引脚为 OUTPUT 模式。当程序中人脸识别检测通过时，主控模块通过驱动模块带动步进电机正转。正转一定的角度后停止，模拟等待人员通过。一段时间后电机反转回到初始位置。</p><h2 id="报警模块设计"><a href="#报警模块设计" class="headerlink" title="报警模块设计"></a>报警模块设计</h2><p>本文设计的是一套完整的门禁系统，报警模块必不可少。本文设计的报警模块由蜂鸣器构成，具体操作流程如下：在程序运行时，触发触摸开关后，每当待检测人员匹配不成功或未检测到人脸，蜂鸣器发出鸣叫。</p><h3 id="程序流程图-4"><a href="#程序流程图-4" class="headerlink" title="程序流程图"></a>程序流程图</h3><p><img src="alarm.png" alt="报警模块程序流程图"> </p><h3 id="系统功能描述-5"><a href="#系统功能描述-5" class="headerlink" title="系统功能描述"></a>系统功能描述</h3><p>蜂鸣器首先设置主控模块相应的引脚为 OUTPUT 模式。当程序中人脸识别检测未通过时，主控模块通过报警模块发出警报，检测通过则触发驱动模块。</p><h1 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h1><h2 id="系统简介"><a href="#系统简介" class="headerlink" title="系统简介"></a>系统简介</h2><p>基于树莓派的人脸识别门禁系统，采用云平台的方式进行人脸识别，可以很大程度上的提高设备的识别效率，使人脸识别技术的应用更加可行，在微机上利用云平台来搭建人脸识别系统，能够使该技术的应用范围变得更广。同时还具有 Web 客户端可方便操作，实时监控家庭画面，远程控制家庭门禁开关，自带警报功能，查看历史门禁记录以及对家庭成员进行管理，可新增、删除或更新人脸信息，使智能门禁系统成为现实。该系统有功耗低、视频流延迟小和响应快的特点，能够改善传统安防领域的安全性、方便性、直观性等。</p><h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><table><thead><tr><th>硬件环境</th><th>应用服务器</th><th>数据库服务器</th><th align="left">客户端</th></tr></thead><tbody><tr><td>硬件配置</td><td>CPU：ARM Cortex-A72 CPU 1.5GHz 四核 64-bit     Memory：4GB</td><td>CPU: Intel(R) Xeon(R) CPU 2394.440 MHZ         Memory：2GB</td><td align="left">CPU: Intel(R) Core(TM) i7-7500 <a href="mailto:&#67;&#x50;&#85;&#x40;&#x32;&#x2e;&#x37;&#x30;&#x47;&#x48;&#122;">&#67;&#x50;&#85;&#x40;&#x32;&#x2e;&#x37;&#x30;&#x47;&#x48;&#122;</a> 2.90 GHz                       Memory: 8GB</td></tr><tr><td>软件配置</td><td>OS: Raspbian  4.18              Flask 1.1.1                       Python 3.7</td><td>OS: Ubuntu  16.04.1          MySQL 5.7.26</td><td align="left">OS: Windows10 1909                                                          Google Chrome 81.0</td></tr><tr><td>网络环境</td><td>100M LAN</td><td>1M LAN</td><td align="left">100M LAN</td></tr></tbody></table><h2 id="测试结论"><a href="#测试结论" class="headerlink" title="测试结论"></a>测试结论</h2><p>系统正确实现了智能门禁的功能，实现了远程监控和操作功能，实现了Web界面。实现了门禁数据管理，人员管理，添加，修改，删除的功能，系统还实现了将权限控制细化到菜单按钮的功能。系统在实现用户管理下的权限管理功能时，存在重大的缺陷，权限控制不严密，权限设计有遗漏[13]。</p><p>现有系统实现了如下易用性：查询，添加，删除，修改操作相关提示信息的一致性，可理解性；输入限制的正确性；输入限制提示信息的正确性，可理解性，一致性。</p><p>现有系统的可靠性控制不够严密，很多控制是通过页面控制实现的，如果页面控制失效，可以向数据库插入数据，引发错误。现有系统的容错性不高，如果系统出现错误，返回错误类型为找不到页面错误，无法回复到出错前的状态。</p><h1 id="设计结果及结论"><a href="#设计结果及结论" class="headerlink" title="设计结果及结论"></a>设计结果及结论</h1><p>本文基于树莓派和旷视人脸识别云平台，实现了一个智能门禁系统．在整个场景模拟试验过程中，无异常报错，系统整体呈现出较强的稳定性，通过试验数据可知系统识别率和实时性都达到了设计的预期要求，系统的外接设备在运行过程中响应良好，识别正确率高，识别成功后的电机进行响应的平均时间为 0.5ｓ，消息远程收发功能、信息管理与控制系统的相关功能均可正常执行。</p><p>虽然系统整体表现良好，但还存在的一个较大问题就是系统的交互性体验还有待提高，在后期的改善过程中，可以引入深度学习的概念，通过对用户的门禁系统的使用数据进行分析，在已有的基础上进行功能扩展，提高用户的使用体验,与同类型产品相比较，本系统在不影响识别精度的前提下，降低了开发生产成本，表现出较强的稳定性，可扩展性强，本文详细描述了整个系统的构建和实现方式，能够为树莓派开发、云平台应用和智能安防等相关领域的同类型产品研发提供一种参考方案。</p><p><a href="https://github.com/gzwangu/Raspberry-Pi-Access-Control">项目源代码</a></p>]]></content>
      
      
      <categories>
          
          <category> 课程实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 树莓派 </tag>
            
            <tag> 门禁系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uCOS-II实验</title>
      <link href="2020/04/25/uCOS-II%E5%AE%9E%E9%AA%8C/"/>
      <url>2020/04/25/uCOS-II%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="多任务调度实验"><a href="#多任务调度实验" class="headerlink" title="多任务调度实验"></a>多任务调度实验</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>编写延时分别为3s、1s和1s的三个任务，观察任务之间的交替运行次序，熟悉任务调度的过程。要求三个任务的输出分别为：M、Y和H，连续不换行显示。</p><h2 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;includes.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK1_PRO     1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK2_PRO     2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK3_PRO     3</span></span><br><span class="line">OS_STK Task1Stk[TASK_STK_SIZE];</span><br><span class="line">OS_STK Task2Stk[TASK_STK_SIZE];</span><br><span class="line">OS_STK Task3Stk[TASK_STK_SIZE];</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Task1</span><span class="params">(<span class="keyword">void</span> *p_arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Task2</span><span class="params">(<span class="keyword">void</span> *p_arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Task3</span><span class="params">(<span class="keyword">void</span> *p_arg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TaskCreate</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">OSTaskCreate(Task1, <span class="literal">NULL</span>, &amp;Task1Stk, TASK1_PRO);</span><br><span class="line">OSTaskCreate(Task2, <span class="literal">NULL</span>, &amp;Task2Stk, TASK2_PRO);</span><br><span class="line">OSTaskCreateExt(Task3, <span class="literal">NULL</span>, &amp;Task3Stk, TASK3_PRO, TASK3_PRO, &amp;Task3Stk[TASK_STK_SIZE - <span class="number">1</span>], TASK_STK_SIZE, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Task1</span><span class="params">(<span class="keyword">void</span> *p_arg)</span></span>&#123;</span><br><span class="line">p_arg = p_arg;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;M&quot;</span>);</span><br><span class="line">OSTimeDlyHMSM(<span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Task2</span><span class="params">(<span class="keyword">void</span> *p_arg)</span></span>&#123;</span><br><span class="line">p_arg = p_arg;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Y&quot;</span>);</span><br><span class="line">OSTimeDlyHMSM(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Task3</span><span class="params">(<span class="keyword">void</span> *p_arg)</span></span>&#123;</span><br><span class="line">p_arg = p_arg;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;H&quot;</span>);</span><br><span class="line">OSTimeDlyHMSM(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p><img src="Scheduling.png" alt="Scheduling"></p><p><img src="analysisScheduling.jpg" alt="analysisScheduling"> </p><h2 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h2><p>第一次对操作系统的代码进行编写调试，深入了解了任务堆栈、创建任务和任务调度，任务间的调度是由cpu在就绪任务中选择最高优先级的任务。调用函数OSStart()之前先创建一个任务，并赋予它最高的优先级别，从而使它成为起始任务。</p><h1 id="利用消息队列进行任务间通信实验"><a href="#利用消息队列进行任务间通信实验" class="headerlink" title="利用消息队列进行任务间通信实验"></a>利用消息队列进行任务间通信实验</h1><h2 id="实验目的-1"><a href="#实验目的-1" class="headerlink" title="实验目的"></a>实验目的</h2><p>仿照《嵌入式实时操作系统uCOS-II原理及应用》（第4版）例4-9，利用先进先出的方式组织消息，由任务一发送消息，任务二和任务三请求消息，三个任务的延时时间均为1s。</p><h2 id="实验代码-1"><a href="#实验代码-1" class="headerlink" title="实验代码"></a>实验代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;includes.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  N_MESSAGES      128<span class="comment">//定义消息队列长度</span></span></span><br><span class="line">OS_STK   TaskStk1[TASK_STK_SIZE];<span class="comment">//定义任务堆栈区</span></span><br><span class="line">OS_STK   TaskStk2[TASK_STK_SIZE];<span class="comment">//定义任务堆栈区</span></span><br><span class="line">OS_STK   TaskStk3[TASK_STK_SIZE];<span class="comment">//定义任务堆栈区</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *ss;</span><br><span class="line"><span class="keyword">char</span> *s100;</span><br><span class="line"><span class="keyword">char</span> *s0;</span><br><span class="line"><span class="keyword">char</span> *s1;</span><br><span class="line"><span class="keyword">char</span> *s500;</span><br><span class="line"><span class="keyword">void</span> *MsgGrp[N_MESSAGES];<span class="comment">//定义消息指针数组</span></span><br><span class="line">INT8U err;</span><br><span class="line"></span><br><span class="line">OS_EVENT *Str_Q;<span class="comment">//定义事件控制块</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">Task1</span><span class="params">(<span class="keyword">void</span> *data)</span></span>;<span class="comment">//声明任务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">Task2</span><span class="params">(<span class="keyword">void</span> *data)</span></span>;<span class="comment">//声明任务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">Task3</span><span class="params">(<span class="keyword">void</span> *data)</span></span>;<span class="comment">//声明任务</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">TaskCreate</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">Str_Q = OSQCreate(&amp;MsgGrp[<span class="number">0</span>], N_MESSAGES);<span class="comment">//创建消息队列</span></span><br><span class="line">OSTaskCreate(Task1,<span class="comment">//创建任务Task1</span></span><br><span class="line">(<span class="keyword">void</span>*)<span class="number">0</span>,<span class="comment">//给任务传递参数</span></span><br><span class="line">&amp;TaskStk1[TASK_STK_SIZE - <span class="number">1</span>],<span class="comment">//设置任务堆栈栈顶</span></span><br><span class="line"><span class="number">0</span>);<span class="comment">//使任务的优先级别为0</span></span><br><span class="line">OSTaskCreate(Task2,<span class="comment">//创建任务Task2</span></span><br><span class="line">(<span class="keyword">void</span>*)<span class="number">0</span>,<span class="comment">//给任务传递参数</span></span><br><span class="line">&amp;TaskStk2[TASK_STK_SIZE - <span class="number">1</span>],<span class="comment">//设置任务堆栈栈顶</span></span><br><span class="line"><span class="number">3</span>);<span class="comment">//使任务的优先级别为3</span></span><br><span class="line">OSTaskCreate(Task3,<span class="comment">//创建任务Task3</span></span><br><span class="line">(<span class="keyword">void</span>*)<span class="number">0</span>,<span class="comment">//给任务传递参数</span></span><br><span class="line">&amp;TaskStk3[TASK_STK_SIZE - <span class="number">1</span>],<span class="comment">//设置任务堆栈栈顶</span></span><br><span class="line"><span class="number">4</span>);<span class="comment">//使任务的优先级别为4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************任务Task1*******************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">Task1</span><span class="params">(<span class="keyword">void</span> *pdata)</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> OS_CRITICAL_METHOD == 3</span></span><br><span class="line">OS_CPU_SR  cpu_sr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">pdata = pdata;</span><br><span class="line">s0 = <span class="string">&quot;这个串能收到几次？&quot;</span>;</span><br><span class="line">OSQPostFront(Str_Q, s0);<span class="comment">//发送消息</span></span><br><span class="line"><span class="keyword">for</span> (;;)&#123;</span><br><span class="line"><span class="keyword">if</span> (OSTimeGet() &gt; <span class="number">0</span> &amp;&amp; OSTimeGet() &lt; <span class="number">200</span>)&#123;<span class="comment">//可以满足两次条件</span></span><br><span class="line">s100 = <span class="string">&quot;现在OSTime的值在0到200之间&quot;</span>;</span><br><span class="line">OSQPostFront(Str_Q, s100);<span class="comment">//发送消息</span></span><br><span class="line">s1 = <span class="string">&quot;这个串是哪个任务收到的？&quot;</span>;</span><br><span class="line">OSQPostFront(Str_Q, s1);<span class="comment">//发送消息</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (OSTimeGet() &gt; <span class="number">2000</span> &amp;&amp; OSTimeGet() &lt; <span class="number">2300</span>)&#123;</span><br><span class="line">s500 = <span class="string">&quot;现在OSTime的值在2000到2300之间&quot;</span>;</span><br><span class="line">OSQPostFront(Str_Q, s500);<span class="comment">//发送消息</span></span><br><span class="line">&#125;</span><br><span class="line">OSTimeDlyHMSM(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);<span class="comment">//等待1秒</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/************************任务Task2*******************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">Task2</span><span class="params">(<span class="keyword">void</span> *pdata)</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> OS_CRITICAL_METHOD == 3</span></span><br><span class="line">OS_CPU_SR  cpu_sr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">pdata = pdata;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;)&#123;</span><br><span class="line">ss = OSQPend(Str_Q, <span class="number">0</span>, &amp;err);  <span class="comment">//请求消息队列                                         </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, ss);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Task2 is running!\n&quot;</span>);</span><br><span class="line">OSTimeDlyHMSM(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);<span class="comment">//等待1秒</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/************************任务Task3******************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">Task3</span><span class="params">(<span class="keyword">void</span> *pdata)</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> OS_CRITICAL_METHOD == 3</span></span><br><span class="line">OS_CPU_SR  cpu_sr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">pdata = pdata;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;)&#123;</span><br><span class="line">ss = OSQPend(Str_Q, <span class="number">0</span>, &amp;err); <span class="comment">//请求消息队列                                          </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, ss);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Task3 is running!\n&quot;</span>);</span><br><span class="line">OSTimeDlyHMSM(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);<span class="comment">//等待1秒</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实验结果-1"><a href="#实验结果-1" class="headerlink" title="实验结果"></a>实验结果</h2><p><img src="Communication.png" alt="Communication"></p><p><img src="analysisCommunication.jpg" alt="analysisCommunication"> </p><h2 id="实验体会-1"><a href="#实验体会-1" class="headerlink" title="实验体会"></a>实验体会</h2><p>通过本次实验进一步掌握了消息队列相当于共用一个任务等待表的消息邮箱数组，向指针数组插入消息指针有两种方式：FIFO和 LIFO，本实验采用的是LIFO（后进先出），任务请求消息队列需要调用函数OSQPend()。</p>]]></content>
      
      
      <categories>
          
          <category> 课程实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> uCOS-II </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于VHDL的数字秒表设计</title>
      <link href="2020/01/19/%E5%9F%BA%E4%BA%8EVHDL%E7%9A%84%E6%95%B0%E5%AD%97%E7%A7%92%E8%A1%A8%E8%AE%BE%E8%AE%A1/"/>
      <url>2020/01/19/%E5%9F%BA%E4%BA%8EVHDL%E7%9A%84%E6%95%B0%E5%AD%97%E7%A7%92%E8%A1%A8%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>当今社会正朝着电子市场发展，越来越多的电子产品应用于各个领域。数字秒表是日常生活中比较常见的电子产品，常用于体育比赛和时间计时，计时的精准性和稳定性是衡量数字秒表最重要的两个指标。现在市场上的数字秒表基本上都能满足计时准确的要求，但很少能满足计时稳定性的要求。本文设计了一种用于精确计时且计时稳定性高的数字秒表，该设计是在Quartus Ⅱ环境下，基于 VHDL语言来编写的，具有开关、计时和显示功能，其计时精度可达0.01s，计时范围较大，计时稳定性好。该设计具有很强的实用性，有着非常广泛的应用。</p><h1 id="实验选题及目标"><a href="#实验选题及目标" class="headerlink" title="实验选题及目标"></a>实验选题及目标</h1><h2 id="实验选题"><a href="#实验选题" class="headerlink" title="实验选题"></a>实验选题</h2><p>在科技高度发展的今天，集成电路和计算机应用得到了高速发展。尤其是计算机应用的发展，它在人们日常生活中已逐渐崭露头角，大多数电子产品多是有计算机电路组成，如：手机、mp3等。而且将来的不久他们的身影将会频繁的出现在我们身边，各种家用电器多会实现微电脑技术，电脑各部分在工作时多是一时间为基准的。</p><p>本文就是基于计算机电路的时钟脉冲信号、状态控制等原理设计出的数字秒表。秒表在很多领域充当一个重要角色，在各种比赛中对秒表的精确度要求很高，尤其是一些科学实验，他们对时间精确度达到了几纳秒级别。数字秒表具有操作方便、使用简单、计数精准等使用优点，在日常生活中的到了广泛认可和使用。</p><h2 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h2><p>设计一块数字秒表，能够精确反映计时时间，并完成复位、计时功能。秒表的计时范围为0秒~ 59分59.99秒，精度为0.01秒，并可显示计时时间的分、秒、毫秒等度量。</p><p>（1）具有秒表系统功能要求显示功能, 用8个数码管分别显示时、分、秒、毫秒，计时范围为00: 00： 00~ 59: 59：99。 </p><p>（2）数字秒表计时精度是0.01s。</p><p>（3）具有启/ 停开关, 复位开关，复位开关在任何情况下都能使用，使计实清零。</p><h1 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h1><p>根据系统设计要求, 系统的底层设计主要由控制模块、分频模块、计时模块、显示模块四部分组成。系统顶层设计图如图所示：</p><p>图中左边为三个输入信号CLK、CLR、SP分别为时钟信号、复位开关和启/ 停开关。主要模块有：分频模块（CB10），时间计数器(COUNT),复位控制(CONTROL)，数据选择模块(MULX),译码器(BCD7)。右边为五个输出信号LED、OUTBCD、SEG、CO、EN分别为七段式LED码值、输出时间值、数码管位选、分频信号和使能信号。</p><p>由模10计数器模块与模6计数器模块进行计数；实验室仪器可产生标准的50mHz的时钟信号，通过分频器模块产生所需的1kHz的时钟信号；复位模块可进行计数器复位操作；译码器是为了将四位二进制信号转换为LED所需的七位二进制编码；状态变换模块是为了用户按键后信号的变换及保持。</p><p><img src="RTL.png" alt="RTL图"></p><h1 id="实验开发环境与器材"><a href="#实验开发环境与器材" class="headerlink" title="实验开发环境与器材"></a>实验开发环境与器材</h1><p>Quartus Ⅱ 9.1和FPGA器件EP2C35F484C8</p><h1 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h1><h2 id="CB10-vhd"><a href="#CB10-vhd" class="headerlink" title="CB10.vhd"></a>CB10.vhd</h2><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LIBRARY</span> IEEE;</span><br><span class="line"><span class="keyword">USE</span> IEEE.STD_LOGIC_1164.<span class="keyword">ALL</span>;</span><br><span class="line"><span class="keyword">USE</span> IEEE.STD_LOGIC_UNSIGNED.<span class="keyword">ALL</span>;</span><br><span class="line"><span class="keyword">ENTITY</span> CB10 <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">PORT</span>(CLK : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC</span>; </span><br><span class="line"> CO : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC</span>);</span><br><span class="line"><span class="keyword">END</span> CB10;</span><br><span class="line"><span class="keyword">ARCHITECTURE</span> one <span class="keyword">OF</span> CB10 <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">SIGNAL</span> CNTER : <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">15</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">PROCESS</span>(CLK)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">IF</span>(RISING_EDGE(CLK)) <span class="keyword">THEN</span> </span><br><span class="line"><span class="keyword">IF</span> CNTER = <span class="string">&quot;1100001101001111&quot;</span> <span class="keyword">THEN</span>   <span class="comment">--49999</span></span><br><span class="line">CNTER&lt;=<span class="string">&quot;0000000000000000&quot;</span>;</span><br><span class="line">CO&lt;=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line">CNTER&lt;=CNTER+<span class="number">1</span>;</span><br><span class="line">CO&lt;=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">PROCESS</span>;</span><br><span class="line"><span class="keyword">END</span> one;</span><br></pre></td></tr></table></figure><h2 id="CONTROL-vhd"><a href="#CONTROL-vhd" class="headerlink" title="CONTROL.vhd"></a>CONTROL.vhd</h2><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LIBRARY</span> IEEE;</span><br><span class="line"><span class="keyword">USE</span> IEEE.STD_LOGIC_1164.<span class="keyword">ALL</span>;</span><br><span class="line"><span class="keyword">USE</span> IEEE.STD_LOGIC_UNSIGNED.<span class="keyword">ALL</span>;</span><br><span class="line"><span class="keyword">ENTITY</span> CONTROL <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">PORT</span>(CLR,CLK,SP : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC</span>;</span><br><span class="line"> EN : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC</span>);</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"><span class="keyword">ARCHITECTURE</span> one <span class="keyword">OF</span> CONTROL <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">TYPE</span> STATES <span class="keyword">IS</span> (S0,S1,S2,S3);</span><br><span class="line"><span class="keyword">SIGNAL</span> CURRENT_STATE,NEXT_STATE:STATES;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">COM:<span class="keyword">PROCESS</span>(SP,CURRENT_STATE)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">CASE</span> CURRENT_STATE <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">WHEN</span> S0=&gt; EN&lt;=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">IF</span> SP=<span class="string">&#x27;1&#x27;</span> <span class="keyword">THEN</span> </span><br><span class="line">NEXT_STATE&lt;=S1;</span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line">NEXT_STATE&lt;=S0;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"><span class="keyword">WHEN</span> S1=&gt; EN&lt;=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"><span class="keyword">IF</span> SP=<span class="string">&#x27;1&#x27;</span> <span class="keyword">THEN</span> </span><br><span class="line">NEXT_STATE&lt;=S1;</span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line">NEXT_STATE&lt;=S2;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"><span class="keyword">WHEN</span> S2=&gt; EN&lt;=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"><span class="keyword">IF</span> SP=<span class="string">&#x27;1&#x27;</span> <span class="keyword">THEN</span> </span><br><span class="line">NEXT_STATE&lt;=S3;</span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line">NEXT_STATE&lt;=S2;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"><span class="keyword">WHEN</span> S3=&gt; EN&lt;=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">IF</span> SP=<span class="string">&#x27;1&#x27;</span> <span class="keyword">THEN</span> </span><br><span class="line">NEXT_STATE&lt;=S3;</span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line">NEXT_STATE&lt;=S0;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">CASE</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">PROCESS</span>;</span><br><span class="line">REG:<span class="keyword">PROCESS</span>(CLK)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">IF</span> CLR=<span class="string">&#x27;1&#x27;</span> <span class="keyword">THEN</span></span><br><span class="line">CURRENT_STATE&lt;=S0;</span><br><span class="line"><span class="keyword">ELSIF</span> CLK<span class="symbol">&#x27;EVENT</span> <span class="keyword">AND</span> CLK=<span class="string">&#x27;1&#x27;</span> <span class="keyword">THEN</span></span><br><span class="line">CURRENT_STATE&lt;=NEXT_STATE;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">PROCESS</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><h2 id="CDU10-vhd"><a href="#CDU10-vhd" class="headerlink" title="CDU10.vhd"></a>CDU10.vhd</h2><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LIBRARY</span> IEEE;</span><br><span class="line"><span class="keyword">USE</span> IEEE.STD_LOGIC_1164.<span class="keyword">ALL</span>;</span><br><span class="line"><span class="keyword">USE</span> IEEE.STD_LOGIC_UNSIGNED.<span class="keyword">ALL</span>;</span><br><span class="line"><span class="keyword">ENTITY</span> CDU10 <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">PORT</span>(CLK,CLR,EN : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC</span>;</span><br><span class="line"> CN : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC</span>;</span><br><span class="line"> COUNT10 : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>));</span><br><span class="line"><span class="keyword">END</span> CDU10;</span><br><span class="line"><span class="keyword">ARCHITECTURE</span> one <span class="keyword">OF</span> CDU10 <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">SIGNAL</span> SCOUNT10 : <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">COUNT10&lt;=SCOUNT10;</span><br><span class="line"><span class="keyword">PROCESS</span>(CLK,CLR,EN)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">IF</span> CLR=<span class="string">&#x27;1&#x27;</span> <span class="keyword">THEN</span></span><br><span class="line">SCOUNT10&lt;=<span class="string">&quot;0000&quot;</span>;</span><br><span class="line">CN&lt;=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">ELSIF</span> RISING_EDGE(CLK) <span class="keyword">THEN</span></span><br><span class="line"><span class="keyword">IF</span> EN=<span class="string">&#x27;1&#x27;</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="keyword">IF</span> SCOUNT10=<span class="string">&quot;1001&quot;</span> <span class="keyword">THEN</span> </span><br><span class="line">CN&lt;=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">SCOUNT10&lt;=<span class="string">&quot;0000&quot;</span>;</span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line">CN&lt;=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">SCOUNT10&lt;=SCOUNT10+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">PROCESS</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><h2 id="CDU6-vhd"><a href="#CDU6-vhd" class="headerlink" title="CDU6.vhd"></a>CDU6.vhd</h2><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LIBRARY</span> IEEE;</span><br><span class="line"><span class="keyword">USE</span> IEEE.STD_LOGIC_1164.<span class="keyword">ALL</span>;</span><br><span class="line"><span class="keyword">USE</span> IEEE.STD_LOGIC_UNSIGNED.<span class="keyword">ALL</span>;</span><br><span class="line"><span class="keyword">ENTITY</span> CDU6 <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">PORT</span>(CLK : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC</span>;</span><br><span class="line"> CLR : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC</span>;</span><br><span class="line"> EN : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC</span>;</span><br><span class="line"> CN : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC</span>;</span><br><span class="line"> COUNT6 : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>));</span><br><span class="line"><span class="keyword">END</span> CDU6;</span><br><span class="line"><span class="keyword">ARCHITECTURE</span> one <span class="keyword">OF</span> CDU6 <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">SIGNAL</span> SCOUNT6 : <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">COUNT6&lt;=SCOUNT6;</span><br><span class="line"><span class="keyword">PROCESS</span>(CLK,CLR,EN)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">IF</span> CLR=<span class="string">&#x27;1&#x27;</span> <span class="keyword">THEN</span></span><br><span class="line">SCOUNT6&lt;=<span class="string">&quot;0000&quot;</span>;</span><br><span class="line">CN&lt;=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">ELSIF</span> RISING_EDGE(CLK) <span class="keyword">THEN</span></span><br><span class="line"><span class="keyword">IF</span> EN=<span class="string">&#x27;1&#x27;</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="keyword">IF</span> SCOUNT6=<span class="string">&quot;0101&quot;</span> <span class="keyword">THEN</span> </span><br><span class="line">CN&lt;=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">SCOUNT6&lt;=<span class="string">&quot;0000&quot;</span>;</span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line">CN&lt;=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">SCOUNT6&lt;=SCOUNT6+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">PROCESS</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><h2 id="COUNT-vhd"><a href="#COUNT-vhd" class="headerlink" title="COUNT.vhd"></a>COUNT.vhd</h2><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LIBRARY</span> IEEE;</span><br><span class="line"><span class="keyword">USE</span> IEEE.STD_LOGIC_1164.<span class="keyword">ALL</span>;</span><br><span class="line"><span class="keyword">ENTITY</span> COUNT <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">PORT</span>(CLK,CLR,EN : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC</span>;</span><br><span class="line"> MS_1MS : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> MS_10MS : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> MS_100MS : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> S_1S : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> S_10S : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> M_1MIN : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> M_10MIN : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> HOUR : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>));</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"><span class="keyword">ARCHITECTURE</span> one <span class="keyword">OF</span> COUNT <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">COMPONENT</span> CDU10</span><br><span class="line"><span class="keyword">PORT</span>(CLK,CLR,EN : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC</span>;</span><br><span class="line"> CN : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC</span>;</span><br><span class="line"> COUNT10 : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>));</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">COMPONENT</span> CDU10;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMPONENT</span> CDU6</span><br><span class="line"><span class="keyword">PORT</span>(CLK,CLR,EN : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC</span>;</span><br><span class="line"> CN : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC</span>;</span><br><span class="line"> COUNT6 : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>));</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">COMPONENT</span> CDU6;</span><br><span class="line"><span class="keyword">SIGNAL</span> A,B,C,D,E,F,G,H : <span class="built_in">STD_LOGIC</span>;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">U1:CDU10 <span class="keyword">PORT</span> <span class="keyword">MAP</span>(CLK=&gt;CLK,CLR=&gt;CLR,EN=&gt;EN,CN=&gt;A,COUNT10=&gt;MS_1MS);</span><br><span class="line">U2:CDU10 <span class="keyword">PORT</span> <span class="keyword">MAP</span>(CLK=&gt;A,CLR=&gt;CLR,EN=&gt;EN,CN=&gt;B,COUNT10=&gt;MS_10MS);</span><br><span class="line">U3:CDU10 <span class="keyword">PORT</span> <span class="keyword">MAP</span>(CLK=&gt;B,CLR=&gt;CLR,EN=&gt;EN,CN=&gt;C,COUNT10=&gt;MS_100MS);</span><br><span class="line">U4:CDU10 <span class="keyword">PORT</span> <span class="keyword">MAP</span>(CLK=&gt;C,CLR=&gt;CLR,EN=&gt;EN,CN=&gt;D,COUNT10=&gt;S_1S);</span><br><span class="line">U5:CDU6  <span class="keyword">PORT</span> <span class="keyword">MAP</span>(CLK=&gt;D,CLR=&gt;CLR,EN=&gt;EN,CN=&gt;E,COUNT6=&gt;S_10S);</span><br><span class="line">U6:CDU10 <span class="keyword">PORT</span> <span class="keyword">MAP</span>(CLK=&gt;E,CLR=&gt;CLR,EN=&gt;EN,CN=&gt;F,COUNT10=&gt;M_1MIN);</span><br><span class="line">U7:CDU6  <span class="keyword">PORT</span> <span class="keyword">MAP</span>(CLK=&gt;F,CLR=&gt;CLR,EN=&gt;EN,CN=&gt;G,COUNT6=&gt;M_10MIN);</span><br><span class="line">U8:CDU10 <span class="keyword">PORT</span> <span class="keyword">MAP</span>(CLK=&gt;G,CLR=&gt;CLR,EN=&gt;EN,CN=&gt;H,COUNT10=&gt;HOUR);</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><h2 id="MUXL-vhd"><a href="#MUXL-vhd" class="headerlink" title="MUXL.vhd"></a>MUXL.vhd</h2><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LIBRARY</span> IEEE;</span><br><span class="line"><span class="keyword">USE</span> IEEE.STD_LOGIC_1164.<span class="keyword">ALL</span>;</span><br><span class="line"><span class="keyword">USE</span> IEEE.STD_LOGIC_UNSIGNED.<span class="keyword">ALL</span>;</span><br><span class="line"><span class="keyword">ENTITY</span> MULX <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">PORT</span>(CLK,CLR,EN : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC</span>;</span><br><span class="line"> MS_1MS : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> MS_10MS : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> MS_100MS : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> S_1S : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> S_10S : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> M_1MIN : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> M_10MIN : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> HOUR : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> OUTBCD : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> SEG : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">7</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>));</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"><span class="keyword">ARCHITECTURE</span> one <span class="keyword">OF</span> MULX <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">SIGNAL</span> COUNT:<span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">PROCESS</span>(CLK)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">IF</span> CLR = <span class="string">&#x27;1&#x27;</span> <span class="keyword">THEN</span></span><br><span class="line">COUNT&lt;=<span class="string">&quot;1111&quot;</span>;</span><br><span class="line"><span class="keyword">ELSIF</span> RISING_EDGE(CLK) <span class="keyword">THEN</span></span><br><span class="line"><span class="keyword">IF</span> EN=<span class="string">&#x27;1&#x27;</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="keyword">IF</span> COUNT=<span class="string">&quot;0111&quot;</span> <span class="keyword">THEN</span></span><br><span class="line">COUNT&lt;=<span class="string">&quot;0000&quot;</span>;</span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line">COUNT&lt;=COUNT+<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">PROCESS</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">PROCESS</span>(CLK)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">IF</span> CLK<span class="symbol">&#x27;EVENT</span> <span class="keyword">AND</span> CLK=<span class="string">&#x27;1&#x27;</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="keyword">CASE</span> COUNT <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">&quot;0000&quot;</span> =&gt; OUTBCD&lt;=MS_1MS; SEG&lt;=<span class="string">&quot;11111110&quot;</span>;</span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">&quot;0001&quot;</span> =&gt; OUTBCD&lt;=MS_10MS; SEG&lt;=<span class="string">&quot;11111101&quot;</span>;</span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">&quot;0010&quot;</span> =&gt; OUTBCD&lt;=MS_100MS; SEG&lt;=<span class="string">&quot;11111011&quot;</span>;</span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">&quot;0011&quot;</span> =&gt; OUTBCD&lt;=S_1S; SEG&lt;=<span class="string">&quot;11110111&quot;</span>;</span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">&quot;0100&quot;</span> =&gt; OUTBCD&lt;=S_10S; SEG&lt;=<span class="string">&quot;11101111&quot;</span>;</span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">&quot;0101&quot;</span> =&gt; OUTBCD&lt;=M_1MIN; SEG&lt;=<span class="string">&quot;11011111&quot;</span>;</span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">&quot;0110&quot;</span> =&gt; OUTBCD&lt;=M_10MIN; SEG&lt;=<span class="string">&quot;10111111&quot;</span>;</span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">&quot;0111&quot;</span> =&gt; OUTBCD&lt;=HOUR; SEG&lt;=<span class="string">&quot;01111111&quot;</span>;</span><br><span class="line"><span class="keyword">WHEN</span> <span class="keyword">OTHERS</span> =&gt; OUTBCD&lt;=<span class="string">&quot;0000&quot;</span>; SEG&lt;=<span class="string">&quot;00000000&quot;</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">CASE</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">PROCESS</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><h2 id="BCD7-vhd"><a href="#BCD7-vhd" class="headerlink" title="BCD7.vhd"></a>BCD7.vhd</h2><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LIBRARY</span> IEEE;</span><br><span class="line"><span class="keyword">USE</span> IEEE.STD_LOGIC_1164.<span class="keyword">ALL</span>;</span><br><span class="line"><span class="keyword">USE</span> IEEE.STD_LOGIC_UNSIGNED.<span class="keyword">ALL</span>;</span><br><span class="line"><span class="keyword">ENTITY</span> BCD7 <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">PORT</span>(BCD: <span class="keyword">IN</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> LED: <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">6</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>));</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"><span class="keyword">ARCHITECTURE</span> one <span class="keyword">OF</span> BCD7 <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line">LED &lt;= <span class="string">&quot;1111110&quot;</span> <span class="keyword">WHEN</span> BCD =<span class="string">&quot;0000&quot;</span> <span class="keyword">ELSE</span></span><br><span class="line">   <span class="string">&quot;0110000&quot;</span> <span class="keyword">WHEN</span> BCD =<span class="string">&quot;0001&quot;</span> <span class="keyword">ELSE</span></span><br><span class="line">   <span class="string">&quot;1101101&quot;</span> <span class="keyword">WHEN</span> BCD =<span class="string">&quot;0010&quot;</span> <span class="keyword">ELSE</span></span><br><span class="line">   <span class="string">&quot;1111001&quot;</span> <span class="keyword">WHEN</span> BCD =<span class="string">&quot;0011&quot;</span> <span class="keyword">ELSE</span></span><br><span class="line">   <span class="string">&quot;0110011&quot;</span> <span class="keyword">WHEN</span> BCD =<span class="string">&quot;0100&quot;</span> <span class="keyword">ELSE</span></span><br><span class="line">   <span class="string">&quot;1011011&quot;</span> <span class="keyword">WHEN</span> BCD =<span class="string">&quot;0101&quot;</span> <span class="keyword">ELSE</span></span><br><span class="line">   <span class="string">&quot;1011111&quot;</span> <span class="keyword">WHEN</span> BCD =<span class="string">&quot;0110&quot;</span> <span class="keyword">ELSE</span></span><br><span class="line">   <span class="string">&quot;1110000&quot;</span> <span class="keyword">WHEN</span> BCD =<span class="string">&quot;0111&quot;</span> <span class="keyword">ELSE</span></span><br><span class="line">   <span class="string">&quot;1111111&quot;</span> <span class="keyword">WHEN</span> BCD =<span class="string">&quot;1000&quot;</span> <span class="keyword">ELSE</span></span><br><span class="line">   <span class="string">&quot;1111011&quot;</span> <span class="keyword">WHEN</span> BCD =<span class="string">&quot;1001&quot;</span> <span class="keyword">ELSE</span></span><br><span class="line">   <span class="string">&quot;0000000&quot;</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><h2 id="Stopwatch-vhd"><a href="#Stopwatch-vhd" class="headerlink" title="Stopwatch.vhd"></a>Stopwatch.vhd</h2><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LIBRARY</span> IEEE;</span><br><span class="line"><span class="keyword">USE</span> IEEE.STD_LOGIC_1164.<span class="keyword">ALL</span>;</span><br><span class="line"><span class="keyword">ENTITY</span> Stopwatch <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">PORT</span>(SP,CLR,CLK :<span class="keyword">IN</span> <span class="built_in">STD_LOGIC</span>;</span><br><span class="line"> CO,EN : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC</span>;</span><br><span class="line"> LED : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">6</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> OUTBCD : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> SEG : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">7</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>));</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"><span class="keyword">ARCHITECTURE</span> ONE <span class="keyword">OF</span> Stopwatch <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">COMPONENT</span> CONTROL </span><br><span class="line"><span class="keyword">PORT</span>(CLR,CLK,SP : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC</span>;</span><br><span class="line"> EN : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC</span>);</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">COMPONENT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMPONENT</span> CB10</span><br><span class="line"><span class="keyword">PORT</span>(CLK : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC</span>;</span><br><span class="line"> CO : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC</span>);</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">COMPONENT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMPONENT</span> COUNT </span><br><span class="line"><span class="keyword">PORT</span>(CLK,CLR,EN : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC</span>;</span><br><span class="line"> MS_1MS : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> MS_10MS : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> MS_100MS : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> S_1S : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> S_10S : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> M_1MIN : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> M_10MIN : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> HOUR : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>));</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">COMPONENT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMPONENT</span> BCD7</span><br><span class="line"><span class="keyword">PORT</span>(BCD: <span class="keyword">IN</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> LED: <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">6</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>));</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">COMPONENT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMPONENT</span> MULX</span><br><span class="line"><span class="keyword">PORT</span>(CLK,CLR,EN : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC</span>;</span><br><span class="line"> MS_1MS : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> MS_10MS : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> MS_100MS : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> S_1S : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> S_10S : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> M_1MIN : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> M_10MIN : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> HOUR : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> OUTBCD : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"> SEG : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">7</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>));</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">COMPONENT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SIGNAL</span> C,E : <span class="built_in">STD_LOGIC</span>;</span><br><span class="line"><span class="keyword">SIGNAL</span> MS1,MS10,MS100 : <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"><span class="keyword">SIGNAL</span> S1,S10 : <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>); </span><br><span class="line"><span class="keyword">SIGNAL</span> MIN1,MIN10 : <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);  </span><br><span class="line"><span class="keyword">SIGNAL</span> HR : <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);    </span><br><span class="line"><span class="keyword">SIGNAL</span> BCD_S : <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);  </span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">U0 : CONTROL <span class="keyword">PORT</span> <span class="keyword">MAP</span>(CLR=&gt;CLR,CLK=&gt;CLK,SP=&gt;SP,EN=&gt;E);</span><br><span class="line">U1 : CB10 <span class="keyword">PORT</span> <span class="keyword">MAP</span>(CLK=&gt;CLK,CO=&gt;C);</span><br><span class="line">U2 : COUNT <span class="keyword">PORT</span> <span class="keyword">MAP</span>(CLK=&gt;C,CLR=&gt;CLR,EN=&gt;E,MS_1MS=&gt;MS1,MS_10MS=&gt;MS10,MS_100MS=&gt;MS100,S_1S=&gt;S1,S_10S=&gt;S10,M_1MIN=&gt;MIN1,M_10MIN=&gt;MIN10,HOUR=&gt;HR);</span><br><span class="line">U3 : MULX <span class="keyword">PORT</span> <span class="keyword">MAP</span>(CLK=&gt;CLK,CLR=&gt;CLR,EN=&gt;E,MS_1MS=&gt;MS1,MS_10MS=&gt;MS10,MS_100MS=&gt;MS100,S_1S=&gt;S1,S_10S=&gt;S10,M_1MIN=&gt;MIN1,M_10MIN=&gt;MIN10,HOUR=&gt;HR,OUTBCD=&gt;BCD_S,SEG=&gt;SEG);</span><br><span class="line">U4 : BCD7 <span class="keyword">PORT</span> <span class="keyword">MAP</span>(BCD=&gt;BCD_S,LED=&gt;LED);</span><br><span class="line">CO&lt;=C;</span><br><span class="line">EN&lt;=E;</span><br><span class="line">OUTBCD&lt;=BCD_S;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><h1 id="实验流程与步骤"><a href="#实验流程与步骤" class="headerlink" title="实验流程与步骤"></a>实验流程与步骤</h1><p>根据系统设计要求, 系统的构成主要由时基分频模块、控制模块、计时模块、显示模块四部分组成，采用自顶向下的方式设计这些模块，系统构成框图如图所示。</p><p> (1) 时基分频模块<br>该分频模块就是把系统工作频率分频后当做定时器的工作频率，例如系统时钟为50MHz，50000分频后定时器的工作时钟为1kHz。</p><p> (2) 控制模块<br>该功能模块是通过对模块的VHDL 程序编译来生成模块的功能元器件，其中<br>VHDL程序采用状态机描述的方式，状态都采用符号化状态。模块的元器件有三个输入端和一个输出端，其中输入端信号为时钟信号CLK、控制信号SP和复位信号CLR。输入信号SP用于控制计数模块的计时状态，在VHDL程序中设置计时模块有四种状态，分别为s0、s1、s2 和 s3，其中 状态s0是保持态，s1是启动态，s2是计数态，s3是停止态。 输出端为使能信号EN，它是高电平有效。整个程序可分为两个进程来分别描述状态转化机和寄存器操作。在VHDL程序中设置输入信号SP变化时计时模块所对应的状态。通过该设置使得系统可通过控制输入信号SP的值来决定计时模块所处的状态。</p><p>（3）计时模块<br>计时模块共需要2个六进制计数器和6个十进制计数器。其中六进制计数器和十进制计数器的描述方法几乎完全一样。考虑到级联的需要，两个计时器除了时钟输入CLK和异步清零CLR之外，另外设计了计数使能输入端EN，该使能端用于控制计时模块是否工作。</p><p>（4）显示模块<br>数据选择的作用是为了选择计时模块每个位置的数字，并将其对应的数字输出，并设置一个位置标志位来显示输出数字为计时数据的哪一位。显示模块用于显示数据选择器输出端BCD的数据，该显示模块采用的是七段译码器的编译码规则，将ASCII 数据转化为对应的七段译码器数据。计时显示电路的实现方案采用扫描显示，即每次只驱动一位数码管，各位数据轮流驱动对应的数码管进行显示。</p><p><img src="block.png" alt="系统构成框图"></p><h1 id="实验结果与分析"><a href="#实验结果与分析" class="headerlink" title="实验结果与分析"></a>实验结果与分析</h1><p>数字秒表系统各个模块及整体仿真图如下：</p><p>（1）时基分频模块仿真</p><p><img src="CB10.png" alt="时基分频模块仿真图"></p><p>CLK是时钟脉冲输入端，CO为分频后信号输出端。由FPGA器件内部50mHZ的时钟脉冲产生秒表需要的1kHZ时钟频率，需要对50mHZ进行50000分频。</p><p>（2）控制模块仿真</p><p>控制模块采用高效的状态机控制，模块有四种状态，分别为s0、s1、s2 和 s3，其中 状态s0是保持态，s1是启动态，s2是计数态，s3是停止态。异步清零，秒表在任何时候都能执行清零操作，SP来控制秒表的开始或关闭。</p><p><img src="CONTROL.png" alt="控制模块仿真图"></p><p>（3）计时模块仿真</p><p>①十进制计数器仿真</p><p><img src="CDU10.png" alt="十进制计数器仿真图"></p><p>图中可以看出十进制计数器的计数功能正常，从0计到9后回0，清零时立即从0开始计时。</p><p>②六进制计数器仿真</p><p><img src="CDU6.png" alt="六进制计数器仿真图"></p><p>图中可以看出六进制计数器的计数功能正常，从0计到5后回0，清零时立即从0开始计时。</p><p>③计时器仿真</p><p><img src="COUNT.png" alt="计时器仿真图"></p><p>计时器功能正常，能够准确计时ms、10ms、100ms、1s、10s、1min、10min、hour位。</p><p>（4）显示模块仿真</p><p>①数据选择器仿真</p><p>数据选择模块选择计时模块每个位置的数字，并将其对应的数字输出，并设置一个位置标志位来显示输出数字为计时数据的哪一位。</p><p><img src="MULX.png" alt="数据选择器仿真图"></p><p>②BCD七段译码器仿真</p><p><img src="BCD7.png" alt="BCD七段译码器仿真图"></p><p>（5）秒表系统仿真</p><p><img src="STOPWATCH.png" alt="秒表系统仿真图"></p><p>秒表系统仿真正常，从ms位到hour位依次刷新扫描，百进制和六十进制正常，异步清零复位正常，系统整体运行良好。由仿真结果可以看出系统具有计时和显示功能，且满足计时精度为10ms，计时范围为0 ～ 59 分 59.99 秒的设计要求，同时计时稳定性高。</p><h1 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h1><p>VHDL作为一种标准硬件描述语言，它除了含有许多具有硬件特征的语句外，其语言形式和描述风格与句法类似一般的计算机高级语言。VHDL有着与其它语言截然不同的地方，那就是它的互动性很强。因为语言的复杂，老师想要教会我们去用这门语言，光是看书或者PPT是不够的，那样在脑海中的印象并不深刻，所以老师让我们尽量带自己的电脑去上课，在课堂上可以跟着老师一起做。 </p><p>通过这次课程设计，我了解到了一些自身的不足：对于模块功能想象力不足，模块设计也总是错误百出，粗心大意是永远会出现的。一开始，感觉数字秒表的功能模块应该很清晰，模块之间的联系很密切，同时，觉得自己对于这种简易电子设备的内部结构应该很熟悉。可是，到了真正操作的时候才发现自己想得太简单了。虽然数字秒表就是些简单的计数器的综合，但是每个计数器的设计也是需要懂很多知识的。而且秒表有复位功能，要考虑到复位时同步清零，清零后还要保持在零的状态，清零是用户进行的操纵，需要有外部输入，又要想暂停、启动的控制，这样就需要状态机的模块进行使能端、清零端的状态转换。这些虽然只是细枝末节，但是真正的编程的成功因素很大一部分都是取决于这些细节。</p><h1 id="附录-VERILOG"><a href="#附录-VERILOG" class="headerlink" title="附录(VERILOG)"></a>附录(VERILOG)</h1><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line">CB10<span class="variable">.v</span></span><br><span class="line"><span class="keyword">module</span> CB10(clk,co);</span><br><span class="line"><span class="keyword">input</span> clk;</span><br><span class="line"><span class="keyword">output</span> co;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] cnter;</span><br><span class="line"><span class="keyword">reg</span> co;</span><br><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span> (cnter==<span class="number">4&#x27;b1001</span>) </span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">cnter = <span class="number">0</span>;</span><br><span class="line">co = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">cnter = cnter + <span class="number">1</span>;</span><br><span class="line">co = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line">CONTROL<span class="variable">.v</span></span><br><span class="line"><span class="keyword">module</span> CONTROL(clk,rst,sp,en);</span><br><span class="line"><span class="keyword">input</span> clk,rst,sp;</span><br><span class="line"><span class="keyword">output</span> en;</span><br><span class="line"><span class="keyword">reg</span> en;</span><br><span class="line"><span class="keyword">parameter</span> s0=<span class="number">0</span>,s1=<span class="number">1</span>,s2=<span class="number">2</span>,s3=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] c_st,n_st;</span><br><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> rst)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span>(rst)</span><br><span class="line">c_st = s0;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">c_st = n_st;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">always</span>@(c_st,sp)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">case</span>(c_st)</span><br><span class="line">s0:<span class="keyword">begin</span> en = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(sp==<span class="number">1</span>)</span><br><span class="line">n_st = s1;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">n_st = s0; <span class="keyword">end</span></span><br><span class="line">s1:<span class="keyword">begin</span> en = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(sp==<span class="number">1</span>)</span><br><span class="line">n_st = s1;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">n_st = s2; <span class="keyword">end</span></span><br><span class="line">s2:<span class="keyword">begin</span> en = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(sp==<span class="number">1</span>)</span><br><span class="line">n_st = s3;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">n_st = s2; <span class="keyword">end</span></span><br><span class="line">s0:<span class="keyword">begin</span> en = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(sp==<span class="number">1</span>)</span><br><span class="line">n_st = s3;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">n_st = s0; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line">CDU10<span class="variable">.v</span></span><br><span class="line"><span class="keyword">module</span> CDU10(clk,rst,en,cn,count10);</span><br><span class="line"><span class="keyword">input</span> clk,rst,en;</span><br><span class="line"><span class="keyword">output</span> cn;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] count10;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] count;</span><br><span class="line"><span class="keyword">reg</span> cn;</span><br><span class="line"><span class="keyword">assign</span> count10 = count;</span><br><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk,<span class="keyword">posedge</span> rst)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span>(rst) <span class="keyword">begin</span></span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line">cn = <span class="number">0</span>; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(en) <span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span>(count==<span class="number">4&#x27;b1001</span>) <span class="keyword">begin</span></span><br><span class="line">cn = <span class="number">1</span>;</span><br><span class="line">count = <span class="number">0</span>; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">cn = <span class="number">0</span>;</span><br><span class="line">count = count+<span class="number">1</span>; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line">CDU6<span class="variable">.v</span></span><br><span class="line"><span class="keyword">module</span> CDU6(clk,rst,en,cn,count6);</span><br><span class="line"><span class="keyword">input</span> clk,rst,en;</span><br><span class="line"><span class="keyword">output</span> cn;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] count6;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] count;</span><br><span class="line"><span class="keyword">reg</span> cn;</span><br><span class="line"><span class="keyword">assign</span> count6 = count;</span><br><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk,<span class="keyword">posedge</span> rst)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span>(rst) <span class="keyword">begin</span></span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line">cn = <span class="number">0</span>; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(en) <span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span>(count==<span class="number">4&#x27;b0101</span>) <span class="keyword">begin</span></span><br><span class="line">cn = <span class="number">1</span>;</span><br><span class="line">count = <span class="number">0</span>; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">cn = <span class="number">0</span>;</span><br><span class="line">count = count+<span class="number">1</span>; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line">TIMER<span class="variable">.v</span></span><br><span class="line"><span class="keyword">module</span> TIMER(clk,rst,en,ms1,ms10,ms100,s1,s10,m1,m10,hour);</span><br><span class="line"><span class="keyword">input</span> clk,rst,en;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] ms1,ms10,ms100,s1,s10,m1,m10,hour;</span><br><span class="line"><span class="keyword">wire</span> a,b,c,d,e,f,g,h;</span><br><span class="line">CDU10 u1(clk,rst,en,a,ms1);</span><br><span class="line">CDU10 u2(a,rst,en,b,ms10);</span><br><span class="line">CDU10 u3(b,rst,en,c,ms100);</span><br><span class="line">CDU10 u4(c,rst,en,d,s1);</span><br><span class="line">CDU6 u5(d,rst,en,e,s10);</span><br><span class="line">CDU10 u6(e,rst,en,f,m1);</span><br><span class="line">CDU6 u7(f,rst,en,g,m10);</span><br><span class="line">CDU10 u8(g,rst,en,h,hour);</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line">MUXL<span class="variable">.v</span></span><br><span class="line"><span class="keyword">module</span> MUXL(clk,rst,en,ms1,ms10,ms100,s1,s10,m1,m10,hour,bcd,seg);</span><br><span class="line"><span class="keyword">input</span> clk,rst,en;</span><br><span class="line"><span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] ms1,ms10,ms100,s1,s10,m1,m10,hour;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] bcd;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] seg;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] count,bcd;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] seg;</span><br><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk,<span class="keyword">posedge</span> rst)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span>(rst)</span><br><span class="line">count = <span class="number">4&#x27;b1111</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">if</span>(en) <span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span> (count==<span class="number">4&#x27;b0111</span>)</span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">count = count + <span class="number">1</span>; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">case</span>(count)</span><br><span class="line"><span class="number">4&#x27;b0000</span>:<span class="keyword">begin</span> bcd = ms1;seg = <span class="number">8&#x27;b11111110</span>; <span class="keyword">end</span></span><br><span class="line"><span class="number">4&#x27;b0001</span>:<span class="keyword">begin</span> bcd = ms10;seg = <span class="number">8&#x27;b11111101</span>; <span class="keyword">end</span></span><br><span class="line"><span class="number">4&#x27;b0010</span>:<span class="keyword">begin</span> bcd = ms100;seg = <span class="number">8&#x27;b11111011</span>; <span class="keyword">end</span></span><br><span class="line"><span class="number">4&#x27;b0011</span>:<span class="keyword">begin</span> bcd = s1;seg = <span class="number">8&#x27;b11110111</span>; <span class="keyword">end</span></span><br><span class="line"><span class="number">4&#x27;b0100</span>:<span class="keyword">begin</span> bcd = s10;seg = <span class="number">8&#x27;b11101111</span>; <span class="keyword">end</span></span><br><span class="line"><span class="number">4&#x27;b0101</span>:<span class="keyword">begin</span> bcd = m1;seg = <span class="number">8&#x27;b11011111</span>; <span class="keyword">end</span></span><br><span class="line"><span class="number">4&#x27;b0110</span>:<span class="keyword">begin</span> bcd = m10;seg = <span class="number">8&#x27;b10111111</span>; <span class="keyword">end</span></span><br><span class="line"><span class="number">4&#x27;b0111</span>:<span class="keyword">begin</span> bcd = hour;seg = <span class="number">8&#x27;b01111111</span>; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">default</span>:<span class="keyword">begin</span> bcd = <span class="number">4&#x27;b0000</span>;seg = <span class="number">8&#x27;b0000000</span>; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line">BCD7<span class="variable">.v</span></span><br><span class="line"><span class="keyword">module</span> BCD7(bcd,led);</span><br><span class="line"><span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] bcd;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">6</span>:<span class="number">0</span>] led;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">6</span>:<span class="number">0</span>] led;</span><br><span class="line"><span class="keyword">always</span>@(*) <span class="keyword">begin</span></span><br><span class="line"><span class="keyword">case</span>(bcd)</span><br><span class="line"><span class="number">4&#x27;b0000</span>:led = <span class="number">7&#x27;b1111110</span>;</span><br><span class="line"><span class="number">4&#x27;b0001</span>:led = <span class="number">7&#x27;b0110000</span>;</span><br><span class="line"><span class="number">4&#x27;b0010</span>:led = <span class="number">7&#x27;b1101101</span>;</span><br><span class="line"><span class="number">4&#x27;b0011</span>:led = <span class="number">7&#x27;b1111001</span>;</span><br><span class="line"><span class="number">4&#x27;b0100</span>:led = <span class="number">7&#x27;b0110011</span>;</span><br><span class="line"><span class="number">4&#x27;b0101</span>:led = <span class="number">7&#x27;b1011011</span>;</span><br><span class="line"><span class="number">4&#x27;b0110</span>:led = <span class="number">7&#x27;b1011111</span>;</span><br><span class="line"><span class="number">4&#x27;b0111</span>:led = <span class="number">7&#x27;b1110000</span>;</span><br><span class="line"><span class="number">4&#x27;b1000</span>:led = <span class="number">7&#x27;b1111111</span>;</span><br><span class="line"><span class="number">4&#x27;b1001</span>:led = <span class="number">7&#x27;b1111011</span>;</span><br><span class="line"><span class="keyword">default</span>:led = <span class="number">7&#x27;b0000000</span>;</span><br><span class="line"><span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line">Stopwatch<span class="variable">.v</span></span><br><span class="line"><span class="keyword">module</span> SPWATCH(clk,rst,sp,co,led,seg);</span><br><span class="line"><span class="keyword">input</span> sp,rst,clk;</span><br><span class="line"><span class="keyword">output</span> co;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">6</span>:<span class="number">0</span>] led;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] seg;</span><br><span class="line"><span class="keyword">wire</span> c,e;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] ms1,ms2,ms3,s1,s2,m1,m2,hr,bcd4;</span><br><span class="line">CONTROL u1(clk,rst,sp,e);</span><br><span class="line">CB10 u2(clk,c);</span><br><span class="line">TIMER u3(c,rst,e,ms1,ms2,ms3,s1,s2,m1,m2,hr);</span><br><span class="line">MUXL u4(clk,rst,e,ms1,ms2,ms3,s1,s2,m1,m2,hr,bcd4,seg);</span><br><span class="line">BCD7 u5(bcd4,led);</span><br><span class="line"><span class="keyword">assign</span> co = c;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 课程实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HDL </tag>
            
            <tag> FPGA </tag>
            
            <tag> VHDL </tag>
            
            <tag> 数字秒表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于单片机的双机通信系统设计</title>
      <link href="2020/01/17/%E5%9F%BA%E4%BA%8E%E5%8D%95%E7%89%87%E6%9C%BA%E7%9A%84%E5%8F%8C%E6%9C%BA%E9%80%9A%E4%BF%A1%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
      <url>2020/01/17/%E5%9F%BA%E4%BA%8E%E5%8D%95%E7%89%87%E6%9C%BA%E7%9A%84%E5%8F%8C%E6%9C%BA%E9%80%9A%E4%BF%A1%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>本次电子设计先自主完成单片机上所有芯片的焊接，经调试确认焊接、硬件等正常工作后，再在单片机的基础上完成双机通信系统的设计。</p><p>双机通信是单片机的一个重要应用，MCS-51系列单片机上有一个通用异步接收／发送器UART，通过引脚RXD[P3．O]和TXD[P3．1]可与另一单片机进行全双工的串行异步通信，发送数据时由TXD端送出，接收时数据由RXD端输入。</p><p>本次课程设计就是要利用单片机来完成一个通信系统，实现两个单片机之间的有序通信。本文详细介绍了关于基于单片机89C52实现双机之间的全双工通信系统设计，软件部分采用C51语言编程实现接收部分和发送部分的功能及其它扩展功能。在Protues上进行仿真，程序软件设计完成后，将程序烧入单片机。在通信过程中，使用通信协议进行通信，通信的结果使用LCD1602液晶显示屏进行显示。</p><h1 id="焊接工艺总结"><a href="#焊接工艺总结" class="headerlink" title="焊接工艺总结"></a><a href="https://wenku.baidu.com/view/38aa1e4f6bd97f192279e9fd.html">焊接工艺总结</a></h1><h2 id="焊接准备"><a href="#焊接准备" class="headerlink" title="焊接准备"></a>焊接准备</h2><p>烙铁头表面覆盖光亮的焊锡，对于保证烙铁头很好地传导热量和焊接点的清洁至关重要。焊接前的准备工作主要是对被氧化的烙铁头进行预处理。如果加热前烙铁头表面沾锡均匀，可不用进行预处理。</p><p>在烙铁架的小盒内准备好清洁海绵并用水浸湿，准备好助焊用的松香。待电烙铁接通电源片刻后，在烙铁头的温度大约达到松香的熔解温度时，将烙铁头插入松香，让其表面涂覆一层松香，再等片刻，待烙铁头温度达到焊锡的熔解温度时，在烙铁头部表面均匀熔化并覆盖一层光亮的锡层。</p><p>如果烙铁头氧化严重，上述步骤无法使烙铁头均匀沾锡，则需要将烙铁头的氧化部位在含有焊锡和松香的铜丝编带上反复磨蹭，直到表面的黑色氧化物完全去除。</p><p>在焊接过程中，如发现烙铁头沾上焦化的助焊剂或其它黑色残留物时，应随时在清洁海绵上擦拭，除去烙铁头部的残留物。如有必要，可将烙铁头放在清洁海绵上数秒钟，降低其温度后再迅速插入松香，这样可以将烙铁头的氧化锡还原，以保持光亮的覆盖层。</p><h2 id="焊接步骤"><a href="#焊接步骤" class="headerlink" title="焊接步骤"></a>焊接步骤</h2><p>（1）准备施焊：首先把被焊件、锡丝和烙铁准备好处于随时可焊的状态。即右手拿烙铁烙铁头应保持干净并吃上锡，左手拿锡丝处于随时可施焊状态。<br>（2）加热焊件：把烙铁头放在接线端子和引线上进行加热。应注意加热整个焊件全体，例如图中导线和接线都要均匀受热。<br>（3）送入焊丝：被焊件经加热达到一定温度后立即将手中的锡丝触到被焊件上使之熔化适量的焊料。注意焊锡应加到被焊件上与烙铁头对称的一侧而不是直接加到烙铁头上。<br>（4）移开焊丝：当锡丝熔化一定量后焊料不能太多迅速移开锡丝。<br>（5）移开烙铁：当焊料的扩散范围达到要求，即焊锡浸润焊盘或焊件的施焊部位后移开电烙铁。撤离烙铁的方向和速度的快慢与焊接质量密切有关，操作时应特别留心仔细体会。  </p><h2 id="焊丝的供应"><a href="#焊丝的供应" class="headerlink" title="焊丝的供应"></a>焊丝的供应</h2><p>（1）供应时刻：原则上是被焊件升温到达焊料的熔化温度是当即送上焊锡丝。<br>（2）供应方位：应是在烙铁与被焊件之间并尽量接近焊盘。<br>（3）供应数量：应看被焊件与焊盘的巨细，焊锡盖住焊盘后焊锡高于焊盘直径的1/3既可。</p><h2 id="焊接注意事项"><a href="#焊接注意事项" class="headerlink" title="焊接注意事项"></a>焊接注意事项</h2><p>（1） 焊接时间不宜过久，但要完全熔著，以免造成冷焊。<br>（2） 焊点的表面要平滑、有光泽。<br>（3） 焊电完全冷却前，不可移动。<br>（4） 电烙铁不用时要放置于电烙铁架上，并随时保持电烙铁的清洁。<br>（5） 焊接完毕，要在烙铁头镀上薄层焊锡，避免氧化，并等冷却后再收存。</p><h1 id="编程思想"><a href="#编程思想" class="headerlink" title="编程思想"></a>编程思想</h1><h2 id="硬件电路设计"><a href="#硬件电路设计" class="headerlink" title="硬件电路设计"></a>硬件电路设计</h2><p>通信过程中双方既是发送方也是接收方，发送方的数据由串行口TXD端输出，经过传输线将信号传送到接收方RXD接收端，接收方也通过传输线将信号送达发送方串行口的接收端。接受方接收后，通过数据口P0及控制口P1的P1.5、P1.6、P1.7在LCD1602上显示接收的信息。相关选择控制按键如输入内容键K1(P3.2)、发送键K2(P3.3)、同意键K3（P3.4）、拒绝键K4（P3.5）、键盘P2等，整体电路设计如图1所示。  </p><h2 id="软件设计"><a href="#软件设计" class="headerlink" title="软件设计"></a>软件设计</h2><p>通过通信协议进行发送接收，甲机先发送‘?’给乙机，当乙机接收到‘?’后，会在LCD屏上显示选择同意或拒绝，如同意和甲机建立通信，则通过按键K3向甲机回答‘Y’，同时甲乙机LCD屏上显示‘Agree’。如拒绝和甲机通信，则通过按键K4向甲机回答‘N’，同时甲乙机LCD屏上显示‘Refuse’，甲机可再次请求建立连接。甲机收到乙机的答复后做出下一步操作。</p><p>当甲机和乙机建立通信后，一方可先按下K3键输入内容，每次发送内容最多可达32个字符，通过单片机上的键盘输入，输入完毕后，按下K4键点击发送，在屏幕下方会提示‘Send Finish’， 另一方收到的内容会在LCD上显示，此时可继续接收或发送信息，为了不影响下次接收的内容显示，可选择按键K3清空LCD屏幕，不清空则接着上次接收内容继续显示。甲乙两机可实现自由的全双工通信，即聊天模式。</p><p>其中键盘是行列式键盘，它是用P2口的4条I/O线作为行线，4条I/O线作为列线组成的键盘。在行线和列线的每一个交叉点上，设置一个按键，这样键盘中按键的个数是16个。通过每次键盘列扫描、按键判断、键值计算三个步骤检测是否有按键按下并返回按下的按键值。</p><p>除了基本的发送和接收功能，该通信系统建立后还可拒收对方信息，即把对方拉黑功能，按下K4键选择拒绝或恢复通信。发送图片音乐也是通信的一大特点，一方向另一方发送播放音乐《我和我的祖国》，播放音乐过程中不干扰正常的通信，可通过键盘中任意键结束音乐播放。</p><p><img src="simulation.png" alt="整体电路设计图"></p><h1 id="程序框图"><a href="#程序框图" class="headerlink" title="程序框图"></a>程序框图</h1><p><img src="process.png" alt="程序流程图">  </p><h1 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h1><h2 id="发送输入"><a href="#发送输入" class="headerlink" title="发送输入"></a>发送输入</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(send_count&lt;<span class="number">32</span>) &#123;  </span><br><span class="line">    key = getKey();   <span class="comment">//获取键值  </span></span><br><span class="line">    <span class="keyword">if</span> (key != <span class="number">-1</span>) &#123;     <span class="comment">//有键按下</span></span><br><span class="line">delayms(<span class="number">10</span>);    <span class="comment">//延时10ms，消除按键抖动</span></span><br><span class="line">        key = getKey();  <span class="comment">//再次获取键值</span></span><br><span class="line">        <span class="keyword">if</span> (key != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(send_count==<span class="number">16</span>)              <span class="comment">//超过16个字符显示在第二行</span></span><br><span class="line">                writecmd_1602(<span class="number">0x80</span>+<span class="number">0x40</span>);</span><br><span class="line">            <span class="keyword">if</span>(key&lt;<span class="number">10</span>) &#123;</span><br><span class="line">                input[send_count++] = <span class="string">&#x27;0&#x27;</span>+key;   <span class="comment">//数字0-9</span></span><br><span class="line">                <span class="keyword">if</span>(send_count==<span class="number">1</span>)</span><br><span class="line">                    writecmd_1602(<span class="number">0x01</span>);  <span class="comment">//清屏Please enter</span></span><br><span class="line">                writedata_1602(<span class="string">&#x27;0&#x27;</span>+key);   <span class="comment">//显示输入的内容</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                input[send_count++] = a_f[key<span class="number">-10</span>];  <span class="comment">//字母a-f</span></span><br><span class="line">                <span class="keyword">if</span>(send_count==<span class="number">1</span>)</span><br><span class="line">                    writecmd_1602(<span class="number">0x01</span>);  <span class="comment">//清屏Please enter</span></span><br><span class="line">                writedata_1602(a_f[key<span class="number">-10</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    P2 = <span class="number">0x0f</span>;        <span class="comment">//判断按键是否松开，防止一直输入</span></span><br><span class="line">    <span class="keyword">while</span>((P2 &amp; <span class="number">0x0f</span>) != <span class="number">0x0f</span>);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h2 id="接收内容"><a href="#接收内容" class="headerlink" title="接收内容"></a>接收内容</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(rec==<span class="string">&#x27;?&#x27;</span>) &#123;       <span class="comment">//接收方</span></span><br><span class="line">    writedata_1602(<span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">    writecmd_1602(<span class="number">0x80</span>+<span class="number">0x40</span>);</span><br><span class="line">    display_1602(<span class="string">&quot;YES:K3 NO:K4&quot;</span>);   <span class="comment">//显示提示信息</span></span><br><span class="line">    writecmd_1602(<span class="number">0x80</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(agree_k3==<span class="number">0</span>) &#123;</span><br><span class="line">            delayms(<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">if</span>(agree_k3==<span class="number">0</span>) &#123;</span><br><span class="line">                SBUF = <span class="string">&#x27;Y&#x27;</span>;   <span class="comment">//发送&#x27;Y&#x27;</span></span><br><span class="line">                rec_count = <span class="number">0</span>;   <span class="comment">//清零准备接收</span></span><br><span class="line">                per_send = <span class="number">1</span>;   <span class="comment">//同时也允许发送</span></span><br><span class="line">                display_1602(<span class="string">&quot;Agree&quot;</span>);  <span class="comment">//显示同意</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(refuse_k4==<span class="number">0</span>) &#123;</span><br><span class="line">            delayms(<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">if</span>(refuse_k4==<span class="number">0</span>) &#123;</span><br><span class="line">                SBUF = <span class="string">&#x27;N&#x27;</span>;   <span class="comment">//发送&#x27;N&#x27;</span></span><br><span class="line">                display_1602(<span class="string">&quot;Refuse&quot;</span>);   <span class="comment">//显示拒绝</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(TI==<span class="number">0</span>);</span><br><span class="line">    TI = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">    rece[rec_count++] = rec;   <span class="comment">//存入接收数组</span></span><br></pre></td></tr></table></figure><h1 id="体会与建议"><a href="#体会与建议" class="headerlink" title="体会与建议"></a>体会与建议</h1><p>1.对电子设计有了更直接的认识，对51单片机也有了更全面的认识，虽然曾经也焊过电路板，无论从原理还是实际操作上来讲那都没法和这次相比。对焊接技术有了更进一步的熟悉，对焊接程序也有了更清晰的认识，也更熟悉了焊接的方法技巧，看着我的焊点从最初的惨不忍睹到最后的爱不释手真的很有成就感。  </p><p>2.对问题的分析处理能力有了很大的进步，由于一开始的盲目行动，我犯了很多低级的错误，比如一开始居然把元件焊在了印制板的反面，先焊了集成块等等。随着设计的进行，我深刻体会到了事前分析规划的重要性，相信这是没有进行过这种实践的人所体会不到的。<br>3.通过这次紧张的电子设计课程，我收获颇多，每天面对着电脑，翻阅各种相关资料，体会颇深。短暂的单片机学习，有种意犹未尽之感，在这次课设中，加深了单片机相关知识的理解，之前的模棱两可已经不存在，这种感觉很好。  </p><p>4.在设计开始的前期，也遇到了麻烦，比如说，由于发送端和接收端的通信协议没有做好，导致数据不能正确的传输，在解决问题的过程中，对于通信协议的协议有了深刻的认知。以及我们的单片机RS-232C接口可能存在一些硬件问题，每次发送和接收都存在很强的信号干扰，最后我们放弃使用RS-232C接口，改用TXD和RXD相接的方法才使得通信成功。</p><p>5.RS-232是目前最常用的一种串行通讯接口。由于RS-232-C接口标准出现较早，难免有不足之处。接口的信号电平值较高，易损坏接口电路的芯片；传输速率较低，在异步传输时，波特率为20Kbps；接口使用一根信号线和另一根信号返回线而构成共地的传输形式，这种共地传输容易产生共模干扰，所以抗噪声干扰性弱；传输距离有限，最大传输距离标准值为50英尺。因此建议使用RS-485标准实现，RS-485接口具有良好的抗噪声干扰性，长的传输距离和多站能力等优点就使其成为首选的串行接口。  </p><p>6.很感谢徐老师的耐心教导，他的幽默让我们觉得亲切，他的认真负责让我们折服。在繁忙的一个学期即将结束之时，我的思想成熟了，这次的电子设计让我找到了方向，让我懂得了很多，有知识方面的，还有人格方面的。我相信，只要不放弃，只要努力，就一定可以！ </p><h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;REG51.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;intrins.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uchar unsigned char</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint unsigned int</span></span><br><span class="line"></span><br><span class="line">sbit been = P1^<span class="number">4</span>;  <span class="comment">//蜂鸣器</span></span><br><span class="line">sbit RS = P1^<span class="number">5</span>;   <span class="comment">//命令/数据</span></span><br><span class="line">sbit RW = P1^<span class="number">6</span>;   <span class="comment">//读/写</span></span><br><span class="line">sbit EN = P1^<span class="number">7</span>;   <span class="comment">//使能</span></span><br><span class="line">sbit agree_k3 = P3^<span class="number">4</span>;   <span class="comment">//同意接收</span></span><br><span class="line">sbit refuse_k4 = P3^<span class="number">5</span>;   <span class="comment">//拒绝接收</span></span><br><span class="line">bit per_send = <span class="number">0</span>;   <span class="comment">//发送允许</span></span><br><span class="line">bit music = <span class="number">0</span>;   <span class="comment">//音乐允许</span></span><br><span class="line">uchar rec;   <span class="comment">//接收的内容</span></span><br><span class="line">uchar send_count = <span class="number">0</span>;  <span class="comment">//发送数组变量</span></span><br><span class="line">uchar rec_count = <span class="number">0</span>;   <span class="comment">//接收数组变量</span></span><br><span class="line">uchar timer1H, timer1L, t;  <span class="comment">//音乐高低音</span></span><br><span class="line">uchar input[<span class="number">32</span>]= &#123;<span class="string">&#x27;\0&#x27;</span>&#125;;    <span class="comment">//发送数组</span></span><br><span class="line">uchar rece[<span class="number">32</span>]= &#123;<span class="string">&#x27;\0&#x27;</span>&#125;;     <span class="comment">//接收数组</span></span><br><span class="line">uchar code key_buf[] = &#123;<span class="number">0xee</span>,<span class="number">0xde</span>,<span class="number">0xbe</span>,<span class="number">0x7e</span>,<span class="number">0xed</span>,<span class="number">0xdd</span>,<span class="number">0xbd</span>,<span class="number">0x7d</span>,<span class="number">0xeb</span>,<span class="number">0xdb</span>,<span class="number">0xbb</span>,<span class="number">0x7b</span>,<span class="number">0xe7</span>,<span class="number">0xd7</span>,<span class="number">0xb7</span>,<span class="number">0x77</span>&#125;;<span class="comment">//按键0-f</span></span><br><span class="line">uchar a_f[]= &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>&#125;;  <span class="comment">//键值a-f</span></span><br><span class="line">uchar code FREQH[] = &#123;   <span class="comment">//我和我的祖国</span></span><br><span class="line">    <span class="number">0xF2</span>, <span class="number">0xF3</span>, <span class="number">0xF5</span>, <span class="number">0xF5</span>, <span class="number">0xF6</span>, <span class="number">0xF7</span>, <span class="number">0xF8</span>,</span><br><span class="line">    <span class="number">0xF9</span>, <span class="number">0xF9</span>, <span class="number">0xFA</span>, <span class="number">0xFA</span>, <span class="number">0xFB</span>, <span class="number">0xFB</span>, <span class="number">0xFC</span>, <span class="number">0xFC</span>,</span><br><span class="line">    <span class="number">0xFC</span>, <span class="number">0xFD</span>, <span class="number">0xFD</span>, <span class="number">0xFD</span>, <span class="number">0xFD</span>, <span class="number">0xFE</span>,</span><br><span class="line">    <span class="number">0xFE</span>, <span class="number">0xFE</span>, <span class="number">0xFE</span>, <span class="number">0xFE</span>, <span class="number">0xFE</span>, <span class="number">0xFE</span>, <span class="number">0xFF</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">uchar code FREQL[] = &#123;</span><br><span class="line">    <span class="number">0x42</span>, <span class="number">0xC1</span>, <span class="number">0x17</span>, <span class="number">0xB6</span>, <span class="number">0xD0</span>, <span class="number">0xD1</span>, <span class="number">0xB6</span>,</span><br><span class="line">    <span class="number">0x21</span>, <span class="number">0xE1</span>, <span class="number">0x8C</span>, <span class="number">0xD8</span>, <span class="number">0x68</span>, <span class="number">0xE9</span>, <span class="number">0x5B</span>, <span class="number">0x8F</span>,</span><br><span class="line">    <span class="number">0xEE</span>, <span class="number">0x44</span>, <span class="number">0x6B</span>, <span class="number">0xB4</span>, <span class="number">0xF4</span>, <span class="number">0x2D</span>,</span><br><span class="line">    <span class="number">0x47</span>, <span class="number">0x77</span>, <span class="number">0xA2</span>, <span class="number">0xB6</span>, <span class="number">0xDA</span>, <span class="number">0xFA</span>, <span class="number">0x16</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">uchar code song[] = &#123;</span><br><span class="line">    <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>,</span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">12</span>,</span><br><span class="line">    <span class="number">6</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">6</span>,</span><br><span class="line">    <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">12</span>,</span><br><span class="line">    <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>,</span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">12</span>,</span><br><span class="line">    <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>,</span><br><span class="line">    <span class="number">6</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>,</span><br><span class="line">    <span class="number">7</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">12</span>,</span><br><span class="line">    <span class="number">8</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">12</span>,</span><br><span class="line">    <span class="number">8</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">12</span>,</span><br><span class="line">    <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>,<span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>,<span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>,<span class="comment">//Me and my country</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delayms</span><span class="params">(uint z)</span> </span>&#123;  <span class="comment">//延时1ms</span></span><br><span class="line">    uint x,y;</span><br><span class="line">    <span class="keyword">for</span>(x=z; x&gt;<span class="number">0</span>; x--)</span><br><span class="line">        <span class="keyword">for</span>(y=<span class="number">110</span>; y&gt;<span class="number">0</span>; y--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay_mc</span><span class="params">(uchar t)</span> </span>&#123;  <span class="comment">//音乐延时</span></span><br><span class="line">    uchar t1;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> t2;</span><br><span class="line">    <span class="keyword">for</span>(t1 = <span class="number">0</span>; t1 &lt; t; t1++)</span><br><span class="line">        <span class="keyword">for</span>(t2 = <span class="number">0</span>; t2 &lt; <span class="number">4000</span>; t2++);</span><br><span class="line">    TR1 = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">musicer</span><span class="params">()</span> interrupt 3 </span>&#123;  <span class="comment">//定时方式1</span></span><br><span class="line">    TR1 = <span class="number">0</span>;</span><br><span class="line">    been = !been;</span><br><span class="line">    TH1 = timer1H;</span><br><span class="line">    TL1 = timer1L;</span><br><span class="line">    TR1 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span> </span>&#123;    <span class="comment">//播放音乐</span></span><br><span class="line">    TH1 = timer1H;</span><br><span class="line">    TL1 = timer1L;</span><br><span class="line">    TR1 = <span class="number">1</span>;</span><br><span class="line">    delay_mc(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">getKey</span><span class="params">()</span> </span>&#123;   <span class="comment">//获取按键</span></span><br><span class="line">    <span class="keyword">char</span> key_scan[] = &#123;<span class="number">0xef</span>, <span class="number">0xdf</span>, <span class="number">0xbf</span>, <span class="number">0x7f</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span> ; i++) &#123;</span><br><span class="line">        P2 = key_scan[i];</span><br><span class="line">        <span class="keyword">if</span> ((P2 &amp; <span class="number">0x0f</span>) != <span class="number">0x0f</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; <span class="number">16</span> ; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (key_buf[j]==P2) <span class="keyword">return</span> j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writecmd_1602</span><span class="params">(uchar cmd)</span> </span>&#123; <span class="comment">//写1602命令</span></span><br><span class="line">    RS = <span class="number">0</span>;</span><br><span class="line">    RW = <span class="number">0</span>;</span><br><span class="line">    P0 = cmd;</span><br><span class="line">    delayms(<span class="number">5</span>);</span><br><span class="line">    EN = <span class="number">1</span>;</span><br><span class="line">    delayms(<span class="number">5</span>);</span><br><span class="line">    EN = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writedata_1602</span><span class="params">(uchar dat)</span> </span>&#123; <span class="comment">//写1602数据</span></span><br><span class="line">    RS = <span class="number">1</span>;</span><br><span class="line">    RW = <span class="number">0</span>;</span><br><span class="line">    P0 = dat;</span><br><span class="line">    delayms(<span class="number">5</span>);</span><br><span class="line">    EN = <span class="number">1</span>;</span><br><span class="line">    delayms(<span class="number">5</span>);</span><br><span class="line">    EN = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_1602</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;   <span class="comment">//1602初始化</span></span><br><span class="line">    EN = <span class="number">0</span>;</span><br><span class="line">    writecmd_1602(<span class="number">0x38</span>);<span class="comment">//模式设置,两行显示，5x8</span></span><br><span class="line">    writecmd_1602(<span class="number">0x0c</span>);<span class="comment">//显示设置,显示开，不显示光标，光标不闪烁</span></span><br><span class="line">    writecmd_1602(<span class="number">0x06</span>);<span class="comment">//显示模式,写入新数据后光标右移,显示不移动</span></span><br><span class="line">    writecmd_1602(<span class="number">0x01</span>);<span class="comment">//清屏</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_1602</span><span class="params">(uchar *dp)</span> </span>&#123; <span class="comment">//1602数据显示</span></span><br><span class="line">    <span class="keyword">while</span>(*dp!= <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        writedata_1602(*dp++);</span><br><span class="line">        delayms(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_mes</span><span class="params">(uchar *mes)</span> </span>&#123;   <span class="comment">//发送信息</span></span><br><span class="line">    <span class="keyword">while</span>(*mes!= <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        SBUF = *mes;</span><br><span class="line">        <span class="keyword">while</span>(TI==<span class="number">0</span>);</span><br><span class="line">        TI = <span class="number">0</span>;</span><br><span class="line">        *mes=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        mes++;</span><br><span class="line">        delayms(<span class="number">50</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inputer</span><span class="params">()</span> interrupt 0 </span>&#123;   <span class="comment">//INT0 输入内容</span></span><br><span class="line">    init_1602();</span><br><span class="line">    delayms(<span class="number">15</span>);</span><br><span class="line">    writecmd_1602(<span class="number">0x80</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(per_send==<span class="number">0</span>) &#123;       <span class="comment">//第一次请求建立通信</span></span><br><span class="line">        writedata_1602(<span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">        SBUF = <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">        <span class="keyword">while</span>(TI==<span class="number">0</span>);</span><br><span class="line">        TI = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;        <span class="comment">//输入发送内容</span></span><br><span class="line">        <span class="keyword">char</span> key = <span class="number">-1</span>;</span><br><span class="line">        send_count = <span class="number">0</span>;</span><br><span class="line">        writecmd_1602(<span class="number">0x0f</span>);<span class="comment">//显示设置,显示开，显示光标，光标闪烁</span></span><br><span class="line">        display_1602(<span class="string">&quot;Please enter&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(send_count&lt;<span class="number">32</span>) &#123;</span><br><span class="line">            key = getKey();</span><br><span class="line">            <span class="keyword">if</span> (key != <span class="number">-1</span>) &#123;</span><br><span class="line">delayms(<span class="number">10</span>);</span><br><span class="line">                key = getKey();</span><br><span class="line">                <span class="keyword">if</span> (key != <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(send_count==<span class="number">16</span>)           <span class="comment">//超过16个字符显示在第二行</span></span><br><span class="line">                        writecmd_1602(<span class="number">0x80</span>+<span class="number">0x40</span>);</span><br><span class="line">                    <span class="keyword">if</span>(key&lt;<span class="number">10</span>) &#123;</span><br><span class="line">                        input[send_count++] = <span class="string">&#x27;0&#x27;</span>+key;</span><br><span class="line">                        <span class="keyword">if</span>(send_count==<span class="number">1</span>)</span><br><span class="line">                            writecmd_1602(<span class="number">0x01</span>); <span class="comment">//清屏Please enter</span></span><br><span class="line">                        writedata_1602(<span class="string">&#x27;0&#x27;</span>+key);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        input[send_count++] = a_f[key<span class="number">-10</span>];</span><br><span class="line">                        <span class="keyword">if</span>(send_count==<span class="number">1</span>)</span><br><span class="line">                            writecmd_1602(<span class="number">0x01</span>); <span class="comment">//清屏Please enter</span></span><br><span class="line">                        writedata_1602(a_f[key<span class="number">-10</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            P2 = <span class="number">0x0f</span>;        <span class="comment">//判断按键是否松开，防止一直输入</span></span><br><span class="line">            <span class="keyword">while</span>((P2 &amp; <span class="number">0x0f</span>) != <span class="number">0x0f</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sender</span><span class="params">()</span> interrupt 2 </span>&#123;   <span class="comment">//INT1发送</span></span><br><span class="line">    send_mes(input);</span><br><span class="line">    send_count = <span class="number">32</span>;  <span class="comment">//结束外部中断0</span></span><br><span class="line">    writecmd_1602(<span class="number">0x0c</span>);</span><br><span class="line">    writecmd_1602(<span class="number">0x80</span>+<span class="number">0x40</span>);</span><br><span class="line">    delayms(<span class="number">10</span>);</span><br><span class="line">    display_1602(<span class="string">&quot;Send Finish&quot;</span>);  <span class="comment">//显示发送完毕</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">receiver</span><span class="params">()</span> interrupt 4 </span>&#123;</span><br><span class="line">    RI = <span class="number">0</span>;</span><br><span class="line">    rec = SBUF;</span><br><span class="line">    init_1602();</span><br><span class="line">    writecmd_1602(<span class="number">0x80</span>);</span><br><span class="line">    <span class="keyword">if</span>(rec==<span class="string">&#x27;Y&#x27;</span>) &#123;</span><br><span class="line">        per_send = <span class="number">1</span>;</span><br><span class="line">        display_1602(<span class="string">&quot;Agree&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(rec==<span class="string">&#x27;N&#x27;</span>) &#123;</span><br><span class="line">        display_1602(<span class="string">&quot;Refuse&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(rec==<span class="string">&#x27;?&#x27;</span>) &#123;       <span class="comment">//接收方</span></span><br><span class="line">        writedata_1602(<span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">        writecmd_1602(<span class="number">0x80</span>+<span class="number">0x40</span>);</span><br><span class="line">        display_1602(<span class="string">&quot;YES:K3 NO:K4&quot;</span>);</span><br><span class="line">        writecmd_1602(<span class="number">0x80</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(agree_k3==<span class="number">0</span>) &#123;</span><br><span class="line">                delayms(<span class="number">10</span>);</span><br><span class="line">                <span class="keyword">if</span>(agree_k3==<span class="number">0</span>) &#123;</span><br><span class="line">                    SBUF = <span class="string">&#x27;Y&#x27;</span>;   <span class="comment">//发送&#x27;Y&#x27;</span></span><br><span class="line">                    rec_count = <span class="number">0</span>;   <span class="comment">//清零准备接收</span></span><br><span class="line">                    per_send = <span class="number">1</span>;   <span class="comment">//同时也允许发送</span></span><br><span class="line">                    display_1602(<span class="string">&quot;Agree&quot;</span>);  <span class="comment">//显示同意</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(refuse_k4==<span class="number">0</span>) &#123;</span><br><span class="line">                delayms(<span class="number">10</span>);</span><br><span class="line">                <span class="keyword">if</span>(refuse_k4==<span class="number">0</span>) &#123;</span><br><span class="line">                    SBUF = <span class="string">&#x27;N&#x27;</span>;   <span class="comment">//发送&#x27;N&#x27;</span></span><br><span class="line">                    display_1602(<span class="string">&quot;Refuse&quot;</span>);   <span class="comment">//显示拒绝</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(TI==<span class="number">0</span>);</span><br><span class="line">        TI = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(rec==<span class="string">&#x27;f&#x27;</span>) &#123;  <span class="comment">//音乐指令</span></span><br><span class="line">        music = <span class="number">1</span>;</span><br><span class="line">        display_1602(<span class="string">&quot;music&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        rece[rec_count++] = rec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    uchar k, i,key;</span><br><span class="line">    been=<span class="number">0</span>;      <span class="comment">//关蜂鸣器</span></span><br><span class="line">    PCON = <span class="number">0X80</span>;  <span class="comment">//波特率加倍</span></span><br><span class="line">    SCON = <span class="number">0X90</span>;  <span class="comment">//通信方式2允许接受</span></span><br><span class="line">    TMOD = <span class="number">0X10</span>; <span class="comment">//音乐定时方式1</span></span><br><span class="line">    IE = <span class="number">0X9d</span>;  <span class="comment">//外部中断0 1 通信中断 定时中断1允许</span></span><br><span class="line">    IT0 = <span class="number">1</span>;  <span class="comment">//INT0</span></span><br><span class="line">    IT1 = <span class="number">1</span>;   <span class="comment">//INT1</span></span><br><span class="line">    PX1 = <span class="number">1</span>;   <span class="comment">//INT1高级中断</span></span><br><span class="line"></span><br><span class="line">    init_1602();</span><br><span class="line">    delayms(<span class="number">15</span>);</span><br><span class="line">    writecmd_1602(<span class="number">0x80</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(rec_count==<span class="number">1</span>) &#123;  <span class="comment">//收到新信息清屏</span></span><br><span class="line">            writecmd_1602(<span class="number">0x01</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(agree_k3==<span class="number">0</span>) &#123;   <span class="comment">//清空上次通信内容</span></span><br><span class="line">            delayms(<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">if</span>(agree_k3==<span class="number">0</span>) &#123;</span><br><span class="line">                uchar *p = rece;</span><br><span class="line">                rec_count = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(*p!= <span class="string">&#x27;\0&#x27;</span>) &#123;  <span class="comment">//清空接收数组，准备下一次接收</span></span><br><span class="line">                    *p++=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(refuse_k4==<span class="number">0</span>) &#123;   <span class="comment">//屏蔽对方信息</span></span><br><span class="line">            delayms(<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">if</span>(refuse_k4==<span class="number">0</span>) &#123;</span><br><span class="line">                ES=!ES;   <span class="comment">//打开或屏蔽对方</span></span><br><span class="line">                <span class="keyword">while</span>(!refuse_k4);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(music) &#123;   <span class="comment">//播放音乐指令</span></span><br><span class="line">            been = <span class="number">1</span>;</span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line">            t = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(t) &#123;</span><br><span class="line">                k = song[i] + <span class="number">7</span> * song[i + <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">                timer1H = FREQH[k];</span><br><span class="line">                timer1L = FREQL[k];</span><br><span class="line">                t = song[i + <span class="number">2</span>];</span><br><span class="line">                i += <span class="number">3</span>;</span><br><span class="line">                sing();</span><br><span class="line">                writecmd_1602(<span class="number">0x80</span>);</span><br><span class="line">                display_1602(rece);</span><br><span class="line">                key = getKey();</span><br><span class="line">                <span class="keyword">if</span> (key != <span class="number">-1</span>) &#123;   <span class="comment">//任意键关闭音乐</span></span><br><span class="line">                    music = <span class="number">0</span>;</span><br><span class="line">                    been = <span class="number">0</span>;</span><br><span class="line">                    writecmd_1602(<span class="number">0x01</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        writecmd_1602(<span class="number">0x80</span>);</span><br><span class="line">        display_1602(rece);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 课程实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C51 </tag>
            
            <tag> 单片机 </tag>
            
            <tag> 双机通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/01/07/hello-world/"/>
      <url>2020/01/07/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Hello Everybody!  </p><p>2017 级CUMT电子信息科学与技术专业</p><p>菜鸡一枚，爱好玩耍</p><p>有问题请邮件联系：<a href="mailto:&#x31;&#x33;&#48;&#x35;&#56;&#x30;&#56;&#51;&#x34;&#48;&#x40;&#x71;&#x71;&#46;&#x63;&#111;&#109;">&#x31;&#x33;&#48;&#x35;&#56;&#x30;&#56;&#51;&#x34;&#48;&#x40;&#x71;&#x71;&#46;&#x63;&#111;&#109;</a></p><p>开始搞事情！</p><p><img src="go.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 关于我 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自我介绍 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
